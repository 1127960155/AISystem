1
00:00:00,000 --> 00:00:11,400
嗨,大家好,我是总笔记,今天我们来到AAB1C系列里面的前端优化也是图优化

2
00:00:11,400 --> 00:00:16,800
里面去讲讲公共词表达式消除,也就是CSE

3
00:00:17,800 --> 00:00:21,600
在公共词表达式CSE这个内容里面其实是比较简单

4
00:00:21,600 --> 00:00:24,400
我们先来看看CSE的一个概念的定义

5
00:00:24,400 --> 00:00:27,800
接着去看看AAB1C里面的CSE怎么去实现的

6
00:00:27,800 --> 00:00:29,400
跟传统的有什么区别

7
00:00:31,000 --> 00:00:33,400
现在我们来展开第一个内容

8
00:00:33,400 --> 00:00:36,600
就是公共词的表达式消除的一个概念的定义

9
00:00:36,600 --> 00:00:41,200
可以看到其实公共词表达式消除是传统编译器优化里面的一个Path

10
00:00:41,200 --> 00:00:45,200
或者其中一个概念在LVM里面它其实是变成了一个Path

11
00:00:45,200 --> 00:00:47,800
在执行优化的时候

12
00:00:47,800 --> 00:00:52,400
编译器会把多个相同的表达式替换成为一个独立的变量

13
00:00:52,400 --> 00:00:53,800
下面我们看一个例子

14
00:00:53,800 --> 00:00:57,800
A等于B×C加G,D等于B×C加E

15
00:00:58,000 --> 00:01:02,200
可以看到这里面有一个公共的词表达式B×C

16
00:01:02,200 --> 00:01:04,600
都有一个公共的词表达式B×C

17
00:01:04,600 --> 00:01:07,600
于是编译器会帮我们做一个替换和优化

18
00:01:07,600 --> 00:01:11,000
这里面AI编辑器就会抽取一个独立的词表达式

19
00:01:11,000 --> 00:01:12,600
Temp等于B×C

20
00:01:12,600 --> 00:01:14,200
然后去做一个替换

21
00:01:14,200 --> 00:01:16,600
A等于Temp加G,D等于Temp加E

22
00:01:16,600 --> 00:01:19,000
抽取出来有什么好处呢

23
00:01:19,000 --> 00:01:21,800
其实很明显在我们计算机里面

24
00:01:21,800 --> 00:01:23,800
抽取了公共词表达式出来了

25
00:01:23,800 --> 00:01:26,600
我们可以把计算结果先存起来

26
00:01:26,600 --> 00:01:28,400
避免下一次的重复的开销

27
00:01:28,400 --> 00:01:32,200
所以说它可以降低重复计算这个表达式的开销

28
00:01:32,200 --> 00:01:35,200
如果我们按照上面的执行方法

29
00:01:35,200 --> 00:01:37,000
我会执行B×C一次

30
00:01:37,000 --> 00:01:39,000
然后再执行B×C第二次

31
00:01:39,000 --> 00:01:42,000
而这里面它只需要执行一次就可以了

32
00:01:42,000 --> 00:01:46,400
我们看一下公共词表达式消除的一个基本的原则

33
00:01:46,400 --> 00:01:49,200
执行这项公共词表的试的优化

34
00:01:49,200 --> 00:01:52,000
是基于表达式的定义可达性的

35
00:01:52,000 --> 00:01:53,800
而什么所谓可达性

36
00:01:53,800 --> 00:01:56,000
就是我们下面的两条定义

37
00:01:56,000 --> 00:01:57,400
那在一个表达式

38
00:01:57,400 --> 00:01:59,200
假设我们以B×C为例子

39
00:01:59,200 --> 00:02:01,800
我们在某个点P被定义为可达

40
00:02:01,800 --> 00:02:02,600
什么叫可达呢

41
00:02:02,600 --> 00:02:05,000
就是从初始的节点到点P

42
00:02:05,000 --> 00:02:09,000
每条路径到达P之前都计算过B×C

43
00:02:09,000 --> 00:02:11,200
而B×C被计算之后

44
00:02:11,200 --> 00:02:13,400
不管是B或者C到达P之前

45
00:02:13,400 --> 00:02:15,400
都没有被重新复制过

46
00:02:15,400 --> 00:02:17,000
回到我们的例子里面

47
00:02:17,000 --> 00:02:19,200
B×C这个计算完time之后

48
00:02:19,200 --> 00:02:20,600
后面不管怎么用了

49
00:02:20,600 --> 00:02:23,000
B和C是没有被重新复制的

50
00:02:23,000 --> 00:02:24,200
这一点很重要

51
00:02:24,200 --> 00:02:26,600
如果B或者C其中一个变量

52
00:02:26,600 --> 00:02:27,600
被重新复制

53
00:02:27,600 --> 00:02:29,600
那这个time的值就会改变了

54
00:02:29,600 --> 00:02:31,800
下面这条公式也就不成立了

55
00:02:31,800 --> 00:02:33,600
它就不是真正的可达了

56
00:02:35,400 --> 00:02:37,200
另外需要注意一点就是

57
00:02:37,200 --> 00:02:40,200
编译器它会去计算整个的成本收益

58
00:02:40,200 --> 00:02:42,400
去判断到底我是重复计算

59
00:02:42,400 --> 00:02:44,000
这个表达式的开销大呢

60
00:02:44,000 --> 00:02:47,000
还是存储这个表达式的内容的开销大呢

61
00:02:47,000 --> 00:02:50,600
如果里面存储的是一个非常大的小数

62
00:02:50,600 --> 00:02:51,400
那这个时候

63
00:02:51,400 --> 00:02:53,600
可能我们需要的存储空间会比较大

64
00:02:53,600 --> 00:02:57,200
但是如果我们只是简单的去做一个两次的计算

65
00:02:57,200 --> 00:03:00,000
我们可能会考虑以计算换空间

66
00:03:00,000 --> 00:03:01,200
就是我重复计算

67
00:03:01,200 --> 00:03:03,000
而不是把它存储起来

68
00:03:03,000 --> 00:03:06,400
这个分析需要结合寄存器等其他因素

69
00:03:06,400 --> 00:03:09,800
而传统的编译器会综合考虑这些问题

70
00:03:10,800 --> 00:03:13,000
现在我们来看一看最后一个principle

71
00:03:13,000 --> 00:03:14,400
就是最后一个原则

72
00:03:14,400 --> 00:03:16,800
编译器的开发者将公共值表达式消除

73
00:03:16,800 --> 00:03:17,800
分为两种

74
00:03:17,800 --> 00:03:19,800
一种是本地的公共值表达式

75
00:03:19,800 --> 00:03:22,600
另外一种是全局的公共值表达式

76
00:03:22,600 --> 00:03:24,400
我们之前在讲LVM的时候

77
00:03:24,400 --> 00:03:26,600
优化的过程有一些是基于基本块的

78
00:03:26,600 --> 00:03:28,400
有一些是基于整个过程的

79
00:03:28,400 --> 00:03:30,200
两种的方式是不一样的

80
00:03:30,200 --> 00:03:32,000
两种的范围也不一样的

81
00:03:33,000 --> 00:03:34,800
了解完公共值表达式的定义之后

82
00:03:34,800 --> 00:03:37,600
我们现在我们来看一下它的一个具体的算法

83
00:03:37,600 --> 00:03:40,600
下面我们要进行一个公共值表达式的抽取

84
00:03:40,600 --> 00:03:43,600
XOPY就是X和Y进行一个计算

85
00:03:44,400 --> 00:03:46,600
我们会从S开始立项的搜索

86
00:03:46,600 --> 00:03:48,000
我们编译器里面的IR

87
00:03:48,000 --> 00:03:49,000
找到距离S

88
00:03:49,000 --> 00:03:51,200
最近执行S跟Y计算

89
00:03:51,200 --> 00:03:53,000
S跟Y一起计算的一个语句

90
00:03:53,000 --> 00:03:55,200
建立一个临时变量U

91
00:03:55,200 --> 00:03:57,800
然后把步骤一找到的一个语句W

92
00:03:57,800 --> 00:03:58,800
进行一个替换

93
00:03:58,800 --> 00:04:01,800
就是XOPY复制给我们的U

94
00:04:01,800 --> 00:04:04,400
而我们的U存到我们的W里面

95
00:04:04,400 --> 00:04:06,400
最后一步我们使用J等于U

96
00:04:06,400 --> 00:04:07,400
去替换我们的S

97
00:04:07,400 --> 00:04:08,800
重复步骤一

98
00:04:08,800 --> 00:04:10,800
直到编译完我们整个IR

99
00:04:10,800 --> 00:04:13,800
就完成了我们的公共值表达式的替换了

100
00:04:14,800 --> 00:04:15,800
现在我们看看

101
00:04:15,800 --> 00:04:17,600
AI编译器里面的公共值表达式

102
00:04:17,600 --> 00:04:19,000
是怎么去消除的

103
00:04:19,000 --> 00:04:20,600
因为AI编译器里面的第一个数

104
00:04:20,600 --> 00:04:22,200
是计算图

105
00:04:22,200 --> 00:04:24,200
它跟传统编译器是不一样的

106
00:04:24,200 --> 00:04:25,400
那对于公共值表达式

107
00:04:25,400 --> 00:04:26,800
我们现在只需要计算

108
00:04:26,800 --> 00:04:28,400
其中一个表达式的值

109
00:04:28,400 --> 00:04:29,600
其他的表达式的值

110
00:04:29,600 --> 00:04:31,600
就可以通过复值或者读内存

111
00:04:31,600 --> 00:04:32,600
就可以得到了

112
00:04:32,600 --> 00:04:35,800
这个过程叫做公共值表达式消除

113
00:04:35,800 --> 00:04:38,000
那它作为传统编译器的手段

114
00:04:38,000 --> 00:04:38,800
也是可以迁移到

115
00:04:38,800 --> 00:04:40,600
深度学习AI编译器里面的

116
00:04:40,600 --> 00:04:43,000
现在我们看看这一个例子

117
00:04:43,000 --> 00:04:45,800
假设现在我有一个数X

118
00:04:45,800 --> 00:04:48,400
然后给我们的OP1 OP2 OP3去执行

119
00:04:48,600 --> 00:04:50,600
那这边也有个OP1 OP2

120
00:04:50,600 --> 00:04:53,800
可以看到OP1 OP2的操作是相同的

121
00:04:53,800 --> 00:04:54,400
于是

122
00:04:54,400 --> 00:04:56,200
AI编译器就会对我们的计算图

123
00:04:56,200 --> 00:04:57,600
进行一个提取

124
00:04:57,600 --> 00:04:59,600
提取我们的公共值表达式出来

125
00:04:59,600 --> 00:05:01,200
变成我们的OP1 OP2

126
00:05:01,200 --> 00:05:03,800
然后再分发给我们的OP3 OP4

127
00:05:03,800 --> 00:05:05,200
分别去执行

128
00:05:05,800 --> 00:05:07,200
从而在我们的计算图里面

129
00:05:07,200 --> 00:05:09,600
搜索具有相同结构的子图

130
00:05:09,600 --> 00:05:11,400
减化整个计算图的结构

131
00:05:11,400 --> 00:05:13,400
从而减少我们的计算的开销

132
00:05:13,400 --> 00:05:15,600
这种方式还是以空间换时间

133
00:05:16,600 --> 00:05:17,800
最重要的一个概念

134
00:05:17,800 --> 00:05:20,000
就是从寻找公共值表达式

135
00:05:20,000 --> 00:05:22,200
变成搜索相同结构的子图

136
00:05:22,200 --> 00:05:24,800
也就是我们鼠标所在的这句话

137
00:05:26,400 --> 00:05:27,800
接下来我们看一下

138
00:05:27,800 --> 00:05:30,200
它具体是怎么实现的一个算法

139
00:05:30,200 --> 00:05:31,600
其实算法很简单

140
00:05:31,600 --> 00:05:34,600
最重要的就是建立后选的哈希表

141
00:05:34,600 --> 00:05:36,000
就是我们黄色的

142
00:05:36,000 --> 00:05:38,400
然后去编译我们的计算图

143
00:05:38,400 --> 00:05:39,400
下面我们来看一下

144
00:05:39,400 --> 00:05:41,400
具体的算法是怎么实现的

145
00:05:41,400 --> 00:05:44,000
这个算法可能分为步骤比较多

146
00:05:44,000 --> 00:05:44,800
文字比较多

147
00:05:44,800 --> 00:05:46,800
我们简单的去理解一下就好了

148
00:05:46,800 --> 00:05:47,800
算法比较简单

149
00:05:47,800 --> 00:05:49,600
但是怎么去优化这个算法

150
00:05:49,600 --> 00:05:51,600
或者找到更好的编译方式

151
00:05:51,600 --> 00:05:54,400
可能是需要我们深入的去思考的

152
00:05:54,400 --> 00:05:55,000
那这个算法

153
00:05:55,000 --> 00:05:56,400
我们以一个最简单

154
00:05:56,400 --> 00:05:58,400
最 naive 的算法来看

155
00:05:58,400 --> 00:05:59,000
首先第一个

156
00:05:59,000 --> 00:06:01,600
我们输入的是一个计算图的 IR

157
00:06:01,600 --> 00:06:03,000
就是我们的 Graph IR

158
00:06:04,000 --> 00:06:05,200
这个 IR 或者计算图

159
00:06:05,200 --> 00:06:07,600
是从我们的 AI 框架里面去获取的

160
00:06:07,600 --> 00:06:08,800
接着我们第一步

161
00:06:08,800 --> 00:06:11,400
是要去获取我们的历后续节点

162
00:06:11,400 --> 00:06:12,600
就是对我们的计算图

163
00:06:12,600 --> 00:06:14,400
进行一个深度优先编译

164
00:06:14,400 --> 00:06:16,200
从我们的根节点开始

165
00:06:17,000 --> 00:06:19,200
所以我们会叫做立项后续

166
00:06:19,200 --> 00:06:21,000
那立项后续的主要作用

167
00:06:21,000 --> 00:06:22,600
就是找到我们的拓扑排序

168
00:06:23,600 --> 00:06:25,400
接着创建一个 Map

169
00:06:25,400 --> 00:06:26,200
那这个 Map

170
00:06:26,200 --> 00:06:28,200
主要是存储我们的公共词表达式的

171
00:06:28,200 --> 00:06:29,000
候选集

172
00:06:29,000 --> 00:06:31,200
也就是在计算图里面

173
00:06:31,200 --> 00:06:32,800
相同结构的几集

174
00:06:32,800 --> 00:06:35,400
接着去编译步骤一得到的一个图

175
00:06:36,000 --> 00:06:37,000
从候选集里面

176
00:06:37,000 --> 00:06:39,200
找找有没有可使用的表达式

177
00:06:39,200 --> 00:06:41,200
那接着我们去编译计算图的

178
00:06:41,200 --> 00:06:42,000
所有节点

179
00:06:42,000 --> 00:06:44,400
去判断是否有公共词表达式

180
00:06:44,400 --> 00:06:46,000
而在编译的过程当中

181
00:06:46,000 --> 00:06:48,600
其实我们是去获取值点的哈希值

182
00:06:48,600 --> 00:06:51,000
然后去计算我们的哈希值的 Key

183
00:06:51,400 --> 00:06:52,000
这个 Key

184
00:06:52,000 --> 00:06:54,000
主要是由节点的输出个数

185
00:06:54,000 --> 00:06:54,800
输出类型

186
00:06:54,800 --> 00:06:56,200
输出节点的 ID

187
00:06:56,200 --> 00:06:58,000
进行组成一个哈希的 Key

188
00:06:58,000 --> 00:06:58,800
那这个 Key

189
00:06:58,800 --> 00:07:01,400
可以保证输出相同的情况下

190
00:07:01,400 --> 00:07:03,800
得到的哈希值都是相同的

191
00:07:04,200 --> 00:07:07,000
接着第4步就是记录到候选集里面

192
00:07:07,000 --> 00:07:08,000
把我们的哈希值

193
00:07:08,000 --> 00:07:09,600
记录到我们的候选集里面

194
00:07:09,600 --> 00:07:10,800
当候选集为空的时候

195
00:07:10,800 --> 00:07:12,400
就第一次遇到这种情况

196
00:07:12,400 --> 00:07:13,600
那我们直接把这个节点

197
00:07:13,600 --> 00:07:15,000
记录进去就好了

198
00:07:16,800 --> 00:07:18,600
然后第5步就是去判断

199
00:07:18,600 --> 00:07:20,200
我们的公共词表达式

200
00:07:20,200 --> 00:07:21,400
就是我们的 Map 里面

201
00:07:21,400 --> 00:07:23,600
假设有了我们怎么去判断

202
00:07:24,600 --> 00:07:25,800
如果我们节点的输入

203
00:07:26,000 --> 00:07:27,400
是来自于 const 节点的

204
00:07:27,400 --> 00:07:30,200
那我们可以保证输入的数据是相同的

205
00:07:30,600 --> 00:07:32,800
而输出个数的类型相同的前提下

206
00:07:32,800 --> 00:07:35,000
我们可以保证输出的结果相同

207
00:07:35,000 --> 00:07:36,000
通过这种方式

208
00:07:36,000 --> 00:07:37,000
我们可以判断

209
00:07:37,000 --> 00:07:39,200
是否可以附用公共词表达式

210
00:07:39,200 --> 00:07:40,400
那最后一步就是

211
00:07:40,400 --> 00:07:41,800
找到公共词表达式之后

212
00:07:42,000 --> 00:07:44,600
我们就去删除重复的节点

213
00:07:45,200 --> 00:07:47,400
记得我们只是删除节点

214
00:07:47,400 --> 00:07:49,200
但是我们也要把上一个节点

215
00:07:49,200 --> 00:07:50,800
跟下一个节点之间的连线

216
00:07:50,800 --> 00:07:51,800
把它连起来

217
00:07:51,800 --> 00:07:54,400
就把边把数据留给它补充起来

218
00:07:54,400 --> 00:07:56,000
不然说你说我删了个节点

219
00:07:56,000 --> 00:07:57,800
但是后续是断了链

220
00:07:58,200 --> 00:08:00,000
计算图就是不完整了

221
00:08:01,400 --> 00:08:03,000
今天我们的内容比较简单

222
00:08:03,000 --> 00:08:05,000
主要是分享了公共词表达式消除

223
00:08:05,000 --> 00:08:07,000
在传统编译器里面的一个概念

224
00:08:07,000 --> 00:08:08,400
它到底是怎么消除的

225
00:08:08,400 --> 00:08:09,800
接着我们去讲了

226
00:08:09,800 --> 00:08:12,800
AI编译器里面的公共词表达式的消除

227
00:08:13,000 --> 00:08:14,400
目的是在计算图里面

228
00:08:14,400 --> 00:08:16,400
找到相同结构的子图

229
00:08:17,000 --> 00:08:19,200
然后对它进行一个消除优化

230
00:08:20,800 --> 00:08:21,600
卷的不行了

231
00:08:21,600 --> 00:08:22,400
卷的不行了

232
00:08:22,400 --> 00:08:24,200
记得一键三连加关注哦

233
00:08:24,200 --> 00:08:25,600
所有的内容都会开源

234
00:08:25,600 --> 00:08:27,400
在下面这条链接里面

235
00:08:27,800 --> 00:08:28,600
拜了个拜

