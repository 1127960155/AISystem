1
00:00:00,000 --> 00:00:09,000
嗨,大家好,我是ZOMBIE

2
00:00:09,000 --> 00:00:16,600
那其实大家会发现我一般录视频的时间都在晚上11点、12点、1点之间

3
00:00:16,600 --> 00:00:19,800
就是没有利用工作的时间去做这个事

4
00:00:19,800 --> 00:00:21,400
我觉得还是比较有意义的

5
00:00:21,400 --> 00:00:23,400
那今天我们回到正式的话题

6
00:00:23,400 --> 00:00:26,400
就是AI编辑器系列里面的前端优化

7
00:00:26,800 --> 00:00:30,600
今天我要给大家汇报的内容叫做代数简化

8
00:00:30,600 --> 00:00:34,800
那可以看到其实我们之前像炼金一样讲了很多

9
00:00:35,200 --> 00:00:37,200
AI编辑器前端的各种优化

10
00:00:37,200 --> 00:00:42,800
数据内存的布局、内存的分配、长量直叠、公共值表达式消除讲了很多

11
00:00:42,800 --> 00:00:46,400
每一个内容看上去都独立无关,比较零散

12
00:00:47,800 --> 00:00:51,600
但实际上我们还是围绕着AI编辑器的前端优化

13
00:00:51,600 --> 00:00:55,400
书是AI框架产生的计算图Graph IR

14
00:00:55,400 --> 00:00:57,400
我们之前讲每一个单独的内容

15
00:00:57,400 --> 00:01:01,200
都可以作为AI编辑器里面前端的一个独立的Path

16
00:01:01,200 --> 00:01:03,400
虽然我们讲了很多零散的内容

17
00:01:03,400 --> 00:01:07,000
但这并不意味着我们的计算图的优化

18
00:01:07,000 --> 00:01:09,400
前端的优化只有这几个Path

19
00:01:09,400 --> 00:01:12,200
希望大家一起去贡献前端优化的Path

20
00:01:12,200 --> 00:01:14,800
让我们前端优化的Path更加明确

21
00:01:14,800 --> 00:01:17,000
而这里面有一点值得注意的

22
00:01:17,000 --> 00:01:18,600
就是虽然我们在前端优化

23
00:01:18,600 --> 00:01:21,600
但实际上在我们训练场景、推理场景

24
00:01:21,600 --> 00:01:24,600
它都有所不同和有所侧重的

25
00:01:24,800 --> 00:01:25,600
那我们今天

26
00:01:27,200 --> 00:01:28,400
回到我们今天的内容

27
00:01:28,400 --> 00:01:29,200
代数简化了

28
00:01:29,200 --> 00:01:29,800
代数简化了

29
00:01:29,800 --> 00:01:31,000
组合分为三个

30
00:01:31,000 --> 00:01:32,800
一个是算术的代数简化

31
00:01:32,800 --> 00:01:34,200
一个是运行的简化

32
00:01:34,200 --> 00:01:35,800
一个是广播的简化

33
00:01:35,800 --> 00:01:37,800
20年后的今天

34
00:01:37,800 --> 00:01:42,000
我才发现初中的数学真的是有用的

35
00:01:42,800 --> 00:01:43,800
现在我们来看一下

36
00:01:43,800 --> 00:01:45,600
三个有什么不一样的区别

37
00:01:55,600 --> 00:01:58,200
代数简化主要是利用交换率

38
00:01:58,200 --> 00:02:01,000
结合率等这些数学的代数的规律

39
00:02:01,000 --> 00:02:03,400
去调整我们计算图里面的执行顺序

40
00:02:03,400 --> 00:02:05,400
或者删除我们计算图里面

41
00:02:05,400 --> 00:02:08,000
没有必要存在的一些算子

42
00:02:08,000 --> 00:02:10,600
来提高我们整个计算图的运行效率

43
00:02:12,200 --> 00:02:15,200
而我们想要去实现代数简化的工作

44
00:02:15,400 --> 00:02:17,600
我们可以通过两种方式来实现

45
00:02:17,600 --> 00:02:19,400
最主要的一个通用的逻辑

46
00:02:19,400 --> 00:02:20,800
就是通过子图的替换

47
00:02:20,800 --> 00:02:24,200
把一些子图换成另外一种子图的方式

48
00:02:24,400 --> 00:02:25,000
具体的实现

49
00:02:25,200 --> 00:02:28,400
我们可以抽象出一套通用的子图的替换的框架

50
00:02:28,400 --> 00:02:30,800
然后对我们提前设定好的规则

51
00:02:31,000 --> 00:02:32,000
进行一个实际化

52
00:02:32,000 --> 00:02:32,800
第二种方式

53
00:02:32,800 --> 00:02:34,800
我们可以针对每一个具体的规则

54
00:02:35,000 --> 00:02:37,000
去实现专门的优化的逻辑

55
00:02:37,000 --> 00:02:38,600
所以这里面很重要的一点

56
00:02:38,600 --> 00:02:41,000
就是我们需要去发现规则

57
00:02:41,000 --> 00:02:42,000
发现规律

58
00:02:42,000 --> 00:02:43,800
编译器就是做这个作用

59
00:02:43,800 --> 00:02:45,000
而发现规律

60
00:02:45,400 --> 00:02:46,800
是我们的系统工程师

61
00:02:46,800 --> 00:02:49,200
AI工程师去专门去做的

62
00:02:49,200 --> 00:02:50,400
所以AI工程师

63
00:02:50,600 --> 00:02:53,000
它其实可以做很多不同的优化

64
00:02:53,000 --> 00:02:54,800
也可以发现很多规律

65
00:02:54,800 --> 00:02:56,400
而且它需要懂算法

66
00:02:56,400 --> 00:02:57,600
才能够更好地知道

67
00:02:57,600 --> 00:02:58,400
我们的子图

68
00:02:58,400 --> 00:02:59,400
我们的计算图

69
00:02:59,400 --> 00:03:00,600
长成什么样子

70
00:03:02,400 --> 00:03:03,200
现在我们来看看

71
00:03:03,200 --> 00:03:04,800
第一个就是算术优化

72
00:03:04,800 --> 00:03:05,600
那算术优化

73
00:03:05,600 --> 00:03:06,400
最重要的就是

74
00:03:06,400 --> 00:03:09,400
利用我们代数之间的一个运算逻辑

75
00:03:09,400 --> 00:03:10,400
在计算图里面

76
00:03:10,400 --> 00:03:12,400
确定我们整个优化的方法

77
00:03:12,400 --> 00:03:14,000
我们现在往下看一下

78
00:03:14,200 --> 00:03:15,600
算术优化里面的第一种

79
00:03:15,600 --> 00:03:18,400
就是结合律的一个化简

80
00:03:18,600 --> 00:03:19,800
可以看到我们这里面

81
00:03:19,800 --> 00:03:21,400
举一个最简单的例子

82
00:03:21,400 --> 00:03:22,600
A乘以根号B

83
00:03:22,600 --> 00:03:23,400
再乘以根号B

84
00:03:23,400 --> 00:03:24,400
乘以根号C

85
00:03:24,600 --> 00:03:25,800
那两个根号B

86
00:03:25,800 --> 00:03:26,600
我们可以结合

87
00:03:26,600 --> 00:03:28,600
变成A乘以B乘以C

88
00:03:28,800 --> 00:03:29,800
这种方式

89
00:03:29,800 --> 00:03:32,600
当然我们有非常多的不同的规则

90
00:03:32,600 --> 00:03:33,200
那这些规则

91
00:03:33,400 --> 00:03:35,000
都是我们提前发现好的

92
00:03:35,000 --> 00:03:36,000
现在我们来看一下

93
00:03:36,000 --> 00:03:37,800
一个最具体的例子

94
00:03:38,000 --> 00:03:40,200
我们现在左边的计算图

95
00:03:40,400 --> 00:03:43,400
就是对应于上面公式的左边

96
00:03:43,400 --> 00:03:45,800
A和B进行卷积之后求逆

97
00:03:45,800 --> 00:03:47,800
然后A和B进行卷积的结果

98
00:03:48,000 --> 00:03:50,000
给我们的C进行一个相乘

99
00:03:50,000 --> 00:03:51,000
最后求逆

100
00:03:51,000 --> 00:03:53,000
最后把这两个结果再相乘

101
00:03:53,000 --> 00:03:55,400
这么一个简单的一个计算逻辑

102
00:03:55,400 --> 00:03:57,800
实际上我们可以把红色的框

103
00:03:58,000 --> 00:03:59,000
提取出来

104
00:03:59,000 --> 00:04:01,000
我们可以把A跟B进行卷积

105
00:04:01,000 --> 00:04:01,600
这个计算

106
00:04:02,200 --> 00:04:03,000
提取出来

107
00:04:03,000 --> 00:04:04,000
A跟B这个计算

108
00:04:04,200 --> 00:04:05,000
提取出来

109
00:04:05,200 --> 00:04:07,000
变成右边的这条公式

110
00:04:07,000 --> 00:04:08,800
那这条公式对应的计算图

111
00:04:08,800 --> 00:04:10,800
就是我们右边的计算图

112
00:04:10,800 --> 00:04:11,800
可以看到了

113
00:04:11,800 --> 00:04:13,600
我们节省了很多的算子

114
00:04:13,600 --> 00:04:16,600
也节省了我们真正的运算的开销

115
00:04:16,800 --> 00:04:18,800
这个就是结合律的化简

116
00:04:21,000 --> 00:04:22,200
接下来我们看一下

117
00:04:22,200 --> 00:04:24,000
第二个算数化简

118
00:04:24,000 --> 00:04:27,000
提取公因式或者分配律的化简

119
00:04:27,400 --> 00:04:29,200
下面我有一条公式

120
00:04:29,200 --> 00:04:31,600
A乘以C加上A乘以B

121
00:04:31,600 --> 00:04:34,200
那这个时候我们可以把A提取出来

122
00:04:34,200 --> 00:04:35,600
然后B加C乘以A

123
00:04:35,600 --> 00:04:38,200
当然我们提取公因式和分配律的

124
00:04:38,200 --> 00:04:38,800
这种化简

125
00:04:39,200 --> 00:04:40,400
有非常多的规则

126
00:04:40,400 --> 00:04:42,400
这里面我们简单列了三条

127
00:04:42,800 --> 00:04:45,200
接下来我们看一下具体的一个例子

128
00:04:45,200 --> 00:04:47,000
A乘以C加上A乘以B

129
00:04:47,000 --> 00:04:48,800
那我们可以把A加B提取出来

130
00:04:48,800 --> 00:04:49,400
乘以C

131
00:04:49,600 --> 00:04:52,200
那就类似于下面这个图所示

132
00:04:52,200 --> 00:04:55,800
我现在AGMMB就是我们的矩阵层

133
00:04:57,000 --> 00:04:58,800
接着把这个结果给C

134
00:04:58,800 --> 00:05:00,200
把这个结果给D

135
00:05:00,200 --> 00:05:01,600
然后再进行相加

136
00:05:01,600 --> 00:05:04,200
这个对应的就是我们左边的这条公式

137
00:05:04,600 --> 00:05:06,800
实际上进行了提取公因式之后

138
00:05:07,000 --> 00:05:09,400
我们就可以把A加上B提取出来

139
00:05:09,400 --> 00:05:11,200
然后把右边的这个框

140
00:05:11,200 --> 00:05:14,400
刚才三个公式变成只有两个公式了

141
00:05:16,400 --> 00:05:18,800
最后一个就是交换律化简

142
00:05:19,000 --> 00:05:20,400
交换律其实很简单

143
00:05:20,400 --> 00:05:22,800
我们以一个最简单的例子来看看

144
00:05:22,800 --> 00:05:25,200
首先我们先对A执行一个一位的操作

145
00:05:25,200 --> 00:05:27,000
然后对它进行reduce sum

146
00:05:27,000 --> 00:05:29,000
其实我们可以把它转换成为

147
00:05:29,000 --> 00:05:30,600
先进行reduce sum

148
00:05:30,800 --> 00:05:32,600
再进行一位的操作

149
00:05:32,600 --> 00:05:34,600
这种方式就是交换律

150
00:05:34,600 --> 00:05:37,200
把两个算子或者两个算幅的操作

151
00:05:37,200 --> 00:05:38,200
进行一个交换

152
00:05:38,200 --> 00:05:39,200
有什么好处吗

153
00:05:39,600 --> 00:05:41,000
A它是一个张量

154
00:05:41,000 --> 00:05:43,600
我对张量里面每一个元素进行位移

155
00:05:43,800 --> 00:05:45,400
它需要很多次运算

156
00:05:45,400 --> 00:05:48,200
然后我再把运算后的结果进行一个聚合

157
00:05:48,400 --> 00:05:50,800
我倒不如先对数据进行聚合

158
00:05:50,800 --> 00:05:52,800
拿到一个小批量的结果之后

159
00:05:53,200 --> 00:05:54,200
再进行位移

160
00:05:54,200 --> 00:05:55,800
这个时候就可以大量的减少

161
00:05:55,800 --> 00:05:57,400
我们整体的运算了

162
00:05:57,400 --> 00:05:59,800
这种就是交换律带来的好处

163
00:06:01,600 --> 00:06:03,200
刚才我提到的这几种方式

164
00:06:03,400 --> 00:06:06,800
其实在这篇文章DNN Fusion里面都有介绍

165
00:06:06,800 --> 00:06:09,400
我也非常鼓励大家去看看这篇文章

166
00:06:11,400 --> 00:06:14,000
接下来我们讲另外一个化简的方法

167
00:06:14,000 --> 00:06:15,400
就是运行化简

168
00:06:15,600 --> 00:06:18,400
主要的目的就是减少运算化执行的时候

169
00:06:18,400 --> 00:06:21,200
勇于的算子或者勇于的算子队

170
00:06:21,200 --> 00:06:23,600
现在我们来看看具体的两个例子

171
00:06:23,600 --> 00:06:25,600
第一个就是对逆函数

172
00:06:25,800 --> 00:06:27,600
第一个就是对逆函数

173
00:06:28,000 --> 00:06:29,400
对逆函数这个数学概念

174
00:06:29,600 --> 00:06:32,400
就是等于自身函数的对和算子

175
00:06:32,400 --> 00:06:34,800
例如有取反倒数逻辑非

176
00:06:34,800 --> 00:06:36,800
还有矩阵转字这种方式

177
00:06:36,800 --> 00:06:39,200
那下面这条公式其实就很明显了

178
00:06:39,200 --> 00:06:42,400
fx的fx是等于x本身

179
00:06:43,000 --> 00:06:46,000
另外还有fx就等于fx的逆

180
00:06:46,200 --> 00:06:49,400
那第二种就是幂等算子的化简

181
00:06:49,400 --> 00:06:51,000
它最重要的算子就是

182
00:06:51,000 --> 00:06:52,400
装在某一元数的两次

183
00:06:52,400 --> 00:06:53,600
其实等于一次

184
00:06:53,600 --> 00:06:55,400
那我们看这条公式很明显

185
00:06:55,400 --> 00:06:58,400
fx的fx等于fx

186
00:06:58,400 --> 00:07:01,400
那这个可能听上去数学概念比较抽象

187
00:07:01,400 --> 00:07:03,000
我们来看一个具体的例子

188
00:07:03,000 --> 00:07:04,200
就是we shape

189
00:07:04,800 --> 00:07:06,600
我们对x进行we shape

190
00:07:06,600 --> 00:07:08,400
然后对x输出的we shape

191
00:07:08,400 --> 00:07:09,600
再进行we shape

192
00:07:09,600 --> 00:07:12,200
其实我们干脆直接对x进行

193
00:07:12,200 --> 00:07:13,800
第二次we shape就完了

194
00:07:15,600 --> 00:07:17,000
那我们看看具体的公式

195
00:07:17,000 --> 00:07:18,200
像对和算子的化简

196
00:07:18,400 --> 00:07:21,600
可能有op1 op1 op2

197
00:07:21,600 --> 00:07:22,800
那这种对和算子

198
00:07:23,000 --> 00:07:24,000
我们其实可以把

199
00:07:24,000 --> 00:07:26,200
相同的对和算子进行优化

200
00:07:26,200 --> 00:07:27,600
把这两个算子都优化了

201
00:07:27,600 --> 00:07:29,400
变成只剩下op2

202
00:07:29,400 --> 00:07:31,600
这种就是对和算子的化简

203
00:07:31,600 --> 00:07:33,600
第二个就是幂等算子的化简

204
00:07:33,600 --> 00:07:36,000
我们可以看到现在我们有三个op

205
00:07:36,000 --> 00:07:37,200
三个操作

206
00:07:37,200 --> 00:07:38,600
我的输是a

207
00:07:38,600 --> 00:07:39,800
那幂等算子

208
00:07:39,800 --> 00:07:41,600
它就可以把相同的算子

209
00:07:41,600 --> 00:07:43,200
变成只有一个

210
00:07:43,200 --> 00:07:44,600
我对a进行we shape

211
00:07:44,600 --> 00:07:46,000
再对结果进行we shape

212
00:07:46,000 --> 00:07:47,200
在第三次we shape

213
00:07:47,200 --> 00:07:48,400
其实我可以直接

214
00:07:48,400 --> 00:07:50,400
执行一次we shape就可以了

215
00:07:50,400 --> 00:07:52,600
这种就是幂等算子的化简

216
00:07:54,400 --> 00:07:57,200
最后一个内容就是广播化简

217
00:07:57,200 --> 00:07:58,400
什么叫广播化简

218
00:07:58,400 --> 00:08:00,200
广播我们叫做broadcast

219
00:08:00,200 --> 00:08:01,600
在PyTorch

220
00:08:01,600 --> 00:08:02,400
或者Modern Sport

221
00:08:02,400 --> 00:08:03,000
TensorFlow

222
00:08:03,000 --> 00:08:04,800
都有对应的算子

223
00:08:04,800 --> 00:08:06,400
那其实我们很好理解

224
00:08:06,400 --> 00:08:08,400
每个算子它的shape都不一样的

225
00:08:08,400 --> 00:08:09,600
但是我们需要

226
00:08:09,600 --> 00:08:11,400
相乘或者相互运算的时候

227
00:08:11,600 --> 00:08:13,200
要对张量的形状

228
00:08:13,200 --> 00:08:14,400
进行对齐

229
00:08:14,400 --> 00:08:15,600
而对齐之前

230
00:08:15,600 --> 00:08:17,600
运用的算子就是broadcast

231
00:08:18,600 --> 00:08:19,800
左边的这条公式

232
00:08:19,800 --> 00:08:21,600
有四个tensor进行相加

233
00:08:21,600 --> 00:08:23,000
但是有两个tensor

234
00:08:23,000 --> 00:08:24,000
它是一个矩阵

235
00:08:24,000 --> 00:08:25,000
有两个tensor

236
00:08:25,200 --> 00:08:27,000
它是一个标量

237
00:08:27,000 --> 00:08:27,800
那这个时候

238
00:08:28,000 --> 00:08:29,400
矩阵加上标量

239
00:08:29,400 --> 00:08:31,200
再加上矩阵加标量

240
00:08:31,200 --> 00:08:34,400
对应的就是我们左边的计算图

241
00:08:35,000 --> 00:08:36,000
首先我们的标量

242
00:08:36,000 --> 00:08:36,600
只有一个数

243
00:08:36,600 --> 00:08:37,600
而我们的矩阵

244
00:08:37,600 --> 00:08:39,400
我们的张量有四个元素

245
00:08:39,400 --> 00:08:40,000
那这个时候

246
00:08:40,000 --> 00:08:41,800
我想要把它们进行相加

247
00:08:41,800 --> 00:08:43,000
就需要语义

248
00:08:43,000 --> 00:08:44,200
Shape上面是对等的

249
00:08:44,200 --> 00:08:45,600
所以我们会对X1

250
00:08:45,600 --> 00:08:47,000
进行一个broadcast

251
00:08:47,000 --> 00:08:49,400
广播变成一个四维的张量之后

252
00:08:49,600 --> 00:08:51,000
才跟我们的Mate 1

253
00:08:51,000 --> 00:08:52,800
四维的张量进行相加

254
00:08:52,800 --> 00:08:55,200
右边的模块也是相同的

255
00:08:55,200 --> 00:08:57,200
这才能够再进行相加

256
00:08:57,200 --> 00:08:58,400
而我们实际上

257
00:08:58,400 --> 00:08:59,800
我们减少一次broadcast

258
00:08:59,800 --> 00:09:01,600
我们可以把两个标量

259
00:09:01,600 --> 00:09:02,800
进行相加之后

260
00:09:02,800 --> 00:09:03,800
再把它broadcast

261
00:09:03,800 --> 00:09:05,600
两个张量直接相加的结果

262
00:09:05,600 --> 00:09:06,800
再进行相加

263
00:09:06,800 --> 00:09:07,600
这种方式

264
00:09:07,600 --> 00:09:09,600
就如右边的这套公式所示

265
00:09:09,600 --> 00:09:11,800
进行了一个广播化解

266
00:09:13,800 --> 00:09:15,800
AI编辑器的前端优化的内容

267
00:09:15,800 --> 00:09:16,800
也到这里为止

268
00:09:18,600 --> 00:09:19,200
谢谢各位

269
00:09:19,200 --> 00:09:20,200
摆了个掰

270
00:09:21,000 --> 00:09:21,800
卷的不行了

271
00:09:21,800 --> 00:09:22,600
卷的不行了

272
00:09:22,600 --> 00:09:24,400
记得一键三连加关注哦

273
00:09:24,400 --> 00:09:25,800
所有的内容都会开源

274
00:09:25,800 --> 00:09:27,600
在下面这条链接里面

275
00:09:28,000 --> 00:09:28,800
摆了个掰

