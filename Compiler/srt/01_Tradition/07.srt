1
00:00:00,000 --> 00:00:07,000
嗨!大家好,我是ZOMI
[字幕生成：奔崩 字幕校对：隔壁小花]

2
00:00:07,000 --> 00:00:09,720
今天来到 LLVM 架构和原理

3
00:00:09,720 --> 00:00:12,680
就是 LLVM 深度剖析的第二节内容

4
00:00:12,680 --> 00:00:14,120
在第二节内容里面

5
00:00:14,120 --> 00:00:18,360
主要去介绍 LLVM 的一个前端的优化过程

6
00:00:18,360 --> 00:00:20,800
和 LLVM 的中间优化过程

7
00:00:21,680 --> 00:00:22,560
在上一节里面

8
00:00:22,680 --> 00:00:24,720
其实讲到了 LLVM 的 IR

9
00:00:24,720 --> 00:00:28,400
贯穿了整个 LLVM 编译器的全生命周期

10
00:00:28,560 --> 00:00:31,760
里面的每一个箭头都有一个 IR 在流窜

11
00:00:31,760 --> 00:00:35,240
这个就是整体 LLVM 最重要的核心概念

12
00:00:35,240 --> 00:00:36,720
有了 LLVM IR 之后

13
00:00:36,720 --> 00:00:40,240
这并不意味着 LLVM 或者编译器的整个 pipeline

14
00:00:40,240 --> 00:00:42,240
都是使用一个单一的 IR

15
00:00:42,240 --> 00:00:43,880
而是在编译的不同阶段

16
00:00:43,880 --> 00:00:45,800
会采用不同的数据结构

17
00:00:45,800 --> 00:00:46,800
但总体来说

18
00:00:46,800 --> 00:00:49,280
还是会维护一个比较标准的 IR

19
00:00:49,280 --> 00:00:53,040
上面来具体的去看看 LLVM 的前端

20
00:00:53,720 --> 00:00:54,680
LLVM 的前端

21
00:00:54,680 --> 00:00:56,160
其实是把原代码

22
00:00:56,200 --> 00:00:58,400
也就是 C, C++, Python, Object C

23
00:00:58,400 --> 00:01:01,080
这些高级语言变为编译器的中间表示

24
00:01:01,080 --> 00:01:02,760
就是 LLVM 的 IR

25
00:01:02,760 --> 00:01:05,400
这个时候它处于代码生成之前

26
00:01:05,920 --> 00:01:06,880
代码生成之后

27
00:01:07,080 --> 00:01:08,720
就是跟目标所相关的

28
00:01:08,720 --> 00:01:10,320
跟硬件所相关的

29
00:01:10,320 --> 00:01:11,800
而代码生成之前

30
00:01:12,000 --> 00:01:14,000
是跟目标没关系的

31
00:01:14,000 --> 00:01:16,320
统一都会变成 LLVM IR

32
00:01:16,320 --> 00:01:18,600
所以在前端的最后一个环节

33
00:01:18,600 --> 00:01:20,280
是 IR 的生成

34
00:01:20,640 --> 00:01:21,320
一般来说

35
00:01:21,520 --> 00:01:24,720
前端都会处理一组相同或者相类似的语言

36
00:01:24,720 --> 00:01:27,160
所以 Cling 在美语里面读 Cling

37
00:01:27,160 --> 00:01:28,720
在英语里面读 Cline

38
00:01:29,480 --> 00:01:32,360
这个 Kling 主要是处理 C, C++, Object C

39
00:01:32,360 --> 00:01:34,640
这一类相类似 C 的语言

40
00:01:35,080 --> 00:01:37,360
前端主要是经历了三个步骤

41
00:01:37,360 --> 00:01:38,360
一个是词法分析

42
00:01:38,360 --> 00:01:39,280
一个是语法分析

43
00:01:39,280 --> 00:01:40,880
另外一个是语义分析

44
00:01:40,880 --> 00:01:42,720
让 IR 生成这个是最通用的

45
00:01:42,720 --> 00:01:44,840
基本上 LLVM 每一个对接的前端

46
00:01:44,840 --> 00:01:45,840
都会有一个

47
00:01:46,000 --> 00:01:48,480
所以后面会深入的去看看词法分析

48
00:01:48,480 --> 00:01:49,240
语法分析

49
00:01:49,240 --> 00:01:50,640
还有语义分析

50
00:01:51,280 --> 00:01:52,840
编译器前端的第一个步骤

51
00:01:52,960 --> 00:01:54,760
就做词法分析

52
00:01:54,760 --> 00:01:55,840
Let's go analyze

53
00:01:55,840 --> 00:01:58,520
它的输入是高级语言的文本

54
00:01:58,520 --> 00:02:00,240
这里面词法分析

55
00:02:00,240 --> 00:02:01,600
主要是将语言的结构

56
00:02:01,720 --> 00:02:03,800
分为一组单词和标记

57
00:02:04,040 --> 00:02:05,840
把一些空白注释

58
00:02:05,960 --> 00:02:08,240
还有字表符等其他没有用的东西

59
00:02:08,480 --> 00:02:10,120
先把它删除掉

60
00:02:10,120 --> 00:02:12,520
然后变成一组单词和标记

61
00:02:13,240 --> 00:02:16,360
下面以最简单的 Hello World 为例子

62
00:02:16,480 --> 00:02:18,040
这段代码比较简单

63
00:02:18,040 --> 00:02:19,560
定义了一个红 Hello World

64
00:02:19,560 --> 00:02:20,840
然后把它打印出来

65
00:02:20,840 --> 00:02:21,800
返回 0

66
00:02:22,200 --> 00:02:24,680
这里面所指的每个单词或者标记

67
00:02:24,840 --> 00:02:26,480
都必须属于高级语言

68
00:02:26,480 --> 00:02:28,320
或者 C 语言的一个子集

69
00:02:28,320 --> 00:02:29,640
语言里面的保留字

70
00:02:29,760 --> 00:02:31,760
就会变成编译器的内部表示

71
00:02:32,000 --> 00:02:33,600
也就是 IR

72
00:02:33,600 --> 00:02:34,880
在词法分析的第一步

73
00:02:35,000 --> 00:02:35,880
可以看到

74
00:02:35,880 --> 00:02:37,680
编译器把每一个符号

75
00:02:37,680 --> 00:02:38,640
每一个括号

76
00:02:38,640 --> 00:02:39,800
每一个字符

77
00:02:39,800 --> 00:02:41,440
全都分解出来

78
00:02:41,440 --> 00:02:44,560
还记录了每一个字符出现的一个 location

79
00:02:44,560 --> 00:02:46,240
Hello.c 里面的第6行

80
00:02:46,240 --> 00:02:47,480
第12个字符

81
00:02:48,400 --> 00:02:49,720
这么做最重要的目的

82
00:02:49,840 --> 00:02:51,960
就是将术语的高级语言

83
00:02:52,840 --> 00:02:55,600
切分成一个个语言的元组

84
00:02:55,960 --> 00:02:57,600
方便下一个步骤的分析

85
00:02:57,600 --> 00:02:58,480
那现在来看看

86
00:02:58,480 --> 00:03:00,120
第二个步骤做的哪些工作

87
00:03:00,160 --> 00:03:02,480
第二个步骤叫做语法分析

88
00:03:03,320 --> 00:03:04,840
Synthetical Analyze

89
00:03:05,880 --> 00:03:07,600
在词法分析标记完

90
00:03:07,600 --> 00:03:08,880
整个原代码之后

91
00:03:09,080 --> 00:03:11,040
语法分析就开始工作了

92
00:03:11,160 --> 00:03:13,360
这里面以表达式语句

93
00:03:13,360 --> 00:03:15,400
函数等不同的方式

94
00:03:15,400 --> 00:03:17,280
去进行一个分组的标记

95
00:03:17,480 --> 00:03:18,680
分组标记完之后

96
00:03:18,840 --> 00:03:20,400
就是方便语法分析器

97
00:03:20,600 --> 00:03:21,920
去检查每一组

98
00:03:21,920 --> 00:03:23,360
是否有真正的物理意义

99
00:03:23,360 --> 00:03:24,680
而这里面的物理意义

100
00:03:24,880 --> 00:03:27,040
主要是讲它这行代码写的对

101
00:03:27,040 --> 00:03:27,880
还是没对

102
00:03:28,600 --> 00:03:30,320
重点就是考虑代码的

103
00:03:30,320 --> 00:03:31,600
整个物理的布局

104
00:03:31,600 --> 00:03:33,320
可以看到这里面有一级二级

105
00:03:33,320 --> 00:03:34,840
然后一层层地加

106
00:03:34,840 --> 00:03:37,200
然后整体类似一个数的概念

107
00:03:37,240 --> 00:03:39,240
这种方式就是语法分析里面

108
00:03:39,240 --> 00:03:41,080
去考虑代码的物理布局

109
00:03:42,240 --> 00:03:43,120
但是到这一步

110
00:03:43,240 --> 00:03:44,440
其实并没有去分析

111
00:03:44,440 --> 00:03:46,000
代码的整体的含义

112
00:03:46,000 --> 00:03:48,280
通俗点来说就是语法分析器

113
00:03:48,280 --> 00:03:50,680
并不管这段代码是干什么了

114
00:03:51,040 --> 00:03:52,720
只考虑这段代码是否正确

115
00:03:52,720 --> 00:03:54,040
并且输出语法树

116
00:03:54,400 --> 00:03:55,960
接收词法分析器标数的

117
00:03:55,960 --> 00:03:57,160
token作为一个输入

118
00:03:57,160 --> 00:03:58,760
然后输出语法树

119
00:03:58,760 --> 00:04:00,040
也就是AST

120
00:04:00,160 --> 00:04:01,560
图中的这段表示

121
00:04:01,720 --> 00:04:02,960
只是方便去看

122
00:04:02,960 --> 00:04:04,440
实际上代码语法树

123
00:04:04,840 --> 00:04:05,800
里面每一个节点

124
00:04:05,920 --> 00:04:07,280
都是有自己的定义的

125
00:04:08,160 --> 00:04:10,160
第三步就是语义分析

126
00:04:10,160 --> 00:04:11,560
Semantic Analyzed

127
00:04:11,560 --> 00:04:12,920
刚才语法分析

128
00:04:12,920 --> 00:04:14,280
只是分析我这个句子

129
00:04:14,280 --> 00:04:15,040
有没有错

130
00:04:15,040 --> 00:04:15,920
这一行代码

131
00:04:15,920 --> 00:04:17,640
有没有写错物理意义

132
00:04:18,160 --> 00:04:19,640
下面以第五行

133
00:04:19,640 --> 00:04:21,480
第六行代码作为例子

134
00:04:21,480 --> 00:04:22,760
一开始定义了一个

135
00:04:22,760 --> 00:04:24,000
int a 四维的数组

136
00:04:24,000 --> 00:04:25,080
接着我在第六行

137
00:04:25,080 --> 00:04:27,560
再定义一个int a 五维的数组

138
00:04:27,560 --> 00:04:29,640
然后去执行clean-c hello

139
00:04:29,640 --> 00:04:30,360
这个时候

140
00:04:30,960 --> 00:04:31,920
结果会看到

141
00:04:31,920 --> 00:04:32,680
编译器

142
00:04:32,680 --> 00:04:33,800
会爆出一个错误

143
00:04:33,800 --> 00:04:35,120
告诉a

144
00:04:35,120 --> 00:04:36,640
其实已经定义好了

145
00:04:36,640 --> 00:04:38,360
你定义的位置是在这里面的

146
00:04:38,360 --> 00:04:40,840
这里面就出现了一个错误

147
00:04:41,280 --> 00:04:43,320
从这个简单的例子可以看到

148
00:04:43,600 --> 00:04:44,160
语义分析

149
00:04:44,400 --> 00:04:46,360
就是借助高级语言的符号表

150
00:04:46,360 --> 00:04:47,600
去检查代码

151
00:04:47,760 --> 00:04:50,240
有没有违背高级语言的类型

152
00:04:50,600 --> 00:04:51,600
有没有语法错误

153
00:04:52,280 --> 00:04:53,760
最后一步就是生成

154
00:04:53,760 --> 00:04:54,720
LLVM IR

155
00:04:54,720 --> 00:04:57,360
然后进入LLVM的优化层

156
00:04:57,920 --> 00:04:59,200
了解LLVM的优化层

157
00:04:59,360 --> 00:05:01,040
其实并不会去展开

158
00:05:01,040 --> 00:05:02,040
讲每一个pass

159
00:05:02,040 --> 00:05:03,320
具体做了哪些工作

160
00:05:03,320 --> 00:05:04,960
针对C语言或者C++语言

161
00:05:04,960 --> 00:05:06,600
对C这些不同的语言

162
00:05:06,600 --> 00:05:09,240
做了哪些不同的优化的方式

163
00:05:09,520 --> 00:05:10,480
或者对IR

164
00:05:10,480 --> 00:05:11,720
做了哪些独特的优化

165
00:05:12,360 --> 00:05:13,720
而是去了解优化层的

166
00:05:13,720 --> 00:05:14,360
这个Pipeline

167
00:05:14,360 --> 00:05:15,800
具体是怎么工作的

168
00:05:16,320 --> 00:05:18,320
LLVM优化层的输是

169
00:05:18,320 --> 00:05:19,200
LLVM IR

170
00:05:19,200 --> 00:05:21,480
输出也是LLVM的IR

171
00:05:21,720 --> 00:05:23,040
这里面只是一个示例

172
00:05:23,040 --> 00:05:24,440
实际上它的输是一个

173
00:05:24,440 --> 00:05:25,440
ASG的语法树

174
00:05:25,440 --> 00:05:26,480
然后变成一个IR

175
00:05:26,760 --> 00:05:28,080
它的输出是一个IR

176
00:05:28,080 --> 00:05:29,680
但是输给指定的时候

177
00:05:30,040 --> 00:05:31,760
已经变成一个DAG的图了

178
00:05:32,000 --> 00:05:33,320
在上一节课里面

179
00:05:33,320 --> 00:05:35,560
其实已经简单的介绍了一下

180
00:05:35,840 --> 00:05:37,960
为什么它的输输出比较特别

181
00:05:38,200 --> 00:05:38,960
现在来看一看

182
00:05:38,960 --> 00:05:40,920
优化层做了哪些工作

183
00:05:41,800 --> 00:05:42,760
优化层里面的

184
00:05:42,760 --> 00:05:45,160
每一种优化的方式叫做Pass

185
00:05:45,600 --> 00:05:46,440
Pass这个概念

186
00:05:46,560 --> 00:05:47,800
其实在第一节

187
00:05:47,800 --> 00:05:48,720
分享的内容里面

188
00:05:48,720 --> 00:05:50,000
给大家汇报过

189
00:05:50,000 --> 00:05:51,960
它就是对LLVM IR

190
00:05:51,960 --> 00:05:53,040
或者对程序

191
00:05:53,040 --> 00:05:54,040
做一次变逆

192
00:05:54,240 --> 00:05:55,800
这一次变逆的叫做Pass

193
00:05:56,640 --> 00:05:57,520
而优化层里面

194
00:05:57,680 --> 00:05:59,000
又分为分析的Pass

195
00:05:59,000 --> 00:06:00,320
和转换的Pass

196
00:06:00,320 --> 00:06:01,200
有两种Pass

197
00:06:01,800 --> 00:06:02,720
有两种的Pass

198
00:06:02,720 --> 00:06:04,040
而这两种不同的Pass

199
00:06:04,240 --> 00:06:05,440
负责不同的工作

200
00:06:05,440 --> 00:06:06,320
现在来看

201
00:06:06,320 --> 00:06:07,880
分析的Pass做什么

202
00:06:07,880 --> 00:06:08,640
分析的Pass

203
00:06:08,800 --> 00:06:09,760
主要是发掘一些

204
00:06:09,760 --> 00:06:11,760
性能和优化的机会点

205
00:06:11,760 --> 00:06:13,560
就是它只做分析

206
00:06:13,600 --> 00:06:16,040
它不做具体的转换和生成

207
00:06:16,040 --> 00:06:17,600
它也不做具体的工作

208
00:06:17,600 --> 00:06:18,600
而具体的工作

209
00:06:18,720 --> 00:06:21,120
留给转换的Pass来做

210
00:06:21,320 --> 00:06:22,080
转换的Pass

211
00:06:22,200 --> 00:06:24,520
就会生成所必要的数据结构

212
00:06:24,720 --> 00:06:25,680
这个数据结构

213
00:06:25,840 --> 00:06:27,360
也叫做IR

214
00:06:27,600 --> 00:06:29,440
它是基于LLVM IR之上

215
00:06:29,440 --> 00:06:31,400
定制的一个具体的数据结构

216
00:06:31,400 --> 00:06:33,480
或者它特有的一个IR形式

217
00:06:33,840 --> 00:06:35,000
为后续的转换Pass

218
00:06:35,000 --> 00:06:36,760
或分析Pass所使用到的

219
00:06:37,360 --> 00:06:39,480
现在执行下面的这条命令

220
00:06:39,480 --> 00:06:40,000
OPT

221
00:06:40,200 --> 00:06:41,680
OPT就是Optimization

222
00:06:41,880 --> 00:06:43,680
是LLVM里面的一个工具

223
00:06:43,680 --> 00:06:44,880
然后hello.bc

224
00:06:44,880 --> 00:06:48,040
bc就是LLVM的IR的一种呈现方式

225
00:06:48,040 --> 00:06:48,960
然后instruction

226
00:06:48,960 --> 00:06:50,040
hello.bc

227
00:06:50,040 --> 00:06:51,960
然后把Stata打出来

228
00:06:51,960 --> 00:06:54,760
然后就打印出图了

229
00:06:54,960 --> 00:06:56,360
可以看到图里面

230
00:06:56,480 --> 00:06:57,920
有非常多的Pass

231
00:06:58,200 --> 00:06:59,320
实际上这个图

232
00:06:59,320 --> 00:07:00,240
还是执行了

233
00:07:00,240 --> 00:07:02,280
刚才很简单的代码

234
00:07:02,480 --> 00:07:04,080
代码呈现出来的结果

235
00:07:04,600 --> 00:07:05,880
运行了不同的Pass

236
00:07:05,880 --> 00:07:07,600
具体其实我也不知道

237
00:07:07,600 --> 00:07:09,400
这些Pass做了哪些工作

238
00:07:09,560 --> 00:07:10,680
来看看这些Pass

239
00:07:10,880 --> 00:07:11,880
做了哪些工作

240
00:07:12,840 --> 00:07:14,760
下面打开这条链接

241
00:07:16,040 --> 00:07:17,320
这条链接里面打开了

242
00:07:17,320 --> 00:07:20,120
就是LLVM Pass里面的一个介绍

243
00:07:20,120 --> 00:07:21,760
里面就分为Analyze Pass

244
00:07:21,760 --> 00:07:23,160
还有Transform Pass

245
00:07:23,520 --> 00:07:25,360
Analyze Pass有非常多

246
00:07:25,360 --> 00:07:27,680
主要是做一些分析性的工作

247
00:07:27,680 --> 00:07:28,760
而Transform Pass

248
00:07:28,960 --> 00:07:30,800
就是做一些实际的转换

249
00:07:31,160 --> 00:07:33,920
以下面ADCE作为例子

250
00:07:33,920 --> 00:07:35,720
积极的死代码消除

251
00:07:36,000 --> 00:07:38,040
虽然我不知道积极的死代码消除

252
00:07:38,040 --> 00:07:38,760
代表是什么

253
00:07:38,760 --> 00:07:40,200
但是这里面就描述了

254
00:07:40,200 --> 00:07:42,920
这个Pass跟DEC非常类似

255
00:07:42,920 --> 00:07:44,880
DEC就是死代码消除

256
00:07:44,880 --> 00:07:46,840
就是把一些没有用的代码

257
00:07:46,840 --> 00:07:47,680
把它删掉

258
00:07:47,960 --> 00:07:49,360
什么为之没有用的代码

259
00:07:49,560 --> 00:07:51,400
举一个具体的例子

260
00:07:52,400 --> 00:07:53,720
在Mate函数里面

261
00:07:53,920 --> 00:07:56,800
我声明一个int b等于1

262
00:07:57,080 --> 00:07:58,800
然后int c等于0

263
00:07:59,240 --> 00:08:01,000
最后我返回的是一个0

264
00:08:01,280 --> 00:08:03,240
在程序去执行这段代码的时候

265
00:08:03,360 --> 00:08:04,840
其实有用的信息就是

266
00:08:04,840 --> 00:08:05,960
print hello world

267
00:08:06,200 --> 00:08:07,520
然后返回一个0

268
00:08:07,760 --> 00:08:09,800
中间的两个定义int b

269
00:08:09,800 --> 00:08:10,440
int c

270
00:08:10,440 --> 00:08:12,760
它只是开辟了一个内存的空间

271
00:08:12,760 --> 00:08:14,320
然后声明了一个变量

272
00:08:14,320 --> 00:08:15,320
做了一个复制

273
00:08:15,320 --> 00:08:16,840
实际上它对于这个程序

274
00:08:17,120 --> 00:08:18,360
是没有任何作用的

275
00:08:18,360 --> 00:08:20,120
这种在变异的过程当中

276
00:08:20,120 --> 00:08:21,560
就会把这段删掉

277
00:08:21,560 --> 00:08:23,920
这种工作叫做死代码消除

278
00:08:24,720 --> 00:08:27,400
也就是转换Pass DEC所做的工作

279
00:08:27,400 --> 00:08:28,440
而做这个工作

280
00:08:28,560 --> 00:08:30,320
不是基于刚才所演示的

281
00:08:30,320 --> 00:08:32,120
实际的高级语言的代码去做的

282
00:08:32,120 --> 00:08:34,480
而是通过LLVM IR去做的

283
00:08:34,840 --> 00:08:36,280
因为死代码消除

284
00:08:36,280 --> 00:08:38,200
它是一个非常通用的需求

285
00:08:38,200 --> 00:08:40,000
包括Java Python C C++

286
00:08:40,000 --> 00:08:42,720
Object C都有同样类型的需求

287
00:08:43,040 --> 00:08:44,320
再举一个例子

288
00:08:44,320 --> 00:08:47,160
叫做merge duplicate global constants

289
00:08:47,440 --> 00:08:50,080
它的意思是将重复的全局常量

290
00:08:50,080 --> 00:08:51,960
合并到一个共享的常量里面

291
00:08:52,320 --> 00:08:53,120
点开看一看

292
00:08:53,440 --> 00:08:54,440
这里面就说了

293
00:08:54,440 --> 00:08:56,960
这一个Pass是非常有用的

294
00:08:56,960 --> 00:08:58,440
因为在有一些Pass里面

295
00:08:58,560 --> 00:09:00,680
插了非常多的变量

296
00:09:00,680 --> 00:09:02,200
然后到程序里面

297
00:09:02,520 --> 00:09:04,800
所以编辑会对这些常量进行优化

298
00:09:05,480 --> 00:09:05,920
在这里面

299
00:09:06,080 --> 00:09:07,680
其实我之前曾经写过

300
00:09:07,680 --> 00:09:08,600
很多不同的Pass

301
00:09:08,600 --> 00:09:10,040
在AI编译器里面

302
00:09:10,320 --> 00:09:11,160
大家不要觉得

303
00:09:11,160 --> 00:09:12,840
这是一个很高大上的动作

304
00:09:12,840 --> 00:09:15,760
其实这个是基于规则去写的代码

305
00:09:16,360 --> 00:09:17,520
在写Pass的时候

306
00:09:17,640 --> 00:09:18,480
其实很简单

307
00:09:18,720 --> 00:09:21,160
我已经知道Pass具体做什么工作了

308
00:09:21,160 --> 00:09:23,280
我知道它要把所有的全局变量

309
00:09:23,280 --> 00:09:25,600
都合并到一个共享的常量里面

310
00:09:25,600 --> 00:09:27,720
这个时候根据LLVM的IR

311
00:09:27,720 --> 00:09:30,960
去编译或者forLLVM IR

312
00:09:30,960 --> 00:09:33,320
然后找到一些全局的变量

313
00:09:33,360 --> 00:09:35,440
把这些全局变量都记录下来

314
00:09:35,440 --> 00:09:37,280
然后通过上一节介绍的

315
00:09:37,280 --> 00:09:38,880
LLVM的内存的模式

316
00:09:38,880 --> 00:09:40,320
去控制LLVM

317
00:09:40,320 --> 00:09:42,600
去把重复的全局常量去删掉

318
00:09:42,600 --> 00:09:44,400
只留下一个共享的常量

319
00:09:44,400 --> 00:09:45,840
所以这里面是很表达的

320
00:09:45,840 --> 00:09:48,000
就是写一个Pass没有这么难

321
00:09:48,000 --> 00:09:49,000
只是需要知道

322
00:09:49,000 --> 00:09:50,560
这个Pass具体做哪些

323
00:09:50,560 --> 00:09:52,680
知道优化器有多少个Pass

324
00:09:52,960 --> 00:09:54,280
想进一步去了解的同学

325
00:09:54,400 --> 00:09:55,920
就可以打开这条链接

326
00:09:55,920 --> 00:09:57,760
去看看LLVM里面的Pass

327
00:09:57,760 --> 00:09:59,080
具体有哪些工作

328
00:09:59,440 --> 00:10:01,680
另外想深入到Pass具体是怎么写的

329
00:10:01,680 --> 00:10:02,960
可以深入到代码

330
00:10:02,960 --> 00:10:04,400
因为LLVM是开源的

331
00:10:04,400 --> 00:10:05,760
去看看每一个Pass

332
00:10:05,760 --> 00:10:07,280
具体是怎么实现的

333
00:10:08,160 --> 00:10:09,520
下面来理一理

334
00:10:09,520 --> 00:10:11,360
Pass之间的一个关系

335
00:10:11,360 --> 00:10:13,160
在转换的Pass和分析的Pass

336
00:10:13,320 --> 00:10:14,520
有两种依赖关系

337
00:10:14,520 --> 00:10:15,960
一种是显性的依赖

338
00:10:15,960 --> 00:10:17,400
一种是隐性的依赖

339
00:10:17,400 --> 00:10:19,560
那什么为之显性的依赖呢

340
00:10:19,840 --> 00:10:21,960
刚才讲过转换的Pass

341
00:10:22,120 --> 00:10:23,480
是实际工作的

342
00:10:23,480 --> 00:10:24,560
但是它工作之前

343
00:10:24,720 --> 00:10:26,080
它依赖于一种分析

344
00:10:26,080 --> 00:10:28,320
就是你要把分析的结果告诉我

345
00:10:28,320 --> 00:10:29,960
然后我再做转换

346
00:10:30,200 --> 00:10:32,320
以合并全局常量为例子

347
00:10:32,880 --> 00:10:33,680
分析的Pass

348
00:10:33,880 --> 00:10:36,720
去分析有多少重复的全局常量

349
00:10:36,920 --> 00:10:37,760
转换的Pass

350
00:10:37,920 --> 00:10:39,600
就是做合并的工作

351
00:10:39,800 --> 00:10:41,320
所以说转换的Pass之前

352
00:10:41,440 --> 00:10:42,920
它需要一个分析的Pass

353
00:10:42,920 --> 00:10:44,160
而Pass的管理器

354
00:10:44,160 --> 00:10:45,080
就是Pass Manager

355
00:10:45,360 --> 00:10:47,680
就会自动的去安排所依赖的Pass

356
00:10:47,920 --> 00:10:48,840
它怎么自动安排

357
00:10:48,960 --> 00:10:51,040
还是根据代码去实现的

358
00:10:51,040 --> 00:10:52,880
这里面有个Domain Tree

359
00:10:52,880 --> 00:10:54,880
然后getAnalyzeDomainTree

360
00:10:54,880 --> 00:10:56,280
前面就声明了

361
00:10:56,280 --> 00:10:58,000
我需要使用哪一种函数

362
00:10:58,000 --> 00:10:59,280
使用哪一种分析

363
00:10:59,480 --> 00:11:01,640
第二种就是隐性的依赖

364
00:11:01,880 --> 00:11:03,960
在转换或者分析的Pass之前

365
00:11:04,120 --> 00:11:06,200
它对上下文是有依赖关系的

366
00:11:06,400 --> 00:11:07,400
我做转换之前

367
00:11:07,520 --> 00:11:08,960
我没有显现的高速程序

368
00:11:08,960 --> 00:11:10,320
我现在需要哪些

369
00:11:10,360 --> 00:11:12,120
这个时候就需要手动的

370
00:11:12,120 --> 00:11:13,600
去正确的把这些Pass

371
00:11:13,640 --> 00:11:15,440
插到正确的位置里面

372
00:11:15,760 --> 00:11:17,640
最后就是Pass的API

373
00:11:17,640 --> 00:11:18,840
在Pass实现的时候

374
00:11:18,960 --> 00:11:21,120
它其实是分层级分力度的

375
00:11:21,320 --> 00:11:23,640
如果对整个模块进行处理

376
00:11:23,760 --> 00:11:24,960
有Model的Pass

377
00:11:25,000 --> 00:11:26,720
对一个函数进行处理

378
00:11:26,720 --> 00:11:28,040
有Function的Pass

379
00:11:28,080 --> 00:11:29,760
如果只对某几条指令

380
00:11:29,760 --> 00:11:31,120
某几个语句进行处理

381
00:11:31,320 --> 00:11:32,840
这里面有Basic Boxed Pass

382
00:11:33,040 --> 00:11:34,320
分开不同力度的Pass

383
00:11:34,480 --> 00:11:36,880
就是为了让更好地去选择

384
00:11:36,880 --> 00:11:38,720
所处理的对象处理的欲


