1
00:00:00,000 --> 00:00:04,000
[字幕生成：BLACK 字幕校对：志宇]

2
00:00:07,000 --> 00:00:07,000
哈喽大家好,我是ZOMI


3
00:00:07,000 --> 00:00:09,000
刚才刷完抖音刷到深夜

4
00:00:09,000 --> 00:00:11,000
然后现在睡不着了,起来录个课

5
00:00:17,000 --> 00:00:21,000
今天我们已经来到LLVM的第三节

6
00:00:21,000 --> 00:00:23,000
深度ProceedLLVM

7
00:00:23,000 --> 00:00:27,000
今天我们要讲的内容主要是围绕LLVM的后端

8
00:00:27,000 --> 00:00:32,000
就是后端CodeGen生成会员代码或者生成一些代码的指令

9
00:00:32,000 --> 00:00:36,000
接着我们会聊一聊基于LLVM的一些AI项目

10
00:00:38,000 --> 00:00:39,000
在进入正式的内容之前

11
00:00:39,000 --> 00:00:41,000
其实我有一个非常大的疑问

12
00:00:41,000 --> 00:00:44,000
就是一开始我做一些MySQL的进阶视频的时候

13
00:00:44,000 --> 00:00:47,000
我的粉丝量永远不超过100个

14
00:00:47,000 --> 00:00:51,000
也就是说我没有一个视频是超过100的浏览量

15
00:00:51,000 --> 00:00:53,000
几乎没有人看

16
00:00:58,000 --> 00:01:02,000
但是当我就发现我要不要做一些AI系统

17
00:01:02,000 --> 00:01:05,000
AI框架计算图比较通用性的东西

18
00:01:05,000 --> 00:01:07,000
于是我就做了一些视频

19
00:01:07,000 --> 00:01:11,000
然后这些视频的浏览量都不超过200到300

20
00:01:11,000 --> 00:01:14,000
那时候我的粉丝量的增加非常可怜

21
00:01:14,000 --> 00:01:18,000
基本上运作了两三个月也就300多个粉丝

22
00:01:18,000 --> 00:01:21,000
然后我想着最近大模型非常火

23
00:01:21,000 --> 00:01:25,000
我们要不要来搞些大模型的教程呢

24
00:01:26,000 --> 00:01:28,000
于是我又去系列的去梳理了大模型

25
00:01:28,000 --> 00:01:31,000
从张量并行,流水型并行,通讯原语

26
00:01:31,000 --> 00:01:34,000
各种大模型相关的技术全部都梳理了一遍之后

27
00:01:34,000 --> 00:01:36,000
然后我就发现

28
00:01:36,000 --> 00:01:39,000
似乎都好像也不爱看这玩意

29
00:01:39,000 --> 00:01:42,000
我的粉丝量永远上不去600

30
00:01:42,000 --> 00:01:44,000
也就是我耕耘了两个月之后

31
00:01:44,000 --> 00:01:46,000
我发现还是没有什么观看

32
00:01:46,000 --> 00:01:56,000
结果什么鬼

33
00:01:56,000 --> 00:02:01,000
我一开始以为LLVM这种老到掉渣

34
00:02:01,000 --> 00:02:03,000
而且还很硬很难啃的技术

35
00:02:03,000 --> 00:02:06,000
 居然浏览量

36
00:02:06,000 --> 00:02:10,000
居然浏览量是我发过所有视频里面最高的

37
00:02:10,000 --> 00:02:11,000
我就想问问

38
00:02:11,000 --> 00:02:13,000
就是给我涨粉的这些粉丝

39
00:02:13,000 --> 00:02:14,000
你们给我弹幕

40
00:02:14,000 --> 00:02:16,000
或者你看到这条视频的人

41
00:02:16,000 --> 00:02:20,000
你告诉我为什么你会去看LLVM

42
00:02:20,000 --> 00:02:22,000
那要是后面我讲完LLVM之后呢

43
00:02:22,000 --> 00:02:24,000
我讲完传统编译器

44
00:02:24,000 --> 00:02:25,000
又去讲AI编译器

45
00:02:25,000 --> 00:02:28,000
我估计又没什么人来观看了

46
00:02:28,000 --> 00:02:29,000
好了

47
00:02:29,000 --> 00:02:31,000
吐槽的东西或者我的疑问呢

48
00:02:31,000 --> 00:02:36,000
我现在真的是满头包

49
00:02:36,000 --> 00:02:37,000
回到我们正式的内容

50
00:02:37,000 --> 00:02:40,000
这一节还是介绍LLVM的一个架构

51
00:02:40,000 --> 00:02:41,000
那主要是集中在后端

52
00:02:41,000 --> 00:02:43,000
可以看到我们回顾一下上两节的内容

53
00:02:43,000 --> 00:02:46,000
上一节我们讲了LLVM的前端

54
00:02:46,000 --> 00:02:48,000
前端主要是对我们的高级语言

55
00:02:48,000 --> 00:02:50,000
做一些词法的分析

56
00:02:50,000 --> 00:02:51,000
把那些词呢

57
00:02:51,000 --> 00:02:53,000
把我们的高级语言的特性的编上token

58
00:02:53,000 --> 00:02:55,000
然后给我们的语法分析

59
00:02:55,000 --> 00:02:56,000
语法分析主要是分析

60
00:02:56,000 --> 00:02:58,000
我这句话有没有写错

61
00:02:58,000 --> 00:03:00,000
而语意分析才是真正的去分析

62
00:03:00,000 --> 00:03:03,000
我们写的代码的逻辑有没有问题

63
00:03:03,000 --> 00:03:05,000
在这一步语法到语意分析

64
00:03:05,000 --> 00:03:07,000
它传输的是一个AST

65
00:03:07,000 --> 00:03:09,000
语法数这么一个概念

66
00:03:09,000 --> 00:03:12,000
那像这种就是我们所谓的语法数

67
00:03:12,000 --> 00:03:14,000
语法分析这个环节呢

68
00:03:14,000 --> 00:03:15,000
输出一个语法数

69
00:03:15,000 --> 00:03:16,000
给我们的语意分析

70
00:03:16,000 --> 00:03:17,000
然后去分析我们每一句话

71
00:03:17,000 --> 00:03:18,000
我们的逻辑

72
00:03:18,000 --> 00:03:20,000
我们的代码到底错在哪里

73
00:03:20,000 --> 00:03:21,000
到底有没有错

74
00:03:21,000 --> 00:03:24,000
接着呢就走到了LLVM的优化层了

75
00:03:24,000 --> 00:03:26,000
优化层有非常多的Path

76
00:03:26,000 --> 00:03:28,000
不同的Path处理不同的任务

77
00:03:28,000 --> 00:03:30,000
那中间的所有的箭头都是处理

78
00:03:30,000 --> 00:03:33,000
我们的LLVM这个数据结构的

79
00:03:33,000 --> 00:03:35,000
Path里面呢主要有两个概念

80
00:03:35,000 --> 00:03:37,000
第一个是分析的Path

81
00:03:37,000 --> 00:03:38,000
第二个是转换的Path

82
00:03:38,000 --> 00:03:41,000
而转换的Path才是真正处理的Path

83
00:03:41,000 --> 00:03:43,000
那接着呢我们今天要讲讲

84
00:03:43,000 --> 00:03:45,000
LLVM的后端CodeGene

85
00:03:45,000 --> 00:03:47,000
如何生成我们的代码

86
00:03:50,000 --> 00:03:51,000
在这一节里面呢

87
00:03:51,000 --> 00:03:52,000
我们就会把编译器的前端

88
00:03:52,000 --> 00:03:55,000
优化层还有后端都讲了

89
00:03:55,000 --> 00:03:56,000
那在后端里面呢

90
00:03:56,000 --> 00:03:57,000
其实是最复杂的

91
00:03:57,000 --> 00:03:59,000
也是跟硬件强相关的

92
00:03:59,000 --> 00:04:01,000
所以我们看到每一个后端呢

93
00:04:01,000 --> 00:04:03,000
它都跟我们实际的硬件是相关的

94
00:04:03,000 --> 00:04:05,000
但是即使是硬件相关呢

95
00:04:05,000 --> 00:04:06,000
LLVM的后端呢

96
00:04:06,000 --> 00:04:08,000
也对它们做了一个约束

97
00:04:08,000 --> 00:04:09,000
做了一些指定的选择

98
00:04:09,000 --> 00:04:10,000
计算机的分配在做调度

99
00:04:10,000 --> 00:04:11,000
代码布局

100
00:04:11,000 --> 00:04:13,000
最后做到代码的组装

101
00:04:13,000 --> 00:04:14,000
那在这一步工作呢

102
00:04:14,000 --> 00:04:15,000
我们大部分都叫它

103
00:04:15,000 --> 00:04:18,000
CodeGene代码生成

104
00:04:18,000 --> 00:04:19,000
总的来说呢

105
00:04:19,000 --> 00:04:20,000
就是把我们的LLVM的IR呢

106
00:04:20,000 --> 00:04:22,000
变成我们的目标代码

107
00:04:22,000 --> 00:04:24,000
或者我们的汇编代码

108
00:04:24,000 --> 00:04:25,000
在后端的处理呢

109
00:04:25,000 --> 00:04:27,000
实际上呢是非常复杂的

110
00:04:27,000 --> 00:04:29,000
整个后端的Pipeline流水线呢

111
00:04:29,000 --> 00:04:30,000
用到了不同的IR

112
00:04:30,000 --> 00:04:31,000
不同的指令

113
00:04:31,000 --> 00:04:32,000
那第一个呢

114
00:04:32,000 --> 00:04:33,000
就是我们的LLVM的IR

115
00:04:33,000 --> 00:04:35,000
还有Selection DAG图

116
00:04:35,000 --> 00:04:36,000
还有Machine Instruction

117
00:04:36,000 --> 00:04:38,000
还有MC Instruction

118
00:04:38,000 --> 00:04:39,000
在最后一个阶段呢

119
00:04:39,000 --> 00:04:40,000
我们把LLVM的IR呢

120
00:04:40,000 --> 00:04:42,000
转换成为目标的汇编代码了

121
00:04:42,000 --> 00:04:44,000
需要经过非常多的

122
00:04:44,000 --> 00:04:45,000
若干的步骤

123
00:04:45,000 --> 00:04:46,000
就是我们下面看到的

124
00:04:46,000 --> 00:04:48,000
这个Pipeline

125
00:04:48,000 --> 00:04:49,000
LLVM IR最后呢

126
00:04:49,000 --> 00:04:51,000
就会变成跟后端

127
00:04:51,000 --> 00:04:52,000
非常之亲密友好的

128
00:04:52,000 --> 00:04:54,000
一些具体的指令

129
00:04:54,000 --> 00:04:55,000
函数或者全局变量的

130
00:04:55,000 --> 00:04:56,000
具体的表示

131
00:04:56,000 --> 00:04:58,000
还有寄存器的表示

132
00:04:58,000 --> 00:05:00,000
流水线越往下走呢

133
00:05:00,000 --> 00:05:01,000
就越贴近我们

134
00:05:01,000 --> 00:05:03,000
实际硬件的目标指令

135
00:05:03,000 --> 00:05:05,000
图中白色的这些Path呢

136
00:05:05,000 --> 00:05:07,000
就是一些非必要的Path

137
00:05:07,000 --> 00:05:08,000
而这些灰色的Path呢

138
00:05:08,000 --> 00:05:10,000
就叫做必须的Path

139
00:05:10,000 --> 00:05:12,000
我们也叫做Super Path

140
00:05:12,000 --> 00:05:13,000
下面可以看到

141
00:05:13,000 --> 00:05:15,000
这里面有五个Super Path

142
00:05:15,000 --> 00:05:16,000
我们也会逐个的Super Path

143
00:05:16,000 --> 00:05:18,000
去展开

144
00:05:18,000 --> 00:05:19,000
第一个Super Path呢

145
00:05:19,000 --> 00:05:21,000
我们叫做指令选择

146
00:05:21,000 --> 00:05:23,000
Instruction Selection

147
00:05:23,000 --> 00:05:25,000
LLVM IR呢

148
00:05:25,000 --> 00:05:26,000
作为指令选择的

149
00:05:26,000 --> 00:05:27,000
一个输入

150
00:05:27,000 --> 00:05:28,000
然后在输入的时候呢

151
00:05:28,000 --> 00:05:29,000
就会把它变成一个

152
00:05:29,000 --> 00:05:30,000
Selection DAG

153
00:05:30,000 --> 00:05:31,000
那DAG呢

154
00:05:31,000 --> 00:05:32,000
就是有相无款图

155
00:05:32,000 --> 00:05:33,000
把我们的IR

156
00:05:33,000 --> 00:05:35,000
变成正正的一个图

157
00:05:35,000 --> 00:05:36,000
每一个DAG图呢

158
00:05:36,000 --> 00:05:37,000
就表示

159
00:05:37,000 --> 00:05:39,000
单一的一个基本块的计算

160
00:05:39,000 --> 00:05:40,000
那既然是图

161
00:05:40,000 --> 00:05:41,000
那就有节点和编

162
00:05:41,000 --> 00:05:43,000
节点就表示

163
00:05:43,000 --> 00:05:44,000
具体执行的指令

164
00:05:44,000 --> 00:05:45,000
而边呢

165
00:05:45,000 --> 00:05:46,000
就代表编码之间的

166
00:05:46,000 --> 00:05:48,000
一个数据流的依赖关系

167
00:05:48,000 --> 00:05:49,000
目标呢

168
00:05:49,000 --> 00:05:50,000
就是我们家出的这一行

169
00:05:50,000 --> 00:05:52,000
希望把我们LLVM的代码

170
00:05:52,000 --> 00:05:53,000
或者LLVM的IR呢

171
00:05:53,000 --> 00:05:55,000
生成我们程序库

172
00:05:55,000 --> 00:05:56,000
能够运行呢

173
00:05:56,000 --> 00:05:57,000
基于数的模式匹配的

174
00:05:57,000 --> 00:05:59,000
指令选择的算法

175
00:05:59,000 --> 00:06:00,000
这句话呢

176
00:06:00,000 --> 00:06:01,000
有点拗口

177
00:06:01,000 --> 00:06:02,000
其实到这个步骤为止呢

178
00:06:02,000 --> 00:06:03,000
指令选择

179
00:06:03,000 --> 00:06:05,000
把LLVM IR变成

180
00:06:05,000 --> 00:06:07,000
一个DAG图

181
00:06:07,000 --> 00:06:08,000
这个DAG图呢

182
00:06:08,000 --> 00:06:09,000
其实就是我们的目标的

183
00:06:09,000 --> 00:06:11,000
机器代码的一个节点

184
00:06:11,000 --> 00:06:12,000
这些节点呢

185
00:06:12,000 --> 00:06:13,000
就代表我们目标的

186
00:06:13,000 --> 00:06:14,000
机器的指令了

187
00:06:14,000 --> 00:06:16,000
而不是LLVM的指令了

188
00:06:16,000 --> 00:06:17,000
LLVM的指令

189
00:06:17,000 --> 00:06:18,000
就是我们的3D子结构嘛

190
00:06:18,000 --> 00:06:19,000
我们在上一节里面

191
00:06:19,000 --> 00:06:20,000
讲到了

192
00:06:20,000 --> 00:06:21,000
而现在呢

193
00:06:21,000 --> 00:06:23,000
就是真正的机器的指令

194
00:06:23,000 --> 00:06:24,000
变成DAG

195
00:06:24,000 --> 00:06:25,000
那DAG是一个图

196
00:06:25,000 --> 00:06:27,000
图非常方便用于建树

197
00:06:27,000 --> 00:06:29,000
通过指令选择算法呢

198
00:06:29,000 --> 00:06:31,000
去执行我们的DAG的指令

199
00:06:31,000 --> 00:06:33,000
那第二个步骤呢

200
00:06:33,000 --> 00:06:34,000
就是指令调度

201
00:06:34,000 --> 00:06:36,000
Instruction Scheduling

202
00:06:36,000 --> 00:06:37,000
第二个步骤

203
00:06:37,000 --> 00:06:38,000
我们可以看到

204
00:06:38,000 --> 00:06:39,000
实际上我们有两个

205
00:06:39,000 --> 00:06:41,000
Instruction Scheduling

206
00:06:41,000 --> 00:06:42,000
从Pipeline里面呢

207
00:06:42,000 --> 00:06:43,000
我们可以看到

208
00:06:43,000 --> 00:06:45,000
它有两个Instruction Scheduling

209
00:06:45,000 --> 00:06:47,000
就是两个指令调度

210
00:06:47,000 --> 00:06:48,000
我们现在讲讲

211
00:06:48,000 --> 00:06:50,000
第一次指令调度的工作

212
00:06:50,000 --> 00:06:51,000
也就是我做一个

213
00:06:51,000 --> 00:06:53,000
寄存器的预分配

214
00:06:53,000 --> 00:06:54,000
我们刚才的第一步工作呢

215
00:06:54,000 --> 00:06:55,000
已经把它变成一个

216
00:06:55,000 --> 00:06:56,000
DAG的图了

217
00:06:56,000 --> 00:06:58,000
我对这些DAG的图的指令呢

218
00:06:58,000 --> 00:06:59,000
做一个排序

219
00:06:59,000 --> 00:07:01,000
就是对节点进行排序

220
00:07:01,000 --> 00:07:02,000
尽可能多的

221
00:07:02,000 --> 00:07:03,000
去发现这些

222
00:07:03,000 --> 00:07:04,000
可以并行的一些指令

223
00:07:04,000 --> 00:07:06,000
同时把我们的指令呢

224
00:07:06,000 --> 00:07:08,000
变成另外一种表示形式

225
00:07:08,000 --> 00:07:09,000
那这种表示形式

226
00:07:09,000 --> 00:07:10,000
其实也叫做IR

227
00:07:10,000 --> 00:07:11,000
但是这个IR呢

228
00:07:11,000 --> 00:07:13,000
叫做Machine Instruction

229
00:07:13,000 --> 00:07:15,000
三地址的表示方式

230
00:07:15,000 --> 00:07:16,000
在第三个步骤呢

231
00:07:16,000 --> 00:07:19,000
就是我们的寄存器的分配

232
00:07:19,000 --> 00:07:21,000
Register Allocation

233
00:07:21,000 --> 00:07:23,000
我们在前面的章节里面

234
00:07:23,000 --> 00:07:24,000
其实已经谈到了

235
00:07:24,000 --> 00:07:26,000
寄存器是非常昂贵的

236
00:07:26,000 --> 00:07:28,000
而每一个硬件的寄存器

237
00:07:28,000 --> 00:07:29,000
都是有限的

238
00:07:29,000 --> 00:07:30,000
但是LVM IR里面呢

239
00:07:30,000 --> 00:07:32,000
就有两个比较重要的特性

240
00:07:32,000 --> 00:07:34,000
一个是SSA

241
00:07:34,000 --> 00:07:35,000
那第二个特性呢

242
00:07:35,000 --> 00:07:37,000
就是寄存器假设是无限的

243
00:07:37,000 --> 00:07:39,000
所以LVM IR里面用百分

244
00:07:39,000 --> 00:07:41,000
还代表无限的寄存器

245
00:07:41,000 --> 00:07:42,000
这个特性呢

246
00:07:42,000 --> 00:07:43,000
保持到这一步为止呢

247
00:07:43,000 --> 00:07:44,000
就终止了

248
00:07:44,000 --> 00:07:46,000
把LVM IR里面

249
00:07:46,000 --> 00:07:47,000
无限虚拟的寄存器呢

250
00:07:47,000 --> 00:07:49,000
转换成为实际上有目标

251
00:07:49,000 --> 00:07:50,000
有地址

252
00:07:50,000 --> 00:07:52,000
有定位的寄存器集合

253
00:07:52,000 --> 00:07:53,000
诶 ZOMI老师

254
00:07:53,000 --> 00:07:54,000
我想问一下

255
00:07:54,000 --> 00:07:55,000
你刚才说到了

256
00:07:55,000 --> 00:07:57,000
LVM IR里面的寄存器

257
00:07:57,000 --> 00:07:58,000
是无限的

258
00:07:58,000 --> 00:08:00,000
但实际上硬件的寄存器

259
00:08:00,000 --> 00:08:01,000
是非常昂贵

260
00:08:01,000 --> 00:08:02,000
非常少量的

261
00:08:02,000 --> 00:08:04,000
如果实际物理意义上的寄存器不够

262
00:08:04,000 --> 00:08:05,000
那怎么办呢

263
00:08:06,000 --> 00:08:07,000
很简单啊

264
00:08:07,000 --> 00:08:09,000
直接把它speed到内存里面嘛

265
00:08:09,000 --> 00:08:10,000
你不够塞

266
00:08:10,000 --> 00:08:12,000
那你就先缓存起来嘛

267
00:08:12,000 --> 00:08:14,000
所以寄存器不够的时候呢

268
00:08:14,000 --> 00:08:15,000
就会把它speed到内存

269
00:08:15,000 --> 00:08:17,000
就把它挤到内存里面

270
00:08:17,000 --> 00:08:19,000
等下一次能够用的时候再用

271
00:08:20,000 --> 00:08:21,000
第四步呢

272
00:08:21,000 --> 00:08:22,000
就是我们刚才的

273
00:08:22,000 --> 00:08:23,000
instruction scheduling

274
00:08:23,000 --> 00:08:25,000
就是我们第二次指令的调度

275
00:08:26,000 --> 00:08:27,000
在第一次指令调度的时候呢

276
00:08:27,000 --> 00:08:28,000
其实我们做了一个

277
00:08:28,000 --> 00:08:30,000
寄存器的预分配

278
00:08:31,000 --> 00:08:33,000
在第二次的指令调度呢

279
00:08:33,000 --> 00:08:34,000
我们要叫做

280
00:08:34,000 --> 00:08:35,000
后寄存器分配啊

281
00:08:35,000 --> 00:08:37,000
多了个后字

282
00:08:37,000 --> 00:08:38,000
这个时候呢

283
00:08:38,000 --> 00:08:39,000
我们就可以获得

284
00:08:39,000 --> 00:08:41,000
寄存器的实际的一些信息

285
00:08:42,000 --> 00:08:43,000
如果我们程序呢

286
00:08:43,000 --> 00:08:44,000
分析到我们刚才

287
00:08:44,000 --> 00:08:45,000
有些寄存器呢

288
00:08:45,000 --> 00:08:47,000
是存不下数据的

289
00:08:47,000 --> 00:08:49,000
或者存在计算延迟的风险呢

290
00:08:49,000 --> 00:08:50,000
这个时候呢

291
00:08:50,000 --> 00:08:52,000
就可以再次通过指令的调度

292
00:08:52,000 --> 00:08:54,000
改变指令的执行顺序

293
00:08:55,000 --> 00:08:56,000
那最后一步呢

294
00:08:56,000 --> 00:08:58,000
叫做code admission

295
00:08:58,000 --> 00:09:00,000
也就是代码的输出

296
00:09:00,000 --> 00:09:01,000
刚才我们在第一次

297
00:09:01,000 --> 00:09:02,000
指令调度的时候呢

298
00:09:02,000 --> 00:09:03,000
就把DAG变成

299
00:09:03,000 --> 00:09:05,000
我们的machine instruction

300
00:09:05,000 --> 00:09:06,000
那我们在代码输出阶段呢

301
00:09:06,000 --> 00:09:08,000
就会把machine instruction

302
00:09:08,000 --> 00:09:09,000
转换成为

303
00:09:09,000 --> 00:09:11,000
MC instruction的一个

304
00:09:11,000 --> 00:09:12,000
对象或者实例

305
00:09:13,000 --> 00:09:14,000
MC instruction这个结构呢

306
00:09:14,000 --> 00:09:16,000
就更贴近我们实际输出的

307
00:09:16,000 --> 00:09:18,000
一个硬件的物理的定义

308
00:09:18,000 --> 00:09:19,000
为的就是方便

309
00:09:19,000 --> 00:09:21,000
我们的汇编器和链接器

310
00:09:21,000 --> 00:09:23,000
用于输出真正的汇编的代码

311
00:09:23,000 --> 00:09:25,000
或者输出二进制的

312
00:09:25,000 --> 00:09:26,000
目标代码格式

313
00:09:26,000 --> 00:09:27,000
那我们从整个pipeline

314
00:09:27,000 --> 00:09:28,000
可以看到啊

315
00:09:28,000 --> 00:09:29,000
我们的pass呢

316
00:09:29,000 --> 00:09:31,000
从一开始的LLVM的pass

317
00:09:31,000 --> 00:09:33,000
有无线的继承器

318
00:09:33,000 --> 00:09:35,000
然后有高度的抽象的三地址

319
00:09:35,000 --> 00:09:35,000


320
00:09:35,000 --> 00:09:37,000
在我们的instruction selection

321
00:09:37,000 --> 00:09:38,000
指令选择的时候呢

322
00:09:38,000 --> 00:09:39,000
把LLVM IR

323
00:09:39,000 --> 00:09:40,000
变成一个DAG图

324
00:09:40,000 --> 00:09:42,000
做了进一步的抽象和提取

325
00:09:42,000 --> 00:09:43,000
那这个提取呢

326
00:09:43,000 --> 00:09:45,000
没有LLVM所抽象

327
00:09:45,000 --> 00:09:46,000
那再往下走了

328
00:09:46,000 --> 00:09:48,000
就是更贴近底层了

329
00:09:48,000 --> 00:09:49,000
所以每一次执行之后呢

330
00:09:49,000 --> 00:09:51,000
都会把一些抽象的概念

331
00:09:51,000 --> 00:09:53,000
变成我们实际的物理意义

332
00:09:55,000 --> 00:09:55,000


333
00:09:55,000 --> 00:09:57,000
我们总体来回顾一下

334
00:09:57,000 --> 00:09:59,000
整个编译器的流程

335
00:09:59,000 --> 00:10:00,000
整个编译器呢

336
00:10:00,000 --> 00:10:01,000
我们输入C和C++

337
00:10:01,000 --> 00:10:02,000
或者Objective C

338
00:10:02,000 --> 00:10:03,000
这些高级的语言

339
00:10:03,000 --> 00:10:05,000
输给我们的前端

340
00:10:05,000 --> 00:10:06,000
经过词法分析

341
00:10:06,000 --> 00:10:07,000
语法分析

342
00:10:07,000 --> 00:10:08,000
语义分析之后呢

343
00:10:08,000 --> 00:10:10,000
就变成我们的AST树

344
00:10:10,000 --> 00:10:11,000
那AST树之后呢

345
00:10:11,000 --> 00:10:12,000
在进入第一个pass之前呢

346
00:10:12,000 --> 00:10:14,000
它会转换成为我们的IR

347
00:10:14,000 --> 00:10:16,000
也就是IR generation

348
00:10:16,000 --> 00:10:17,000
而LLVM IR呢

349
00:10:17,000 --> 00:10:20,000
全都是SSA三地址指令

350
00:10:20,000 --> 00:10:22,000
去表示我们的 IR的一个结构

351
00:10:22,000 --> 00:10:23,000
那表示完之后呢

352
00:10:23,000 --> 00:10:25,000
我们会有非常多的 IR

353
00:10:25,000 --> 00:10:26,000
不同的 IR

354
00:10:26,000 --> 00:10:28,000
去优化我们的这个LLVM的代码

355
00:10:28,000 --> 00:10:29,000
优化完之后呢

356
00:10:29,000 --> 00:10:30,000
就会把LLVM的代码呢

357
00:10:30,000 --> 00:10:32,000
变成我们的一个DAG图

358
00:10:32,000 --> 00:10:33,000
那这个呢

359
00:10:33,000 --> 00:10:35,000
就是我们实际的DAG图

360
00:10:35,000 --> 00:10:37,000
DAG里面的每个节点呢

361
00:10:37,000 --> 00:10:38,000
就是对应的指令

362
00:10:38,000 --> 00:10:40,000
节点跟节点之间的边呢

363
00:10:40,000 --> 00:10:42,000
就是我们的数据的流向

364
00:10:42,000 --> 00:10:43,000
经过指令选择

365
00:10:43,000 --> 00:10:44,000
指令调度

366
00:10:44,000 --> 00:10:45,000
进行其分配

367
00:10:45,000 --> 00:10:47,000
再进行第二次的指令调度

368
00:10:47,000 --> 00:10:47,000


369
00:10:47,000 --> 00:10:49,000
就会生成我们的目标代码

370
00:10:49,000 --> 00:10:50,000
或者机器代码

371
00:10:50,000 --> 00:10:50,000


372
00:10:50,000 --> 00:10:53,000
就是整个LLVM的编译器的流程

373
00:10:53,000 --> 00:10:55,000
或者LLVM编译器的过程

374
00:10:55,000 --> 00:10:56,000
里面的每一个模块

375
00:10:56,000 --> 00:10:58,000
每一个Path都可以独立的去运作

376
00:10:58,000 --> 00:11:00,000
都可以把它抽出来

377
00:11:00,000 --> 00:11:01,000
如果你不想要这个Path

378
00:11:01,000 --> 00:11:02,000
你通过命令行

379
00:11:02,000 --> 00:11:03,000
OPT的这个命令行

380
00:11:03,000 --> 00:11:04,000
直接把它删掉

381
00:11:04,000 --> 00:11:06,000
或者告诉我们的Path Manager

382
00:11:06,000 --> 00:11:08,000
我不需要这个Path就好了

383
00:11:08,000 --> 00:11:10,000
如果你需要新增的一个Path

384
00:11:10,000 --> 00:11:11,000
你告诉我们的Path Manager

385
00:11:11,000 --> 00:11:13,000
去新增一个Path就行了

386
00:11:13,000 --> 00:11:14,000
所以Path Manager的管理呢

387
00:11:14,000 --> 00:11:16,000
是非常强大的

388
00:11:17,000 --> 00:11:18,000
到这里为止呢

389
00:11:18,000 --> 00:11:20,000
已经是我们传统编译器LLVM的

390
00:11:20,000 --> 00:11:22,000
一个最后的环节

391
00:11:22,000 --> 00:11:24,000
GLLVM的项目

392
00:11:24,000 --> 00:11:26,000
在介绍LLVM的项目之前呢

393
00:11:26,000 --> 00:11:29,000
我非常推荐YouTube的一个视频

394
00:11:29,000 --> 00:11:30,000
这个视频呢

395
00:11:30,000 --> 00:11:31,000
就是我们的LLM之父Christ

396
00:11:31,000 --> 00:11:34,000
在2021年的一个Presentation

397
00:11:34,000 --> 00:11:37,000
编译器的黄金时代

398
00:11:37,000 --> 00:11:39,000
LLVM之父Christ

399
00:11:39,000 --> 00:11:41,000
在发表了这篇文章之后呢

400
00:11:41,000 --> 00:11:42,000
没过几个月

401
00:11:42,000 --> 00:11:43,000
他就离职了

402
00:11:43,000 --> 00:11:45,000
然后去创建了一家新的公司

403
00:11:45,000 --> 00:11:46,000
叫做Modular

404
00:11:46,000 --> 00:11:47,000
他的目标呢

405
00:11:47,000 --> 00:11:48,000
是重建全球的

406
00:11:48,000 --> 00:11:50,000
AI和机器学习的基础设施

407
00:11:50,000 --> 00:11:52,000
包括编译器运行时异构计算

408
00:11:53,000 --> 00:11:54,000
从边缘到中心的并用

409
00:11:54,000 --> 00:11:55,000
那这个Modular

410
00:11:55,000 --> 00:11:56,000
我们也可以看到

411
00:11:56,000 --> 00:11:57,000
是模块化

412
00:11:57,000 --> 00:11:59,000
他到底会给AI编译器

413
00:11:59,000 --> 00:12:01,000
带来哪些模块化的工作呢

414
00:12:01,000 --> 00:12:03,000
而Christ后面的中心工作

415
00:12:03,000 --> 00:12:05,000
也是转到AI编译器上面

416
00:12:05,000 --> 00:12:06,000
可以看到

417
00:12:06,000 --> 00:12:07,000
AI编译器

418
00:12:07,000 --> 00:12:09,000
未来肯定是市场非常大

419
00:12:09,000 --> 00:12:11,000
技术含量非常高

420
00:12:11,000 --> 00:12:13,000
非常值得探索的一个领域

421
00:12:13,000 --> 00:12:14,000
下面呢

422
00:12:14,000 --> 00:12:15,000
讲讲几个利用到了

423
00:12:15,000 --> 00:12:17,000
LLVM的一些编译器

424
00:12:17,000 --> 00:12:18,000
第一个呢

425
00:12:18,000 --> 00:12:19,000
就是XLA

426
00:12:19,000 --> 00:12:20,000
那XLA呢

427
00:12:20,000 --> 00:12:21,000
是谷歌推出的一个

428
00:12:21,000 --> 00:12:23,000
模块机学习的一个编译器

429
00:12:23,000 --> 00:12:24,000
可能你没听过XLA

430
00:12:24,000 --> 00:12:25,000
没关系

431
00:12:25,000 --> 00:12:26,000
但是TensorFlow里面的

432
00:12:26,000 --> 00:12:27,000
大部分代码

433
00:12:27,000 --> 00:12:28,000
或者大部分算子呢

434
00:12:28,000 --> 00:12:31,000
都是通过XLA进行一个编译的

435
00:12:31,000 --> 00:12:32,000
然后呢

436
00:12:32,000 --> 00:12:33,000
你可能会非常多的

437
00:12:33,000 --> 00:12:35,000
听过TensorFlow

438
00:12:35,000 --> 00:12:36,000
那TensorFlow底层呢

439
00:12:36,000 --> 00:12:37,000
就是用XLA

440
00:12:37,000 --> 00:12:38,000
XLA的底层呢

441
00:12:38,000 --> 00:12:39,000
就是用LLVM

442
00:12:40,000 --> 00:12:41,000
那第二个呢

443
00:12:41,000 --> 00:12:42,000
就是JAX

444
00:12:42,000 --> 00:12:43,000
那JAX呢

445
00:12:43,000 --> 00:12:44,000
这也是谷歌

446
00:12:44,000 --> 00:12:45,000
他推出的

447
00:12:45,000 --> 00:12:46,000
一个把Autobrain的

448
00:12:46,000 --> 00:12:48,000
就是自动微分和XLA

449
00:12:48,000 --> 00:12:50,000
结合的一个深度学习的库

450
00:12:50,000 --> 00:12:52,000
那我刚才说的是

451
00:12:52,000 --> 00:12:53,000
深度学习库

452
00:12:53,000 --> 00:12:54,000
因为他最近呢

453
00:12:54,000 --> 00:12:56,000
用在做一些深度学习的工作

454
00:12:56,000 --> 00:12:57,000
但实际上

455
00:12:57,000 --> 00:12:58,000
他是一个高性能的

456
00:12:58,000 --> 00:12:59,000
数字计算的库

457
00:12:59,000 --> 00:13:00,000
就他可以做很多

458
00:13:00,000 --> 00:13:01,000
传统HPC

459
00:13:01,000 --> 00:13:03,000
所用到的计算

460
00:13:04,000 --> 00:13:05,000
第三个呢

461
00:13:05,000 --> 00:13:07,000
毫无疑问就是TensorFlow

462
00:13:07,000 --> 00:13:09,000
那TensorFlow可能很多

463
00:13:09,000 --> 00:13:10,000
在学术界或者学生

464
00:13:10,000 --> 00:13:12,000
可能会用的比较少

465
00:13:12,000 --> 00:13:13,000
但是在工业界

466
00:13:13,000 --> 00:13:14,000
包括我们现在

467
00:13:14,000 --> 00:13:16,000
接触到的一些客户

468
00:13:16,000 --> 00:13:17,000
字节跳动

469
00:13:17,000 --> 00:13:18,000
腾讯阿里巴巴

470
00:13:18,000 --> 00:13:19,000
这样的大库库

471
00:13:19,000 --> 00:13:21,000
他们大部分都会用TensorFlow

472
00:13:21,000 --> 00:13:22,000
或者没有完全

473
00:13:22,000 --> 00:13:24,000
从PyTorch转过来

474
00:13:24,000 --> 00:13:25,000
大家可以看一下

475
00:13:25,000 --> 00:13:26,000
我的AI框架基础里面

476
00:13:26,000 --> 00:13:27,000
去介绍PyTorch

477
00:13:27,000 --> 00:13:28,000
TensorFlow

478
00:13:28,000 --> 00:13:29,000
还有MineSmart

479
00:13:29,000 --> 00:13:30,000
这些新一代的

480
00:13:30,000 --> 00:13:31,000
AI框架之争

481
00:13:31,000 --> 00:13:32,000
里面就讲到了

482
00:13:32,000 --> 00:13:33,000
TensorFlow

483
00:13:33,000 --> 00:13:34,000
它是非常好的

484
00:13:34,000 --> 00:13:35,000
用在我们的

485
00:13:35,000 --> 00:13:37,000
工业生产环境的

486
00:13:37,000 --> 00:13:38,000
而TensorFlow的底层呢

487
00:13:38,000 --> 00:13:39,000
依赖于我们刚才讲的

488
00:13:39,000 --> 00:13:40,000
XLA

489
00:13:40,000 --> 00:13:41,000
XLA呢又依赖于

490
00:13:41,000 --> 00:13:42,000
我们的LVM

491
00:13:42,000 --> 00:13:44,000
之上去构建的

492
00:13:45,000 --> 00:13:46,000
那最后一个呢

493
00:13:46,000 --> 00:13:47,000
就是端到端的

494
00:13:47,000 --> 00:13:48,000
一个深度学习编译器

495
00:13:48,000 --> 00:13:49,000
TVM

496
00:13:49,000 --> 00:13:50,000
成天奇

497
00:13:50,000 --> 00:13:51,000
教授所发明的

498
00:13:51,000 --> 00:13:52,000
编译全栈

499
00:13:52,000 --> 00:13:53,000
里面呢

500
00:13:53,000 --> 00:13:54,000
就用到了LVM

501
00:13:54,000 --> 00:13:55,000
去对不同的硬件

502
00:13:55,000 --> 00:13:57,000
进行一个编译的

503
00:13:58,000 --> 00:13:59,000
最后一个就是

504
00:13:59,000 --> 00:14:00,000
Julia

505
00:14:00,000 --> 00:14:01,000
一种新的语言

506
00:14:01,000 --> 00:14:02,000
面向科学计算

507
00:14:02,000 --> 00:14:03,000
就是HPC的

508
00:14:03,000 --> 00:14:04,000
高性能动态语言

509
00:14:04,000 --> 00:14:05,000
里面呢

510
00:14:05,000 --> 00:14:07,000
就用了LVM的JIT编译

511
00:14:07,000 --> 00:14:08,000
就是Just-In-Time

512
00:14:08,000 --> 00:14:10,000
即时编译的能力

513
00:14:11,000 --> 00:14:12,000
好了

514
00:14:12,000 --> 00:14:13,000
关于传统编译器的介绍

515
00:14:13,000 --> 00:14:14,000
就这么多

516
00:14:14,000 --> 00:14:15,000
谢谢各位

517
00:14:16,000 --> 00:14:17,000
卷的不行了

518
00:14:17,000 --> 00:14:18,000
卷的不行了

519
00:14:18,000 --> 00:14:19,000
记得一键三连

520
00:14:19,000 --> 00:14:20,000
加关注哦

521
00:14:20,000 --> 00:14:21,000
所有的内容

522
00:14:21,000 --> 00:14:22,000
都会开源在

523
00:14:22,000 --> 00:14:23,000
下面这条链接里面

524
00:14:23,000 --> 00:14:24,000
拜拜

