1
00:00:00,000 --> 00:00:14,000
哈喽大家好我是宗敏现在已经是我看看啊到了晚上凌晨一点多了我刚到东莞这是我到东莞集结的第一天

2
00:00:14,000 --> 00:00:27,000
昨天的晚上那今天呢我们来到了一个AI芯片里面的AI计算体系主要我们讲到的是计算体系里面的我们整体的目录在整体的目录里面呢我们现在来到了这个内容

3
00:00:27,000 --> 00:00:30,000
整个计算体系和矩阵的运算

4
00:00:30,000 --> 00:00:36,000
而最重要的我会给大家带来一些新的或者我自己的还有在网上去摘录的一些思考

5
00:00:36,000 --> 00:00:41,000
那最重要的我们在AI计算体系和矩阵运算里面的分享四个内容

6
00:00:41,000 --> 00:00:45,000
第一个呢就是AI芯片的关键指标key matrix

7
00:00:45,000 --> 00:00:49,000
第二个呢就是比特的位数还有矩阵程

8
00:00:49,000 --> 00:00:52,000
那这两个呢是更细的一些细节了

9
00:00:52,000 --> 00:01:03,000
最后我们看一下Domain Specific一些专用的硬件具体对于AI这个产业或者AI这个芯片呢有哪些牵引的方向和它的计算体系有什么不一样

10
00:01:03,000 --> 00:01:08,000
那今天我们主要是快速的去过一下AI芯片的关键指标这个内容

11
00:01:08,000 --> 00:01:13,000
好了来到我们的正式的内容之前呢我们来看看整体的算力单位

12
00:01:13,000 --> 00:01:23,000
不管是哪款芯片刚发布包括里面的最近的苹果的M2这块SoC里面都会大量的提到我的峰值的算力到底是多少

13
00:01:23,000 --> 00:01:26,000
我到底有多少倍的性能的提升

14
00:01:26,000 --> 00:01:30,000
而这里面呢我们看看算力的单位呢主要有两个

15
00:01:30,000 --> 00:01:34,000
第一个呢是OPS注意哦OPS三个字母都是大写

16
00:01:34,000 --> 00:01:41,000
然后呢还有另外一个叫做MACS注意了这里面的X呢是小写

17
00:01:41,000 --> 00:01:46,000
而我们现在来看看OPS呢主要是指Operations Per Second

18
00:01:46,000 --> 00:01:50,000
每秒能够去运行的多少次计算

19
00:01:50,000 --> 00:01:57,000
那这个时候呢下面有另外一个单位加了1-W是指每瓦特的运算的性能

20
00:01:57,000 --> 00:02:05,000
那通常我们在评判一款SoC的时候呢就会经常用T-OPS-W这种去评价我们的处理器的性能

21
00:02:05,000 --> 00:02:08,000
那下面我们看一下MACS

22
00:02:08,000 --> 00:02:14,000
MACS其实我们后面会大量的去讲到的就是Multiply Accumulate Operations

23
00:02:14,000 --> 00:02:19,000
层加累积操作可以看到的层加累积操作主要是我们在前面的介绍过

24
00:02:19,000 --> 00:02:24,000
我们网络的最主要的运算就是层加累积操作了

25
00:02:24,000 --> 00:02:29,000
而一个层积累积操作呢就包括一个乘法和一个加法

26
00:02:29,000 --> 00:02:32,000
这里面呢就是就涉及到两个Flops了

27
00:02:33,000 --> 00:02:35,000
那接下来我们再看两个概念

28
00:02:35,000 --> 00:02:40,000
两个呢就是MAC还有FLOPS

29
00:02:40,000 --> 00:02:44,000
注意这里面呢MAC这个C后面没有S

30
00:02:44,000 --> 00:02:48,000
而Flops呢后面的S是小写

31
00:02:48,000 --> 00:02:52,000
这两个两个单位呢有点不一样跟模型相关

32
00:02:52,000 --> 00:02:55,000
像Flops呢主要是Full Point Operations

33
00:02:55,000 --> 00:02:58,000
具体的S呢是来自于这里面的X

34
00:02:58,000 --> 00:03:01,000
主要指的是就是浮点的运算的次数

35
00:03:01,000 --> 00:03:03,000
主要用来衡量我们的网络模型啊

36
00:03:03,000 --> 00:03:05,000
我们的AI模型我们的算法的复杂度

37
00:03:05,000 --> 00:03:09,000
第二个呢是MAC这个是跟内存相关的

38
00:03:09,000 --> 00:03:11,000
叫做Memory Assessed Cost

39
00:03:11,000 --> 00:03:13,000
用来评价我们一些AI算法

40
00:03:13,000 --> 00:03:16,000
一些MobileNet在内存里面的MACX呢

41
00:03:16,000 --> 00:03:21,000
特别是我们的AI芯片里面的一些主要的运算的性能

42
00:03:21,000 --> 00:03:25,000
而在我们后面讲到AI芯片的关键的Matrix

43
00:03:25,000 --> 00:03:27,000
就是接下来要分享的内容

44
00:03:27,000 --> 00:03:31,000
里面就会大量的去用到下面上面

45
00:03:31,000 --> 00:03:33,000
主要的算力的指标

46
00:03:33,000 --> 00:03:36,000
后面呢就不会再详细的单独的展开

47
00:03:36,000 --> 00:03:37,000
而是只用

48
00:03:37,000 --> 00:03:40,000
而是统一通过简称来去给大家

49
00:03:40,000 --> 00:03:42,000
它只是一个开篇的开胃菜

50
00:03:42,000 --> 00:03:44,000
大家知道有这么一回事就好了

51
00:03:46,000 --> 00:03:48,000
接下来呢我们来到一个正式的内容

52
00:03:48,000 --> 00:03:52,000
AI芯片的关键指标Key Matrix

53
00:03:52,000 --> 00:03:54,000
来到Key Matrix

54
00:03:55,000 --> 00:03:58,000
是指我们的模型结果的精度

55
00:03:58,000 --> 00:04:00,000
还包括我们的计算的精度

56
00:04:00,000 --> 00:04:03,000
例如我用FP32FP16来去计算

57
00:04:03,000 --> 00:04:05,000
还是用int8来去计算

58
00:04:05,000 --> 00:04:08,000
第二个呢就是吞吐量

59
00:04:09,000 --> 00:04:10,000
评错了

60
00:04:10,000 --> 00:04:11,000
没关系我们后劝

61
00:04:11,000 --> 00:04:12,000
没关系

62
00:04:12,000 --> 00:04:14,000
我们后面再改改

63
00:04:14,000 --> 00:04:15,000
我们对于

64
00:04:15,000 --> 00:04:17,000
而吞吐量呢主要是的数据量特别大

65
00:04:17,000 --> 00:04:19,000
它怎么去对这些数据进行除去

66
00:04:19,000 --> 00:04:21,000
它的吞吐量到底有多少

67
00:04:21,000 --> 00:04:24,000
第二个呢主要是指我们的实时的性能

68
00:04:24,000 --> 00:04:26,000
能不能够快速的去处理

69
00:04:26,000 --> 00:04:28,000
我们每秒30fps

70
00:04:28,000 --> 00:04:30,000
或者每秒20token的这样的数据

71
00:04:30,000 --> 00:04:31,000
那这两个呢

72
00:04:31,000 --> 00:04:33,000
其实都跟数据相关

73
00:04:33,000 --> 00:04:35,000
第三个呢就是时间

74
00:04:39,000 --> 00:04:42,000
一个时间我们叫做TTA

75
00:04:42,000 --> 00:04:45,000
那后面呢我们还有几个指标

76
00:04:45,000 --> 00:04:47,000
那可以展开一下

77
00:04:47,000 --> 00:04:49,000
像能耗这个其实非常关键的

78
00:04:49,000 --> 00:04:52,000
能耗不仅仅是指电池容量是有限的

79
00:04:52,000 --> 00:04:54,000
每秒去执行多少个fps

80
00:04:54,000 --> 00:04:56,000
我们的能耗消耗是多少

81
00:04:56,000 --> 00:04:58,000
那这个就我们刚才指到的

82
00:04:58,000 --> 00:05:02,000
OPX每瓦特的性能了

83
00:05:02,000 --> 00:05:05,000
另外呢还有数据中心的夜冷等大功耗

84
00:05:05,000 --> 00:05:09,000
对我们确实也是一个很重要的衡量指标

85
00:05:09,000 --> 00:05:11,000
第五个呢就是系统的价格

86
00:05:11,000 --> 00:05:13,000
我们叫做系统的价格

87
00:05:13,000 --> 00:05:16,000
是因为我们不仅包括AI芯片支撑的价格

88
00:05:16,000 --> 00:05:18,000
包括我们的去光刻或者流片的价格

89
00:05:18,000 --> 00:05:22,000
我们还包括系统集成上下游全站的成本

90
00:05:22,000 --> 00:05:23,000
因为我们有了芯片之后

91
00:05:23,000 --> 00:05:26,000
我们要基于芯片的开发相关的

92
00:05:27,000 --> 00:05:29,000
还有在对上的SDK

93
00:05:29,000 --> 00:05:32,000
这些都是我们的系统的价格

94
00:05:32,000 --> 00:05:35,000
这些呢芯片你不仅是买他的芯片

95
00:05:35,000 --> 00:05:37,000
你买生腾的一款产品

96
00:05:37,000 --> 00:05:39,000
也不仅是买他的产品

97
00:05:39,000 --> 00:05:41,000
而是他产品配套的服务

98
00:05:41,000 --> 00:05:42,000
配套的软硬件

99
00:05:42,000 --> 00:05:44,000
那最后一个呢就是应用性的

100
00:05:44,000 --> 00:05:47,000
应用性这个其实很难去衡量的

101
00:05:47,000 --> 00:05:49,000
他主要是看我们的开发的效率

102
00:05:49,000 --> 00:05:50,000
还有开发的难度

103
00:05:50,000 --> 00:05:52,000
而应用性的好坏呢

104
00:05:52,000 --> 00:05:55,000
确实决定于我们整款的芯片

105
00:05:55,000 --> 00:05:57,000
用的人的多和少

106
00:05:57,000 --> 00:06:00,000
而且决定用户用的爽还是不爽

107
00:06:02,000 --> 00:06:05,000
下面我们看很多指标

108
00:06:05,000 --> 00:06:07,000
但是我们还是有一些关键的一些点

109
00:06:07,000 --> 00:06:09,000
例如我们希望

110
00:06:09,000 --> 00:06:12,000
例如呢我们在跟客户交流会经常发现

111
00:06:12,000 --> 00:06:16,000
确实要尽可能的去提高我们的吞吐量

112
00:06:16,000 --> 00:06:17,000
Increase整个Fullput

113
00:06:17,000 --> 00:06:19,000
还有降低我们自己的食盐

114
00:06:19,000 --> 00:06:23,000
那这个呢主要是针对我们数据去处理的

115
00:06:23,000 --> 00:06:26,000
那是跟我们的数据和计算相关的

116
00:06:26,000 --> 00:06:28,000
所以我们很多时候呢

117
00:06:28,000 --> 00:06:31,000
大部分我们都会跟数据和计算

118
00:06:31,000 --> 00:06:34,000
内存三个东西打交道

119
00:06:34,000 --> 00:06:37,000
那第二点呢就是低食盐和Batch Size

120
00:06:37,000 --> 00:06:39,000
之间的一个平衡

121
00:06:39,000 --> 00:06:40,000
我们叫做Tradeoff

122
00:06:40,000 --> 00:06:41,000
我想要食盐更低

123
00:06:41,000 --> 00:06:43,000
我的Batch Size的更少

124
00:06:43,000 --> 00:06:45,000
我的每一次处理的数据肯定要少

125
00:06:45,000 --> 00:06:47,000
每一次处理的数据大了

126
00:06:47,000 --> 00:06:49,000
我的食盐就会上去了

127
00:06:49,000 --> 00:06:51,000
所以我们中间呢会取一个Tradeoff

128
00:06:51,000 --> 00:06:54,000
我们的芯片到底能支持多大的Batch Size

129
00:06:54,000 --> 00:06:56,000
能支持多大的数据的吞吐量

130
00:06:56,000 --> 00:07:00,000
然后跟我们的食盐也是

131
00:07:00,000 --> 00:07:03,000
跟我们的食盐我们

132
00:07:03,000 --> 00:07:07,000
是MACS在整个AI加速器

133
00:07:07,000 --> 00:07:09,000
或者AI芯片的关键的设计点呢

134
00:07:09,000 --> 00:07:12,000
我们很多时候啊在软件的角度来看呢

135
00:07:12,000 --> 00:07:15,000
在两个我比较关心的点

136
00:07:15,000 --> 00:07:18,000
第一个呢就是去掉没有意义的MACS

137
00:07:18,000 --> 00:07:20,000
去掉没有意义的计算

138
00:07:20,000 --> 00:07:22,000
那去掉没有意义的

139
00:07:22,000 --> 00:07:24,000
整体的时钟周期

140
00:07:24,000 --> 00:07:26,000
去Save我们的Cycle

141
00:07:26,000 --> 00:07:27,000
第二个呢

142
00:07:27,000 --> 00:07:28,000
去Save我们的Cycle

143
00:07:28,000 --> 00:07:30,000
另外呢他可能还有其他点

144
00:07:30,000 --> 00:07:32,000
就是降低每一次MACS的

145
00:07:32,000 --> 00:07:34,000
降低每一次计算的时间

146
00:07:34,000 --> 00:07:36,000
例如我们可以增加我们的

147
00:07:36,000 --> 00:07:38,000
时钟的周期的频率啦

148
00:07:38,000 --> 00:07:40,000
那这个时候我们可能功耗也会去上去

149
00:07:40,000 --> 00:07:43,000
第六个呢就是减少指令的开销

150
00:07:43,000 --> 00:07:45,000
那这个时候呢就需要我们

151
00:07:45,000 --> 00:07:47,000
对指令进行一个精简

152
00:07:47,000 --> 00:07:48,000
有关系

153
00:07:48,000 --> 00:07:49,000
可能还会对我们的编译器

154
00:07:49,000 --> 00:07:51,000
对我们的并行的策略

155
00:07:51,000 --> 00:07:53,000
还有我们的数据执行的策略

156
00:07:53,000 --> 00:07:55,000
有关系

157
00:07:55,000 --> 00:07:58,000
下面呢是第二个关键的设计点

158
00:07:58,000 --> 00:07:59,000
PE

159
00:07:59,000 --> 00:08:02,000
在AI加速器另外一个设计关键点呢

160
00:08:02,000 --> 00:08:04,000
我们叫做PE

161
00:08:04,000 --> 00:08:05,000
往下面这个图来看

162
00:08:05,000 --> 00:08:08,000
PE实际上呢就是我们的执行单元

163
00:08:08,000 --> 00:08:11,000
每一款芯片呢都会有大量的PE在内

164
00:08:11,000 --> 00:08:13,000
或者在我们的SIMD架构里面呢

165
00:08:13,000 --> 00:08:14,000
有非常多的PE

166
00:08:14,000 --> 00:08:16,000
在我们的SIMT里面呢

167
00:08:16,000 --> 00:08:18,000
你可以把大量的CUDA Core呢

168
00:08:18,000 --> 00:08:20,000
看成独立的每一个的PE

169
00:08:20,000 --> 00:08:23,000
那我们为了让我们的芯片跑得更快

170
00:08:23,000 --> 00:08:25,000
首先第一个呢就是增加PE的数量

171
00:08:25,000 --> 00:08:27,000
PE的数量肯定越多越好

172
00:08:27,000 --> 00:08:30,000
使用台积电更高纳米的制程

173
00:08:30,000 --> 00:08:32,000
或者中芯国际更高纳米的制程呢

174
00:08:32,000 --> 00:08:34,000
就可以增加我们PE的面积的密度

175
00:08:34,000 --> 00:08:35,000
这个时候

176
00:08:35,000 --> 00:08:38,000
一款PE可以容纳更多的晶体管

177
00:08:38,000 --> 00:08:40,000
这个时候我执行的效率可能会更高

178
00:08:40,000 --> 00:08:42,000
或者我硬的位置呢

179
00:08:42,000 --> 00:08:43,000
可以塞更多的PE

180
00:08:43,000 --> 00:08:45,000
这也可以提升我们PE的核心的数量

181
00:08:45,000 --> 00:08:48,000
第二个呢就是增加PE的利用率

182
00:08:48,000 --> 00:08:49,000
因为我们可以看到呢

183
00:08:49,000 --> 00:08:50,000
在一款芯片里面呢

184
00:08:50,000 --> 00:08:52,000
有非常多的PE

185
00:08:52,000 --> 00:08:54,000
非常多的计算的核心

186
00:08:54,000 --> 00:08:55,000
那这个时候呢

187
00:08:55,000 --> 00:08:57,000
我们就要把不同的任务

188
00:08:57,000 --> 00:08:59,000
均衡地分配到不同的PE上面

189
00:08:59,000 --> 00:09:02,000
让我们的PE呢满打满地去执行

190
00:09:02,000 --> 00:09:05,000
另外呢可能还会选择合适的内存带宽

191
00:09:05,000 --> 00:09:09,000
有效地去降低我们整个空闲的时钟周期

192
00:09:09,000 --> 00:09:11,000
就是简单的来说

193
00:09:11,000 --> 00:09:13,000
我们的数据的流动的频率

194
00:09:13,000 --> 00:09:15,000
要跟我们的PE的处理的频率

195
00:09:15,000 --> 00:09:16,000
要匹配得上

196
00:09:16,000 --> 00:09:20,000
才能够让我们PE发挥更大的效用

197
00:09:22,000 --> 00:09:23,000
诶 救命老师

198
00:09:23,000 --> 00:09:24,000
等一下等一下

199
00:09:24,000 --> 00:09:26,000
你刚才讲了很多内容

200
00:09:26,000 --> 00:09:28,000
我有两个问题啊

201
00:09:28,000 --> 00:09:30,000
第一个你刚才讲到

202
00:09:30,000 --> 00:09:33,000
AI芯片的关键指标里面呢

203
00:09:33,000 --> 00:09:35,000
有吞吐量和食盐

204
00:09:35,000 --> 00:09:38,000
那这个主要是由什么产生的吗

205
00:09:38,000 --> 00:09:39,000
小新同学你好

206
00:09:39,000 --> 00:09:41,000
在AI芯片的关键的指标呢

207
00:09:41,000 --> 00:09:42,000
主要有六项

208
00:09:42,000 --> 00:09:44,000
这里面呢吞吐量和食盐就占了两上

209
00:09:44,000 --> 00:09:46,000
这两个呢更多的是由我们的计算

210
00:09:46,000 --> 00:09:48,000
还有我们的内存导致的

211
00:09:48,000 --> 00:09:50,000
我们的计算越快

212
00:09:50,000 --> 00:09:52,000
我们的食盐肯定就越少

213
00:09:52,000 --> 00:09:53,000
但是我们的食盐

214
00:09:53,000 --> 00:09:55,000
不仅仅是跟我们的计算量相关

215
00:09:55,000 --> 00:09:57,000
还跟我们的吞吐量相关

216
00:09:57,000 --> 00:09:59,000
我们吞吐量越大

217
00:09:59,000 --> 00:10:02,000
我们的食盐也会相对应的去减少

218
00:10:02,000 --> 00:10:03,000
那这个时候呢

219
00:10:03,000 --> 00:10:05,000
吞吐量和食盐是息息相关的

220
00:10:05,000 --> 00:10:06,000
我们在后面那个内容

221
00:10:06,000 --> 00:10:07,000
计算仿真的时候呢

222
00:10:07,000 --> 00:10:09,000
就会给大家去看看

223
00:10:09,000 --> 00:10:11,000
这里面具体有什么关系

224
00:10:11,000 --> 00:10:13,000
应该怎么去处理好

225
00:10:13,000 --> 00:10:16,000
我们的芯片应该用哪个明确的指标

226
00:10:16,000 --> 00:10:18,000
或者仿真的指标去做牵引

227
00:10:18,000 --> 00:10:19,000
那第二个

228
00:10:19,000 --> 00:10:20,000
也就是你刚才提到

229
00:10:20,000 --> 00:10:23,000
AI芯片的关键的设计点呢

230
00:10:23,000 --> 00:10:26,000
是MAC和PE

231
00:10:26,000 --> 00:10:30,000
感觉这两个主要是针对提升单个核心的

232
00:10:30,000 --> 00:10:32,000
计算能力是吗

233
00:10:32,000 --> 00:10:34,000
说的非常对

234
00:10:34,000 --> 00:10:36,000
我们刚才讲了两个内容

235
00:10:36,000 --> 00:10:37,000
一个是关键指标

236
00:10:37,000 --> 00:10:39,000
一个是关键的设计点

237
00:10:39,000 --> 00:10:40,000
关键的指标呢

238
00:10:40,000 --> 00:10:43,000
是整体的去看我们的AI芯片的

239
00:10:43,000 --> 00:10:44,000
而关键的设计点呢

240
00:10:44,000 --> 00:10:46,000
MAC和PE呢

241
00:10:46,000 --> 00:10:49,000
主要是针对我们单个核心的计算能力

242
00:10:49,000 --> 00:10:51,000
希望能够尽可能的去提升我们

243
00:10:51,000 --> 00:10:53,000
计算的峰值的算力

244
00:10:53,000 --> 00:10:54,000
那谈到这一点

245
00:10:54,000 --> 00:10:56,000
就引入了我们下个内容

246
00:10:56,000 --> 00:10:58,000
计算性能的仿真

247
00:10:58,000 --> 00:10:59,000
这里面有一张

248
00:10:59,000 --> 00:11:01,000
下面呢我们来到了这节分享里面

249
00:11:01,000 --> 00:11:03,000
或者给大家汇报里面的内容里面

250
00:11:03,000 --> 00:11:06,000
最精华或者最重要的一部分

251
00:11:06,000 --> 00:11:07,000
如果大家听不明白

252
00:11:07,000 --> 00:11:08,000
或者我讲的不太好呢

253
00:11:08,000 --> 00:11:10,000
欢迎大家来去指正

254
00:11:10,000 --> 00:11:12,000
就是我们整个计算性能的仿真

255
00:11:12,000 --> 00:11:14,000
下面的这个图是非常的核心

256
00:11:14,000 --> 00:11:16,000
也是来源于这篇论文

257
00:11:16,000 --> 00:11:17,000
我们现在来看看

258
00:11:17,000 --> 00:11:20,000
纵坐标和横坐标所代表的意义

259
00:11:20,000 --> 00:11:22,000
那横坐标呢

260
00:11:22,000 --> 00:11:24,000
主要是指我们的计算的密集度

261
00:11:24,000 --> 00:11:26,000
或者叫做计算的强度

262
00:11:26,000 --> 00:11:29,000
它的单位呢是ops byte

263
00:11:29,000 --> 00:11:30,000
纵坐标呢

264
00:11:30,000 --> 00:11:32,000
就是我们的性能performance

265
00:11:32,000 --> 00:11:35,000
它的单位呢是ops每second

266
00:11:35,000 --> 00:11:36,000
那这个时候呢

267
00:11:36,000 --> 00:11:39,000
我们中间有一条曲折线

268
00:11:39,000 --> 00:11:40,000
那这条曲折线呢

269
00:11:40,000 --> 00:11:43,000
代表的就是我们整个AI芯片的

270
00:11:43,000 --> 00:11:45,000
峰值算力

271
00:11:45,000 --> 00:11:47,000
峰值的性能

272
00:11:47,000 --> 00:11:48,000
而这个峰值性能呢

273
00:11:48,000 --> 00:11:50,000
更多的是指理论的峰值性能

274
00:11:50,000 --> 00:11:51,000
而不是实际的峰值性能

275
00:11:52,000 --> 00:11:54,000
实际的峰值性能呢

276
00:11:54,000 --> 00:11:56,000
我们会在后面去讲到

277
00:11:56,000 --> 00:11:58,000
现在有一个前提的假设

278
00:11:58,000 --> 00:12:01,000
假设我们现在的所有的PE

279
00:12:01,000 --> 00:12:02,000
就是所有的计算单元呢

280
00:12:02,000 --> 00:12:04,000
计算性能都是相同的

281
00:12:04,000 --> 00:12:05,000
那这个时候

282
00:12:05,000 --> 00:12:07,000
核心执行单元的数量越多

283
00:12:07,000 --> 00:12:08,000
理论上呢

284
00:12:08,000 --> 00:12:12,000
我们的峰值性能肯定是越高的

285
00:12:12,000 --> 00:12:14,000
这一条直线

286
00:12:14,000 --> 00:12:16,000
我们的计算性能

287
00:12:16,000 --> 00:12:18,000
是跟我们的数据相关的

288
00:12:18,000 --> 00:12:20,000
只要它PE有数据

289
00:12:20,000 --> 00:12:21,000
它能够执行起来

290
00:12:21,000 --> 00:12:22,000
那这个时候呢

291
00:12:22,000 --> 00:12:26,000
我们就对我们的这个图进行填充

292
00:12:26,000 --> 00:12:28,000
分成红色跟绿色

293
00:12:28,000 --> 00:12:29,000
这个部分

294
00:12:29,000 --> 00:12:30,000
这个部分呢

295
00:12:30,000 --> 00:12:32,000
就是我们的带宽的上限

296
00:12:32,000 --> 00:12:33,000
我们的带宽

297
00:12:33,000 --> 00:12:36,000
约我们整个运算的峰值性能

298
00:12:36,000 --> 00:12:38,000
假设我们的带宽传输的数据非常慢

299
00:12:38,000 --> 00:12:39,000
那这个时候

300
00:12:39,000 --> 00:12:41,000
不管我们的PE数量有多少

301
00:12:41,000 --> 00:12:43,000
它都不可能完全上去的

302
00:12:43,000 --> 00:12:45,000
因为PE的利用率非常高

303
00:12:45,000 --> 00:12:46,000
我们刚才也讲到了

304
00:12:46,000 --> 00:12:48,000
假设我们的带宽

305
00:12:48,000 --> 00:12:49,000
已经不再是瓶颈了

306
00:12:49,000 --> 00:12:51,000
它能够快速的把数据

307
00:12:51,000 --> 00:12:52,000
传到给我们的PE

308
00:12:52,000 --> 00:12:53,000
那这个时候呢

309
00:12:53,000 --> 00:12:55,000
PE的核心数量了

310
00:12:55,000 --> 00:12:57,000
就是右边的这个绿色

311
00:12:57,000 --> 00:12:59,000
compute bound

312
00:12:59,000 --> 00:13:00,000
峰值呢

313
00:13:00,000 --> 00:13:01,000
是跟我们的带宽

314
00:13:01,000 --> 00:13:03,000
和我们的PE计算的能力

315
00:13:03,000 --> 00:13:04,000
是相关的

316
00:13:04,000 --> 00:13:05,000
这个时候

317
00:13:05,000 --> 00:13:08,000
我们必须要寻求一个最平衡的点

318
00:13:08,000 --> 00:13:09,000
就是这个点

319
00:13:09,000 --> 00:13:10,000
能够让我们

320
00:13:10,000 --> 00:13:12,000
可能在一定数量的PE之下

321
00:13:12,000 --> 00:13:13,000
一定的带宽之下

322
00:13:13,000 --> 00:13:16,000
能够让我们的性能发挥到最好

323
00:13:16,000 --> 00:13:17,000
而不是说

324
00:13:17,000 --> 00:13:19,000
我的带宽设计的非常小

325
00:13:19,000 --> 00:13:20,000
但是我的PE

326
00:13:20,000 --> 00:13:22,000
我的核心执行数量非常多

327
00:13:22,000 --> 00:13:23,000
那这个时候呢

328
00:13:23,000 --> 00:13:25,000
我们是没有办法充分发挥

329
00:13:25,000 --> 00:13:27,000
我们的计算的性能的

330
00:13:27,000 --> 00:13:28,000
于是呢

331
00:13:28,000 --> 00:13:29,000
就着这个理论

332
00:13:29,000 --> 00:13:31,000
我们继续往下看一看

333
00:13:31,000 --> 00:13:32,000
那下面呢

334
00:13:32,000 --> 00:13:33,000
4呢

335
00:13:33,000 --> 00:13:34,000
讲的是一个相同的概念

336
00:13:34,000 --> 00:13:35,000
PE的数量了

337
00:13:35,000 --> 00:13:38,000
对我们整个峰值的算力的影响

338
00:13:38,000 --> 00:13:39,000
不过step5

339
00:13:39,000 --> 00:13:40,000
红色这条线呢

340
00:13:40,000 --> 00:13:41,000
就很有意思了

341
00:13:41,000 --> 00:13:43,000
就是我们PE执行单元的数量了

342
00:13:43,000 --> 00:13:44,000
小于我们的cash

343
00:13:44,000 --> 00:13:46,000
小于我们的存储单元的时候呢

344
00:13:46,000 --> 00:13:48,000
就会严重的约束了

345
00:13:48,000 --> 00:13:50,000
我们整个峰值的算力

346
00:13:50,000 --> 00:13:51,000
下面呢

347
00:13:51,000 --> 00:13:52,000
我们让我们看一下

348
00:13:52,000 --> 00:13:54,000
再往下step6的时候

349
00:13:54,000 --> 00:13:56,000
就是另外一种情况了

350
00:13:56,000 --> 00:13:57,000
这里的step呢

351
00:13:57,000 --> 00:13:58,000
不是指每一步

352
00:13:58,000 --> 00:14:00,000
而是指我们具体的case

353
00:14:00,000 --> 00:14:01,000
具体的情况

354
00:14:01,000 --> 00:14:02,000
那我们现在呢

355
00:14:02,000 --> 00:14:04,000
更低的算力的利用率

356
00:14:04,000 --> 00:14:06,000
或者更低的PE的利用力呢

357
00:14:06,000 --> 00:14:09,000
由于带宽不足所影响的

358
00:14:10,000 --> 00:14:11,000
性能就更差了

359
00:14:11,000 --> 00:14:13,000
现在我们PE的利用这么低

360
00:14:14,000 --> 00:14:16,000
同样是因为不足的内存带宽

361
00:14:16,000 --> 00:14:18,000
还有存取空间

362
00:14:18,000 --> 00:14:20,000
或者叫做cash

363
00:14:20,000 --> 00:14:21,000
那这个时候呢

364
00:14:21,000 --> 00:14:22,000
就会严重的制约到

365
00:14:22,000 --> 00:14:25,000
我们的整体的计算的性能

366
00:14:25,000 --> 00:14:27,000
而最好的计算性能呢

367
00:14:27,000 --> 00:14:29,000
就是我们绿色的这条线

368
00:14:29,000 --> 00:14:30,000
我们需要计算体系呢

369
00:14:30,000 --> 00:14:32,000
需要找到带宽

370
00:14:32,000 --> 00:14:35,000
还有PE之间的一个平衡点

371
00:14:35,000 --> 00:14:40,000
使得整个AI芯片的最优的性能值

372
00:14:41,000 --> 00:14:42,000
这么多内容呢

373
00:14:42,000 --> 00:14:43,000
我们回头看看

374
00:14:43,000 --> 00:14:45,000
刚才给大家去分享的key metrics

375
00:14:45,000 --> 00:14:47,000
就是我们的关键的实际指标

376
00:14:47,000 --> 00:14:49,000
跟计算体系的一个思考

377
00:14:49,000 --> 00:14:51,000
也就是作为一个总结了

378
00:14:51,000 --> 00:14:52,000
那首先第一个呢

379
00:14:52,000 --> 00:14:54,000
就是精度我们希望能够处理

380
00:14:54,000 --> 00:14:56,000
各种各样没有规则的数据

381
00:14:56,000 --> 00:14:58,000
还有应对很多复杂的网络模型

382
00:14:58,000 --> 00:14:59,000
那这个时候呢

383
00:14:59,000 --> 00:15:00,000
模式呢

384
00:15:00,000 --> 00:15:02,000
在英伟达的H100

385
00:15:02,000 --> 00:15:04,000
还有华为的NPU里面呢

386
00:15:04,000 --> 00:15:05,000
都是有一个的IP

387
00:15:05,000 --> 00:15:06,000
那第二种呢

388
00:15:06,000 --> 00:15:08,000
就是能够应对复杂的网络

389
00:15:08,000 --> 00:15:10,000
这个时候就要求我们的计算单元

390
00:15:10,000 --> 00:15:12,000
有充足的勇于性

391
00:15:12,000 --> 00:15:13,000
所谓的计算单元

392
00:15:13,000 --> 00:15:14,000
有充足的勇于性呢

393
00:15:14,000 --> 00:15:15,000
就是不仅仅我们能够处理

394
00:15:15,000 --> 00:15:17,000
cube矩阵的运算

395
00:15:17,000 --> 00:15:18,000
我们还要处理vector

396
00:15:18,000 --> 00:15:19,000
还有scalar

397
00:15:19,000 --> 00:15:21,000
标量和降量的数据

398
00:15:21,000 --> 00:15:22,000
那第二点呢

399
00:15:22,000 --> 00:15:24,000
就是我们刚才大量的提到的

400
00:15:24,000 --> 00:15:26,000
还有吞吐量和食盐

401
00:15:26,000 --> 00:15:27,000
吞吐量呢

402
00:15:27,000 --> 00:15:28,000
除了看峰值的算力

403
00:15:28,000 --> 00:15:29,000
我们很重要的就要看

404
00:15:29,000 --> 00:15:31,000
PE的平均的利用率

405
00:15:31,000 --> 00:15:32,000
PE的利用率越多

406
00:15:32,000 --> 00:15:34,000
我们的性能肯定是越好的

407
00:15:34,000 --> 00:15:35,000
另外还要看一下

408
00:15:35,000 --> 00:15:37,000
sota网络模型的整体的时间

409
00:15:37,000 --> 00:15:38,000
那这里面呢

410
00:15:38,000 --> 00:15:40,000
就很有意思的会去提到

411
00:15:40,000 --> 00:15:42,000
一个很重要的内容

412
00:15:42,000 --> 00:15:43,000
就是mlperf

413
00:15:43,000 --> 00:15:45,000
它是因为达根谷歌

414
00:15:45,000 --> 00:15:46,000
去主导的一个

415
00:15:46,000 --> 00:15:48,000
AI的benchmark

416
00:15:48,000 --> 00:15:50,000
去提升相同的网络模型

417
00:15:50,000 --> 00:15:51,000
不同的A框架

418
00:15:51,000 --> 00:15:53,000
不同的AI的芯片之下

419
00:15:53,000 --> 00:15:54,000
它的整体的性能

420
00:15:54,000 --> 00:15:55,000
而食盐呢

421
00:15:55,000 --> 00:15:56,000
更多的是

422
00:15:56,000 --> 00:15:59,000
希望我们能够食盐越少越好嘛

423
00:15:59,000 --> 00:16:00,000
那这个时候呢

424
00:16:00,000 --> 00:16:01,000
两个优化点

425
00:16:01,000 --> 00:16:02,000
就是优化我们的带宽呢

426
00:16:02,000 --> 00:16:05,000
优化我们的多极的缓存

427
00:16:05,000 --> 00:16:06,000
那下面呢

428
00:16:06,000 --> 00:16:07,000
来个内容

429
00:16:07,000 --> 00:16:09,000
能耗系统的价格

430
00:16:09,000 --> 00:16:10,000
还有易用性

431
00:16:10,000 --> 00:16:11,000
那能耗呢

432
00:16:11,000 --> 00:16:12,000
刚才讲了

433
00:16:12,000 --> 00:16:13,000
它跟我们的部署的场景

434
00:16:13,000 --> 00:16:14,000
是相关的

435
00:16:14,000 --> 00:16:15,000
我们的手机

436
00:16:15,000 --> 00:16:17,000
肯定能耗越少越好

437
00:16:17,000 --> 00:16:18,000
但是呢

438
00:16:18,000 --> 00:16:19,000
我们的数据中心

439
00:16:19,000 --> 00:16:20,000
我们可以有大量的供电

440
00:16:20,000 --> 00:16:21,000
我们有夜浪

441
00:16:21,000 --> 00:16:23,000
那这个时候的应用场景

442
00:16:23,000 --> 00:16:24,000
去驱动

443
00:16:24,000 --> 00:16:25,000
例如训练场景呢

444
00:16:25,000 --> 00:16:26,000
大部分都在训练中心

445
00:16:26,000 --> 00:16:28,000
在我们的AI计算中心

446
00:16:28,000 --> 00:16:29,000
另外呢

447
00:16:29,000 --> 00:16:30,000
我们很重要的一点

448
00:16:30,000 --> 00:16:32,000
就是减少内存的读写啊

449
00:16:32,000 --> 00:16:33,000
等各种方法

450
00:16:33,000 --> 00:16:34,000
去降低我们的能耗

451
00:16:34,000 --> 00:16:36,000
那系统的价值呢

452
00:16:36,000 --> 00:16:37,000
对我们的价格

453
00:16:37,000 --> 00:16:38,000
非常的敏感

454
00:16:38,000 --> 00:16:39,000
另外几个呢

455
00:16:39,000 --> 00:16:40,000
就是我们的电路设计了

456
00:16:40,000 --> 00:16:41,000
P的数量了

457
00:16:41,000 --> 00:16:42,000
芯片的大小了

458
00:16:42,000 --> 00:16:44,000
还有拉米的制程数了

459
00:16:44,000 --> 00:16:45,000
对我们的价格

460
00:16:45,000 --> 00:16:47,000
也是非常之敏感的

461
00:16:47,000 --> 00:16:48,000
另外呢

462
00:16:48,000 --> 00:16:49,000
整体的应用性

463
00:16:49,000 --> 00:16:51,000
主要是跟我们的软件站

464
00:16:51,000 --> 00:16:52,000
相关的

465
00:16:52,000 --> 00:16:54,000
软件站做得越好

466
00:16:54,000 --> 00:16:56,000
易用性肯定会越好

467
00:16:56,000 --> 00:16:57,000
而这个时候呢

468
00:16:57,000 --> 00:16:58,000
不仅仅只强调性能

469
00:16:58,000 --> 00:17:00,000
而且我们还要看看

470
00:17:00,000 --> 00:17:01,000
易用性

471
00:17:01,000 --> 00:17:02,000
那后面呢

472
00:17:02,000 --> 00:17:03,000
卷的不行了

473
00:17:03,000 --> 00:17:04,000
卷的不行了

474
00:17:04,000 --> 00:17:05,000
记得一键三连

475
00:17:05,000 --> 00:17:06,000
加关注哦

476
00:17:06,000 --> 00:17:07,000
所有的内容

477
00:17:07,000 --> 00:17:08,000
都会开源在

478
00:17:08,000 --> 00:17:10,000
下面这条链接里面

479
00:17:10,000 --> 00:17:11,000
摆了个拜

