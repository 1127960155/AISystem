1
00:00:00,000 --> 00:00:12,000
哈喽,大家好,问君能有几多愁,未到三旬又嘟头的宗米

2
00:00:12,000 --> 00:00:16,400
到通用处理器CPU这一个章节内容

3
00:00:16,400 --> 00:00:20,320
那今天呢我们回顾一下在整个AI芯片基础里面呢

4
00:00:20,320 --> 00:00:23,320
我们会从CPU到GPU再到NPU

5
00:00:23,320 --> 00:00:26,840
然后呢再到了我们的计算体系架构的黄金十年

6
00:00:26,840 --> 00:00:28,840
也就是我们的超异构体系里面

7
00:00:28,840 --> 00:00:33,000
现在我们还是在通用处理器CPU这个内容

8
00:00:33,000 --> 00:00:34,600
这个内容可能会稍微有点多

9
00:00:34,600 --> 00:00:38,680
我会分开两个视频给大家去汇报的

10
00:00:38,680 --> 00:00:41,280
首先呢在今天我要去汇报一下

11
00:00:41,280 --> 00:00:43,720
CPU的整体的发展历史和组成

12
00:00:43,720 --> 00:00:46,400
还有CPU的并行处理的架构

13
00:00:46,400 --> 00:00:50,520
那现在我们开始第一个内容就是CPU的发展历史

14
00:00:50,520 --> 00:00:52,200
还有它的组成

15
00:00:52,200 --> 00:00:54,480
从发展去看它的组成

16
00:00:55,480 --> 00:00:59,200
其实世界上的第一台真正意义的计算机呢

17
00:00:59,200 --> 00:01:01,240
是在1946年的时候

18
00:01:01,240 --> 00:01:03,760
美国宾夕法利亚大学图书区运行的

19
00:01:03,760 --> 00:01:06,000
当时候采用的还不是二进制

20
00:01:06,000 --> 00:01:08,240
而是十进制的数据进行处理

21
00:01:08,240 --> 00:01:10,480
那这台计算机呢我们叫做

22
00:01:10,480 --> 00:01:13,560
Aniac电子数字积分计算机

23
00:01:13,560 --> 00:01:17,640
不知道大家认不认识里面的这两位美女

24
00:01:17,640 --> 00:01:23,200
现在我们看看世界第一台二进制的计算器

25
00:01:23,200 --> 00:01:29,200
那这台计算机呢其实是由冯洛依曼教授去发明的

26
00:01:29,880 --> 00:01:34,640
那叫做EDVC电子离散变量的自动计算机

27
00:01:34,640 --> 00:01:37,680
这里面提到冯洛依曼就很有意思了

28
00:01:37,680 --> 00:01:39,280
通过这一台计算机呢

29
00:01:39,280 --> 00:01:42,880
冯洛依曼就提出了他经典的冯洛依曼架构

30
00:01:42,880 --> 00:01:45,520
由运算器控制器存储器还有输出

31
00:01:45,520 --> 00:01:48,360
就是我们的IO5个部分去组成

32
00:01:48,360 --> 00:01:50,680
那聊到计算机的发展历史

33
00:01:50,680 --> 00:01:52,960
就离不开计算机的组成

34
00:01:53,200 --> 00:01:54,880
直到现今为止呢

35
00:01:54,880 --> 00:01:58,280
无论CPU的经过了多少代的一个变化

36
00:01:58,280 --> 00:02:00,680
或者晶体管的数量翻了多少番

37
00:02:00,680 --> 00:02:03,520
它的整个的组成或者构成呢

38
00:02:03,520 --> 00:02:04,720
有五个部分组成

39
00:02:04,720 --> 00:02:06,120
第一个呢就是输出

40
00:02:06,120 --> 00:02:08,520
输入那这个呢我们可以避而不谈

41
00:02:08,520 --> 00:02:11,560
最重要的就是中间三部分控制单元

42
00:02:11,560 --> 00:02:14,400
计算单元ALU还有内存单元

43
00:02:14,400 --> 00:02:19,560
通过这三个部分呢来组成整个CPU的最重要的核心内容

44
00:02:19,560 --> 00:02:21,960
我们的中央控制处理器

45
00:02:22,000 --> 00:02:25,720
那现在呢像呢这里面呢其实只是一个简图

46
00:02:25,720 --> 00:02:28,080
实际上啊中央处理单元

47
00:02:28,080 --> 00:02:30,720
它的整个连线整个IO

48
00:02:30,720 --> 00:02:33,960
整个具体的控制流程是非常的复杂的

49
00:02:33,960 --> 00:02:35,600
我们接着往下看一看

50
00:02:35,600 --> 00:02:38,480
这些单元之间呢是怎么互相配合的

51
00:02:39,320 --> 00:02:41,960
在那我们叫做运算器了

52
00:02:41,960 --> 00:02:43,600
运算器呢叫做ALU

53
00:02:43,600 --> 00:02:45,640
也叫做算术逻辑单元

54
00:02:45,640 --> 00:02:48,480
主要是负责算术的运算和逻辑的运算

55
00:02:48,480 --> 00:02:51,040
什么叫做算术运算和逻辑运算呢

56
00:02:51,440 --> 00:02:55,120
简单的来说呢算术运算就是加减乘除

57
00:02:55,120 --> 00:02:59,280
逻辑运算呢就是与或非亦或这些内容

58
00:02:59,280 --> 00:03:02,280
输进去呢有可能有两个数据

59
00:03:02,280 --> 00:03:04,560
然后输出来的是一个数据

60
00:03:05,560 --> 00:03:07,800
那还穿插一些状态码

61
00:03:07,800 --> 00:03:09,920
这个就是我们的运算器了

62
00:03:09,920 --> 00:03:14,760
而整体的运算器呢也是由我们的逻辑控制门来去组成的

63
00:03:14,760 --> 00:03:16,800
接着我们看看第二个内容

64
00:03:16,800 --> 00:03:18,240
寄存器

65
00:03:18,240 --> 00:03:22,280
那寄存器其实分为指令寄存器和数据寄存器

66
00:03:22,280 --> 00:03:26,000
主要是两种负责一些赞成我们的指令呢

67
00:03:26,000 --> 00:03:28,960
我们的command呢还有ALU的一些操作了

68
00:03:28,960 --> 00:03:30,680
ALU算出来的结果呢

69
00:03:30,680 --> 00:03:34,240
那往左边呢看一下整个寄存器呢

70
00:03:34,240 --> 00:03:36,440
可以有非常多不同的寄存器

71
00:03:36,440 --> 00:03:40,080
有指令寄存器、地址寄存器、累积寄存器、编程寄存器

72
00:03:40,080 --> 00:03:42,600
而很多时候呢完全这些寄存器啊

73
00:03:42,600 --> 00:03:45,320
是由我们的控制单元去控制

74
00:03:45,320 --> 00:03:46,840
它什么时候存什么

75
00:03:46,880 --> 00:03:48,880
什么时候发生什么作用

76
00:03:48,880 --> 00:03:52,200
最后控制单元呢根据寄存器的内容

77
00:03:52,200 --> 00:03:55,320
去下发到我们的运算器ALU里面

78
00:03:55,320 --> 00:03:58,560
那往右边的这个图呢我们举两个简单的例子

79
00:03:58,560 --> 00:04:02,080
首先呢我们的数据寄存器呢我们叫做DR

80
00:04:02,080 --> 00:04:03,880
它的比特位观呢是16位

81
00:04:03,880 --> 00:04:06,080
主要是呢辅助一些临时的指令

82
00:04:06,080 --> 00:04:09,000
可以看到呢我们有非常多不同的寄存器

83
00:04:09,000 --> 00:04:11,600
不同的寄存器呢它有自己不同的作用

84
00:04:11,600 --> 00:04:13,120
也有不同的位宽

85
00:04:13,120 --> 00:04:15,760
还有自己不同的一个符号位表示

86
00:04:16,480 --> 00:04:19,160
往下看呢就是我们最重要的一个功能

87
00:04:19,160 --> 00:04:21,520
控制器负责整体的调度的工作

88
00:04:21,520 --> 00:04:25,240
包括对我们刚才的一些指令呢进行一个编码、解码

89
00:04:25,240 --> 00:04:27,480
然后从内存里面把数据读取出来

90
00:04:27,480 --> 00:04:29,000
给到我们的寄存器

91
00:04:29,000 --> 00:04:31,880
然后呢向我们的一些运算器ALU呢

92
00:04:31,880 --> 00:04:34,560
或者寄存器呢发出具体的指令操作

93
00:04:34,560 --> 00:04:36,080
那这个就是控制器

94
00:04:36,080 --> 00:04:38,280
也相当于整个CPU的大佬

95
00:04:38,280 --> 00:04:40,920
所以我们可以说呢CPU里面非常核心的一块

96
00:04:40,920 --> 00:04:43,720
就是我们的控制单元控制器

97
00:04:44,120 --> 00:04:46,800
接下来我们看一下整个CPU的工作流程

98
00:04:46,800 --> 00:04:47,920
就是它的workflow

99
00:04:47,920 --> 00:04:49,840
首先呢主要分开为四步

100
00:04:49,840 --> 00:04:52,800
我们刚才讲到了很重要的就是三个内容嘛

101
00:04:52,800 --> 00:04:55,360
控制单元、计算单元还有内存

102
00:04:55,360 --> 00:04:57,680
那第一步呢就是从内存里面

103
00:04:57,680 --> 00:05:00,520
去读取一些指令给到我们的控制单元

104
00:05:00,520 --> 00:05:03,400
控制单元呢就会进行对我们的刚才读取的

105
00:05:03,400 --> 00:05:05,160
一些指令来进行解码

106
00:05:05,160 --> 00:05:07,640
变成正式的一些command命令

107
00:05:07,640 --> 00:05:11,400
然后呢ALU就会去执行这些command这些命令

108
00:05:11,400 --> 00:05:14,760
执行完之后呢就会存储回来我们的内存

109
00:05:14,760 --> 00:05:16,640
总体来说就是这四步

110
00:05:16,640 --> 00:05:20,320
内存里面读取指令、解码、执行、写回

111
00:05:20,320 --> 00:05:22,560
就是这四个工作流程

112
00:05:22,560 --> 00:05:27,360
接下来我们以下面这个代码例子AX加B

113
00:05:27,360 --> 00:05:29,680
这么简单的一个线性操作

114
00:05:29,680 --> 00:05:33,000
看看CPU的三大组成是怎么分工的

115
00:05:33,000 --> 00:05:36,560
那现在我们可以看到其实里面的doublealova

116
00:05:36,560 --> 00:05:38,200
这个呢就是我们的存储

117
00:05:38,200 --> 00:05:40,160
doubleX也是我们的存储

118
00:05:40,200 --> 00:05:42,040
doubleY也是我们的存储

119
00:05:42,040 --> 00:05:44,080
包括n等于200

120
00:05:44,080 --> 00:05:46,280
int i等于0

121
00:05:46,280 --> 00:05:50,200
这些全都是我们的内存把数据存储起来的

122
00:05:50,200 --> 00:05:52,520
接着呢我们的器呢就会去内存里面

123
00:05:52,520 --> 00:05:55,600
把刚才这些数据呢都读取出来

124
00:05:55,600 --> 00:05:56,880
读取出来之后呢

125
00:05:56,880 --> 00:06:01,200
真正的去运行的其实只有这个x和加

126
00:06:01,200 --> 00:06:04,920
就是ALU啊真正运行的就这么两个操作

127
00:06:04,920 --> 00:06:06,880
而这里面的for循环迭代

128
00:06:06,880 --> 00:06:08,600
什么时候挨加加

129
00:06:08,600 --> 00:06:10,480
什么时候去相乘

130
00:06:10,480 --> 00:06:11,760
什么时候相加

131
00:06:11,760 --> 00:06:14,920
全都是由我们的控制器去组成的

132
00:06:14,920 --> 00:06:17,760
所以我们可以说控制器和寄存器

133
00:06:17,760 --> 00:06:19,640
复制的工作是最多的

134
00:06:19,640 --> 00:06:23,040
要存储的数据也是最多的两个部分

135
00:06:23,040 --> 00:06:25,000
因为我们刚才虽然说这些数据啊

136
00:06:25,000 --> 00:06:26,640
都是从内存里面读出来

137
00:06:26,640 --> 00:06:28,400
但实际在运行之前呢

138
00:06:28,400 --> 00:06:32,360
控制器会把这些数据呢搬到我们的寄存器里面

139
00:06:32,360 --> 00:06:34,440
然后再给ALU去执行

140
00:06:34,480 --> 00:06:36,960
这里面可以看到大量的数据交互

141
00:06:36,960 --> 00:06:38,600
大量的控制逻辑

142
00:06:38,600 --> 00:06:42,120
而真正的计算只有x和加两个

143
00:06:43,320 --> 00:06:45,400
到中央处理器这个图

144
00:06:45,400 --> 00:06:48,920
这个图呢可能稍微比刚才那个图多了一行

145
00:06:48,920 --> 00:06:52,000
寄存器就是因为我们刚才讲到了控制单元

146
00:06:52,000 --> 00:06:52,800
计算单元

147
00:06:52,800 --> 00:06:55,280
内存实际上呢我们有寄存器

148
00:06:55,280 --> 00:06:57,160
我们真正执行的时候呢

149
00:06:57,160 --> 00:07:00,080
就会把内存的数据放到寄存器

150
00:07:00,080 --> 00:07:01,320
然后控制单元呢

151
00:07:01,320 --> 00:07:03,560
控制什么时候把寄存器的数据

152
00:07:03,560 --> 00:07:06,160
给到我们的计算单元去执行

153
00:07:06,160 --> 00:07:07,120
执行完之后呢

154
00:07:07,120 --> 00:07:09,600
就把我们的计算单元的结果输出

155
00:07:09,600 --> 00:07:10,800
或者放到寄存器里面

156
00:07:10,800 --> 00:07:13,040
又或者放回我们的内存里面

157
00:07:13,040 --> 00:07:15,120
就是这么简单的一个操作

158
00:07:15,120 --> 00:07:17,920
这么简单的一个架构沿用至今

159
00:07:17,920 --> 00:07:21,400
CPU的整体架构基本上就没有太多的变化了

160
00:07:22,480 --> 00:07:25,960
接下来我们看看CPU的一个架构图

161
00:07:25,960 --> 00:07:28,080
下面就是整个CPU的架构图

162
00:07:28,080 --> 00:07:29,200
一个简图

163
00:07:29,200 --> 00:07:31,400
首先呢我们的DWAM就是内存

164
00:07:31,440 --> 00:07:33,880
内存里面呢之后我们有一级的Cache

165
00:07:33,880 --> 00:07:35,040
有二级的Cache

166
00:07:35,040 --> 00:07:37,760
这些呢其实都可以当做是我们的内存

167
00:07:37,760 --> 00:07:39,480
然后呢有控制器

168
00:07:39,480 --> 00:07:41,520
真正的执行单元就是我们的ALU

169
00:07:41,520 --> 00:07:42,720
可以看到呢

170
00:07:42,720 --> 00:07:44,200
真正执行单元的ALU

171
00:07:44,200 --> 00:07:46,400
占的面积是非常的小的

172
00:07:46,400 --> 00:07:47,800
这里面有四个ALU

173
00:07:47,800 --> 00:07:50,200
假设有四个ALU或者计算盒

174
00:07:50,200 --> 00:07:51,920
那总体电路里面呢

175
00:07:51,920 --> 00:07:54,560
占的绝大部分的就是我们的内存

176
00:07:54,560 --> 00:07:55,760
还有控制器

177
00:07:55,760 --> 00:07:57,360
而并非计算

178
00:07:57,360 --> 00:08:00,200
所以说CPU是非常适合

179
00:08:00,200 --> 00:08:02,360
擅长处理我们的逻辑控制

180
00:08:02,360 --> 00:08:03,680
而并非计算

181
00:08:03,680 --> 00:08:05,560
真正你要让计算非常好

182
00:08:05,560 --> 00:08:07,200
所以我们又有了GPU

183
00:08:07,200 --> 00:08:08,240
有了NPU

184
00:08:08,240 --> 00:08:09,400
那这些后话了

185
00:08:09,400 --> 00:08:11,840
我们后面会给大家介绍的

186
00:08:13,400 --> 00:08:16,480
那下面我们来看一下CPU的约束和限制

187
00:08:16,480 --> 00:08:18,520
实际上呢我们的计算单元呢

188
00:08:18,520 --> 00:08:20,880
也就是ALU逻辑计算单元

189
00:08:20,880 --> 00:08:24,600
它只要适用来完成整体的数据的计算

190
00:08:24,600 --> 00:08:25,960
其他的模块

191
00:08:25,960 --> 00:08:27,280
包括我们的控制器

192
00:08:27,280 --> 00:08:29,240
为的就是能够让我们的指令

193
00:08:29,240 --> 00:08:31,640
一条一条有序的去执行

194
00:08:31,640 --> 00:08:32,440
通过这种方式

195
00:08:32,440 --> 00:08:33,000
另外一方面呢

196
00:08:33,000 --> 00:08:35,720
我们还可以提高CPU的主频

197
00:08:35,720 --> 00:08:37,760
也就是提高我们单位时间类的

198
00:08:37,760 --> 00:08:39,720
执行指令的条数

199
00:08:39,720 --> 00:08:42,560
来提升整体的计算的速度

200
00:08:42,560 --> 00:08:43,240
那这个呢

201
00:08:43,240 --> 00:08:44,120
普通的CPU呢

202
00:08:44,120 --> 00:08:45,120
因为这种方式

203
00:08:45,120 --> 00:08:49,160
能够很方便的去写非常多的应用的代码

204
00:08:49,160 --> 00:08:49,840
不过下

205
00:08:49,840 --> 00:08:51,160
不过呢有一点值得注意的

206
00:08:51,160 --> 00:08:52,960
就是像冯洛依曼架构

207
00:08:52,960 --> 00:08:56,040
这种对指令的顺序执行的原则

208
00:08:56,040 --> 00:08:57,680
就保证了我们的CPU

209
00:08:57,680 --> 00:09:00,200
每一次只能执行一条指令

210
00:09:00,200 --> 00:09:00,920
它当然呢

211
00:09:00,920 --> 00:09:03,200
当然我们会存在多核的情况

212
00:09:03,200 --> 00:09:05,240
一次过可以执行多条指令

213
00:09:05,240 --> 00:09:07,120
因为原则上大原则

214
00:09:07,120 --> 00:09:08,440
受限于顺序执行

215
00:09:08,440 --> 00:09:10,480
所以我们的计算能力的提升呢

216
00:09:10,480 --> 00:09:12,080
是受到限制的

217
00:09:12,080 --> 00:09:14,520
于是我们引入了第二个内容

218
00:09:14,520 --> 00:09:15,920
也就是本节的第二章

219
00:09:15,920 --> 00:09:17,400
并行处理的架构

220
00:09:18,560 --> 00:09:20,080
那并行处理架构里面呢

221
00:09:20,080 --> 00:09:21,920
主要有4种方式

222
00:09:21,920 --> 00:09:22,560
那其实呢

223
00:09:22,560 --> 00:09:23,800
最原始的CPU呢

224
00:09:23,800 --> 00:09:24,840
就是单指令流

225
00:09:24,840 --> 00:09:27,320
单数据流这种方式

226
00:09:27,360 --> 00:09:28,360
那第二种呢

227
00:09:28,360 --> 00:09:29,760
就是SIMT

228
00:09:29,760 --> 00:09:31,200
现在来说用的最多的

229
00:09:31,200 --> 00:09:32,320
包括现代的CPU

230
00:09:32,320 --> 00:09:32,880
英特尔的

231
00:09:32,880 --> 00:09:33,800
还有AMD的CPU

232
00:09:33,800 --> 00:09:35,440
都是SIMD的架构

233
00:09:35,440 --> 00:09:38,080
也就是MISD和MIND呢

234
00:09:38,080 --> 00:09:39,240
反倒用的比较少

235
00:09:39,240 --> 00:09:41,120
我们下面来看看具体的例子

236
00:09:41,120 --> 00:09:42,560
它们有哪些不一样

237
00:09:42,560 --> 00:09:43,280
那第一个呢

238
00:09:43,280 --> 00:09:43,600
其实

239
00:09:44,240 --> 00:09:45,800
下面我们来到第一个内容

240
00:09:45,800 --> 00:09:46,480
SISD

241
00:09:46,480 --> 00:09:48,480
Single Instruction Single Data

242
00:09:48,480 --> 00:09:49,280
我们的PU

243
00:09:49,280 --> 00:09:50,520
就是Poset Unit

244
00:09:50,520 --> 00:09:51,600
我们的执行单元

245
00:09:51,600 --> 00:09:52,360
每一次呢

246
00:09:52,360 --> 00:09:53,680
从我们的指令流里面

247
00:09:53,680 --> 00:09:55,160
单独读取一条指令

248
00:09:55,160 --> 00:09:56,880
然后从我们的数据流里面呢

249
00:09:56,920 --> 00:09:58,080
单独取一条数据

250
00:09:58,080 --> 00:09:59,400
然后进行计算

251
00:09:59,400 --> 00:10:00,240
最后输出

252
00:10:00,240 --> 00:10:01,120
那这种方式呢

253
00:10:01,120 --> 00:10:02,600
是串行的去执行的

254
00:10:02,600 --> 00:10:03,080
硬件呢

255
00:10:03,080 --> 00:10:04,920
是不支持并行的方式

256
00:10:04,920 --> 00:10:06,760
而且在每个时钟周期内呢

257
00:10:06,760 --> 00:10:09,280
CPU只能够处理一个数据流

258
00:10:09,280 --> 00:10:10,680
举的最简单的例子

259
00:10:10,680 --> 00:10:11,560
就是我的指令

260
00:10:11,560 --> 00:10:13,200
做一个加法的操作

261
00:10:13,200 --> 00:10:13,720
于是呢

262
00:10:13,720 --> 00:10:15,520
我就会在数据流里面

263
00:10:15,520 --> 00:10:17,840
读取两个数据A和B

264
00:10:17,840 --> 00:10:19,440
然后执行一个加法的操作

265
00:10:19,440 --> 00:10:20,920
最后输出一个C

266
00:10:20,920 --> 00:10:21,720
这么简单的

267
00:10:21,720 --> 00:10:23,960
就是我们的SISD

268
00:10:23,960 --> 00:10:25,200
接下来我们看一下

269
00:10:25,200 --> 00:10:27,840
第二个并行的硬件处理的架构

270
00:10:27,840 --> 00:10:29,800
SIMD就有点意思了

271
00:10:29,800 --> 00:10:33,000
就是Single Instruction Multi Data

272
00:10:33,000 --> 00:10:34,640
我们的指令流呢

273
00:10:34,640 --> 00:10:35,680
只有一个指令

274
00:10:35,680 --> 00:10:36,600
但是数据呢

275
00:10:36,600 --> 00:10:37,800
可以有多个数据

276
00:10:37,800 --> 00:10:40,160
那从这个图我们可以看到

277
00:10:40,160 --> 00:10:41,880
首先我们读取一条指令

278
00:10:41,880 --> 00:10:45,000
这条指令假设都是加法操作

279
00:10:45,000 --> 00:10:46,160
那我们可以里面呢

280
00:10:46,160 --> 00:10:47,760
读取不同的数据出来

281
00:10:47,760 --> 00:10:49,880
最后获取计算并行的去计算

282
00:10:49,880 --> 00:10:52,400
可以看到从左边A1 A2 A3

283
00:10:52,400 --> 00:10:54,080
同时进行一个加法的操作

284
00:10:54,080 --> 00:10:55,320
B B2 B3

285
00:10:55,320 --> 00:10:57,480
所以我们叫做单指令流

286
00:10:57,480 --> 00:10:59,600
多数据的这种方式

287
00:10:59,600 --> 00:11:00,640
加法只有一个

288
00:11:00,640 --> 00:11:02,600
但是数据呢有很多个

289
00:11:02,600 --> 00:11:03,560
这种的特点呢

290
00:11:03,560 --> 00:11:05,560
就是我们的处理单元非常多

291
00:11:05,560 --> 00:11:07,440
可以看到PU呢非常多

292
00:11:07,440 --> 00:11:09,600
但是处理的就是处理的速度

293
00:11:09,600 --> 00:11:12,480
那会受到我们的计算的通讯的带宽

294
00:11:12,480 --> 00:11:15,480
还有通讯的延时等限制

295
00:11:15,480 --> 00:11:16,880
可以看到最大的限制

296
00:11:16,880 --> 00:11:19,400
就是我们的数据的读取的方式

297
00:11:19,400 --> 00:11:21,280
指令的读取方式是很快的

298
00:11:21,280 --> 00:11:23,640
我们从计存器里面去读取指令

299
00:11:23,800 --> 00:11:25,680
数据呢就特别的慢了

300
00:11:26,400 --> 00:11:28,200
接着呢我们看一下

301
00:11:28,200 --> 00:11:30,080
第三个并行处理架构

302
00:11:30,080 --> 00:11:34,400
就是MISD Multic Instruction and Single Data

303
00:11:34,400 --> 00:11:35,600
这里面呢多指令流

304
00:11:35,600 --> 00:11:37,200
单数据呢就很有意思

305
00:11:37,200 --> 00:11:39,440
指令流是分开多个的

306
00:11:39,440 --> 00:11:43,280
但是呢数据我们只有比较简单的一种

307
00:11:43,280 --> 00:11:45,080
那下面我们可以看到从左边的

308
00:11:45,080 --> 00:11:47,120
这个就是加减层

309
00:11:47,120 --> 00:11:49,440
我们都有不同的计算的指令

310
00:11:49,440 --> 00:11:51,840
但是呢输入的数据呢只有一种

311
00:11:51,840 --> 00:11:53,480
最后呢输出数据

312
00:11:53,480 --> 00:11:55,240
这种呢其实我们可以看到

313
00:11:55,240 --> 00:11:56,560
像这种奇奇怪怪的计算

314
00:11:56,560 --> 00:11:59,760
其实我至少总比来看呢很少能够见到

315
00:11:59,760 --> 00:12:01,360
所以作为一种理论的模型

316
00:12:01,360 --> 00:12:04,360
并没有在实际应用当中去投产的

317
00:12:04,360 --> 00:12:06,600
所以我们看到的类随这种架构的芯片呢

318
00:12:06,600 --> 00:12:08,480
是非常非常的少

319
00:12:08,480 --> 00:12:10,880
那最后一个就是MIMD了

320
00:12:10,880 --> 00:12:13,360
Multic Instruction Multic Data

321
00:12:13,360 --> 00:12:17,120
在多个数据集上面呢去执行多个指令流

322
00:12:17,120 --> 00:12:19,720
这种呢我们又分为共享内存MIMD

323
00:12:19,720 --> 00:12:21,440
和分布式内存

324
00:12:21,480 --> 00:12:23,480
就分开两种MIMD

325
00:12:23,480 --> 00:12:24,760
一种是共享内存

326
00:12:24,760 --> 00:12:26,560
一种是分布式内存

327
00:12:26,560 --> 00:12:29,120
那我们现在先看看共享内存主要是指

328
00:12:29,120 --> 00:12:32,520
我们在整个CPU或者在整个芯片系列里面呢

329
00:12:32,520 --> 00:12:35,120
共享所有的全局的内存

330
00:12:35,120 --> 00:12:39,400
而分布式呢就是夸机器进行内存的共享

331
00:12:39,400 --> 00:12:40,240
那内存共享呢

332
00:12:40,240 --> 00:12:43,120
那我们又可以通过进程间进行通讯

333
00:12:43,120 --> 00:12:43,920
各种方式

334
00:12:43,920 --> 00:12:47,320
但是呢这种说实话用的也是比较少的

335
00:12:47,320 --> 00:12:50,880
另外我们用的更多的是我们的SIMT

336
00:12:50,880 --> 00:12:55,200
像GPU呢就是我们的SIMD的另外一种眼镜

337
00:12:55,200 --> 00:12:57,040
变成SIMT

338
00:12:57,040 --> 00:12:59,560
把data变成我们的flat

339
00:12:59,560 --> 00:13:01,200
变成我们的线程

340
00:13:01,200 --> 00:13:02,840
单指令多线程

341
00:13:02,840 --> 00:13:05,400
从GPU的这个呢就是GPU的基本架构

342
00:13:05,400 --> 00:13:07,280
它可以有效的管理和执行

343
00:13:07,280 --> 00:13:10,160
非常非常多的线程

344
00:13:10,160 --> 00:13:13,480
SP呢就是其中的一个线程执行器

345
00:13:14,560 --> 00:13:18,480
就允许一条指令呢多个数据分开寻子

346
00:13:18,480 --> 00:13:19,640
这个时候我们开发

347
00:13:19,760 --> 00:13:21,760
好了今天的内容呢就这么多了

348
00:13:21,760 --> 00:13:23,800
有点水我们简单的回顾了一下

349
00:13:23,800 --> 00:13:25,640
CPU的发展历史它的组成

350
00:13:25,640 --> 00:13:28,280
另外我们还看了CPU的并行的架构

351
00:13:28,280 --> 00:13:32,280
从SISD到SIMD到SIMT

352
00:13:32,280 --> 00:13:33,960
它的一个发展的脉络

353
00:13:33,960 --> 00:13:35,400
在接下来的内容我们看看

354
00:13:35,400 --> 00:13:37,120
ISA指令集的架构

355
00:13:37,120 --> 00:13:38,680
还有CPU的应用场景

356
00:13:38,680 --> 00:13:39,760
今天内容到这里为止

357
00:13:39,760 --> 00:13:40,520
谢谢各位

358
00:13:40,520 --> 00:13:41,720
拜了个拜

359
00:13:42,840 --> 00:13:44,520
卷的不行了卷的不行了

360
00:13:44,520 --> 00:13:46,320
记得一键三连加关注哦

361
00:13:46,320 --> 00:13:49,600
所有的内容都会开源在下面这条链接里面

362
00:13:49,600 --> 00:13:51,080
拜了个拜

