1
00:00:00,000 --> 00:00:06,280
Hello大家好

2
00:00:06,280 --> 00:00:08,520
我是一周工作猛如虎

3
00:00:08,520 --> 00:00:12,120
劳道数理只有250的周米

4
00:00:12,120 --> 00:00:13,920
那一周确实只有250

5
00:00:13,920 --> 00:00:14,880
低的可怜

6
00:00:14,880 --> 00:00:16,320
职场上卷的不行了

7
00:00:16,320 --> 00:00:19,400
我们今天还是在AI芯片的AI芯片

8
00:00:19,400 --> 00:00:21,640
整体的基础看一看CPU

9
00:00:21,640 --> 00:00:23,840
我们的通用处理器

10
00:00:23,840 --> 00:00:25,480
那实际上在通用处理器

11
00:00:25,480 --> 00:00:28,160
我们上一节已经讲了CPU的发展和组成

12
00:00:28,200 --> 00:00:30,240
从而引出了我们CPU的整体的

13
00:00:30,240 --> 00:00:31,520
并行的处理架构

14
00:00:31,520 --> 00:00:33,600
今天我们要主要去聚焦一下

15
00:00:33,600 --> 00:00:35,080
ISA指令集架构

16
00:00:35,080 --> 00:00:36,800
来去看一看什么是

17
00:00:36,800 --> 00:00:37,960
ISA

18
00:00:37,960 --> 00:00:39,080
令集架构

19
00:00:39,080 --> 00:00:42,280
那ISA对于我们整个CPUGPU

20
00:00:42,280 --> 00:00:45,160
包括到后面的AI芯片

21
00:00:45,160 --> 00:00:47,160
它都是非常的重要

22
00:00:47,160 --> 00:00:48,480
最后的内容

23
00:00:48,480 --> 00:00:51,000
我们来回顾一下CPU的应用场景

24
00:00:51,000 --> 00:00:52,800
那现在我们进入到第一个内容

25
00:00:52,800 --> 00:00:55,160
ISA指令集架构

26
00:00:56,160 --> 00:00:58,720
所谓的ISA其实叫做

27
00:00:58,720 --> 00:01:00,720
Instruction Set Architecture

28
00:01:00,720 --> 00:01:03,360
也就是指令集的架构

29
00:01:03,360 --> 00:01:04,440
那CPU的全称

30
00:01:04,440 --> 00:01:06,360
其实叫做中央处理器

31
00:01:06,360 --> 00:01:08,720
CPU Center Process Unit

32
00:01:08,720 --> 00:01:09,440
通常来说

33
00:01:09,440 --> 00:01:11,240
我们区别CPU的标准

34
00:01:11,240 --> 00:01:13,320
是指令集的架构

35
00:01:13,320 --> 00:01:14,720
也就是通过指令架构

36
00:01:14,720 --> 00:01:17,560
去区分我们的CPU的一个标准

37
00:01:17,560 --> 00:01:18,800
到底是属于ARM的

38
00:01:18,800 --> 00:01:21,320
还是属于X86的这种不同的体系

39
00:01:21,320 --> 00:01:22,600
当然了指令集架构

40
00:01:22,600 --> 00:01:24,520
包括我们后面的GPU NPU

41
00:01:24,520 --> 00:01:27,160
还有现在的AI芯片

42
00:01:27,160 --> 00:01:29,800
都是通过指令集架构去区分的

43
00:01:29,800 --> 00:01:32,480
所以芯片的开发人员

44
00:01:32,480 --> 00:01:34,240
会基于我们的指令集架构

45
00:01:34,240 --> 00:01:35,640
也就是所谓的ISA

46
00:01:35,640 --> 00:01:37,960
通过不同的处理器硬件的方案

47
00:01:37,960 --> 00:01:38,960
来去实现的

48
00:01:38,960 --> 00:01:40,000
通过这种ISA

49
00:01:40,000 --> 00:01:41,720
去设计我们的处理器

50
00:01:41,720 --> 00:01:45,160
因此我们说ISA是作为CPU的灵魂

51
00:01:45,160 --> 00:01:47,400
下面这个图就有点意思

52
00:01:47,400 --> 00:01:50,200
是我们把其中一个ISA拿出来

53
00:01:50,200 --> 00:01:51,760
其中一个指令拿出来

54
00:01:51,760 --> 00:01:52,880
那指令集

55
00:01:52,920 --> 00:01:54,600
它有很多的指令

56
00:01:54,600 --> 00:01:57,760
MIPS32它是其中一个

57
00:01:57,760 --> 00:01:59,320
加法的指令

58
00:01:59,320 --> 00:02:01,800
那现在我们以加法的这个指令

59
00:02:01,800 --> 00:02:02,960
具体打开看看

60
00:02:02,960 --> 00:02:05,560
指令集架构里面的其中一条

61
00:02:06,960 --> 00:02:10,480
MIPS32它是一个加法的指令

62
00:02:10,480 --> 00:02:13,040
那刚才讲的指令集是一个集合

63
00:02:13,040 --> 00:02:14,200
我们现在指令集里面

64
00:02:14,200 --> 00:02:16,160
有非常多的不同的指令

65
00:02:16,160 --> 00:02:17,480
而具体的一个指令

66
00:02:17,720 --> 00:02:19,560
是由两个部分来组成的

67
00:02:19,560 --> 00:02:20,480
首先第一个部分的

68
00:02:20,480 --> 00:02:22,040
第一个就是我们的运算幅

69
00:02:22,040 --> 00:02:23,000
告诉我们现在

70
00:02:23,000 --> 00:02:24,360
到底它的opcode是什么

71
00:02:24,360 --> 00:02:26,120
我们需要进行什么操作

72
00:02:26,120 --> 00:02:27,920
那这里面是以加为例子

73
00:02:27,920 --> 00:02:29,840
所以这里面真正的指令

74
00:02:29,840 --> 00:02:31,400
它这是一个加法

75
00:02:31,400 --> 00:02:34,080
右边的这个就是操作数

76
00:02:34,080 --> 00:02:35,600
需要操作的对象

77
00:02:35,600 --> 00:02:36,680
包括我们的

78
00:02:37,160 --> 00:02:39,400
它的参数有三个

79
00:02:39,400 --> 00:02:42,240
R1是我们的目的操作数

80
00:02:42,240 --> 00:02:44,520
R2是我们的原操作数

81
00:02:44,520 --> 00:02:45,720
第三个immediate value

82
00:02:45,720 --> 00:02:46,880
是我们的立即数

83
00:02:46,880 --> 00:02:49,480
就是把立即数跟原操作数相加

84
00:02:49,480 --> 00:02:51,760
结果存到我们的目的操作数

85
00:02:51,760 --> 00:02:54,000
简单的来说就是immediate value

86
00:02:54,000 --> 00:02:54,720
加上R2

87
00:02:54,720 --> 00:02:57,680
把得到的结果存回我们的R1

88
00:02:58,120 --> 00:03:00,120
加法的指令集了

89
00:03:01,960 --> 00:03:03,080
指令作为例子

90
00:03:03,080 --> 00:03:03,560
讲完之后

91
00:03:03,640 --> 00:03:05,200
我们看看指令集

92
00:03:05,400 --> 00:03:07,040
其实它有主要的分类

93
00:03:07,040 --> 00:03:07,720
有三个

94
00:03:07,720 --> 00:03:09,400
第一个就是运算的指令

95
00:03:09,400 --> 00:03:10,680
那我们刚才讲到的加法

96
00:03:10,800 --> 00:03:12,160
就是我们的运算指令

97
00:03:12,160 --> 00:03:13,120
在AOU当中

98
00:03:13,280 --> 00:03:15,560
去执行具体的计算操作

99
00:03:15,560 --> 00:03:18,400
第二种就是数据搬运的一些指令

100
00:03:18,400 --> 00:03:19,800
我们叫数据移动指令了

101
00:03:19,880 --> 00:03:23,360
当然它包括大部分的数据的读写IO

102
00:03:23,360 --> 00:03:24,560
那主要是指这些

103
00:03:24,560 --> 00:03:26,160
第三个对于CPU来说

104
00:03:26,160 --> 00:03:28,080
是非常重要的控制指令

105
00:03:28,080 --> 00:03:29,640
就是我们的执行序列

106
00:03:29,640 --> 00:03:31,040
什么时候进行跳转

107
00:03:31,040 --> 00:03:32,800
什么时候if else while for

108
00:03:32,800 --> 00:03:35,040
这些都属于我们的控制指令

109
00:03:35,040 --> 00:03:36,800
而在这里面剧透一下

110
00:03:36,800 --> 00:03:39,000
我们的AI芯片里面

111
00:03:39,320 --> 00:03:40,080
很重要的

112
00:03:40,080 --> 00:03:42,600
就是会写自己的一些运算的指令

113
00:03:42,600 --> 00:03:43,680
包括谷歌的TPU

114
00:03:43,960 --> 00:03:45,200
还有华为生铜的NPU

115
00:03:45,440 --> 00:03:47,920
都会有自己独特的运算指令

116
00:03:47,960 --> 00:03:50,200
这就是对应我们Q核里面

117
00:03:50,200 --> 00:03:51,880
会做的一些特殊的操作

118
00:03:52,440 --> 00:03:55,200
接下来我们看一下整体的ISA

119
00:03:55,760 --> 00:03:56,800
我们的指令集架构

120
00:03:56,960 --> 00:03:58,840
它是有一个生命周期的

121
00:03:59,000 --> 00:03:59,840
这个字打错了

122
00:03:59,840 --> 00:04:00,640
不是生命周期

123
00:04:00,760 --> 00:04:01,680
生命周期

124
00:04:01,680 --> 00:04:02,400
整体来说

125
00:04:02,400 --> 00:04:03,880
它有6个生命周期

126
00:04:03,880 --> 00:04:04,320
当然了

127
00:04:04,320 --> 00:04:07,120
不是所有的指令都会循环这个周期

128
00:04:07,120 --> 00:04:08,000
但是这个周期

129
00:04:08,120 --> 00:04:09,640
基本上大原则来说

130
00:04:09,640 --> 00:04:10,840
是不会变化的

131
00:04:11,920 --> 00:04:13,640
接下来我们看第二个内容

132
00:04:13,640 --> 00:04:16,280
就是更宏观的去看看指令集架构了

133
00:04:16,280 --> 00:04:17,720
我们可以看到指令集架构

134
00:04:17,880 --> 00:04:19,640
主要我们可以理解为

135
00:04:19,640 --> 00:04:21,560
它是一个抽象的层

136
00:04:21,560 --> 00:04:22,760
属于处理器

137
00:04:22,760 --> 00:04:24,120
底层是我们的硬件

138
00:04:24,120 --> 00:04:27,800
上层是我们的软件连接的一个桥梁

139
00:04:28,240 --> 00:04:28,800
指令架构

140
00:04:28,800 --> 00:04:29,640
我们刚才讲到了

141
00:04:29,640 --> 00:04:30,400
有计算的指令

142
00:04:30,400 --> 00:04:31,280
数据寻指的指令

143
00:04:31,280 --> 00:04:33,400
还有我们的控制的指令

144
00:04:33,400 --> 00:04:34,120
通过这些

145
00:04:34,280 --> 00:04:36,360
我们去连接好我们的硬件

146
00:04:36,360 --> 00:04:38,280
那硬件可能就会有一些微架构

147
00:04:38,440 --> 00:04:39,960
还有一些IC的电路

148
00:04:39,960 --> 00:04:41,320
还有我们的逻辑门

149
00:04:41,320 --> 00:04:43,920
对上了就对到我们的机器码了

150
00:04:43,920 --> 00:04:46,200
指令集架构对应的是我们的机器码

151
00:04:46,360 --> 00:04:47,960
对应到机器码之上了

152
00:04:47,960 --> 00:04:49,240
才是我们的编译器

153
00:04:49,240 --> 00:04:51,600
还有我们的一些symbol的语言

154
00:04:51,600 --> 00:04:53,160
包括我们的编程语言

155
00:04:53,160 --> 00:04:54,400
在网上编译器网上

156
00:04:54,400 --> 00:04:55,360
就是我们的编程语言

157
00:04:55,800 --> 00:04:57,360
再上去就是操作系统

158
00:04:57,360 --> 00:04:58,160
还有我们的算法

159
00:04:58,160 --> 00:04:59,200
还有我们的应用了

160
00:04:59,200 --> 00:05:01,600
它是这么一个具体的组成方式的

161
00:05:01,600 --> 00:05:03,560
所以欢迎大家去我的Github上面

162
00:05:03,560 --> 00:05:05,400
去取这些内容来看看

163
00:05:05,400 --> 00:05:06,320
去打开这些图

164
00:05:06,320 --> 00:05:08,120
这些图都是每一张都自己画的

165
00:05:08,440 --> 00:05:08,920
接下来

166
00:05:09,480 --> 00:05:10,080
不装了

167
00:05:11,400 --> 00:05:13,520
我十七万富翁我摊牌了

168
00:05:14,400 --> 00:05:15,760
SA的一个宏观的概念

169
00:05:15,760 --> 00:05:17,040
我们有几个问题

170
00:05:17,360 --> 00:05:18,760
这里面看一下大家懂不懂

171
00:05:18,760 --> 00:05:21,040
或者我们一起去探讨和思考的

172
00:05:21,040 --> 00:05:23,360
首先就是计算机的架构里面

173
00:05:23,360 --> 00:05:25,360
有多少个集存器

174
00:05:25,360 --> 00:05:26,280
多少个register

175
00:05:26,600 --> 00:05:29,000
才能够去存放我们各种各样的指令

176
00:05:29,600 --> 00:05:32,000
接着我们现在能够进行的

177
00:05:32,000 --> 00:05:33,920
有哪些运算的操作

178
00:05:33,920 --> 00:05:35,360
就是有哪些具体的指令

179
00:05:35,360 --> 00:05:37,720
包括加减乘除这些我都知道

180
00:05:37,720 --> 00:05:39,000
但是具体有哪些

181
00:05:39,320 --> 00:05:41,360
复杂指令集跟简单指令集之间

182
00:05:41,360 --> 00:05:42,120
又有什么区别

183
00:05:42,920 --> 00:05:43,600
第三个问题

184
00:05:43,640 --> 00:05:46,320
就是如果遇到异常或者中断的时候

185
00:05:46,320 --> 00:05:47,320
我们应该怎么办

186
00:05:47,800 --> 00:05:48,840
就刚才指令集

187
00:05:48,840 --> 00:05:50,320
它是有自己的生命周期的

188
00:05:50,800 --> 00:05:52,680
中间整个生命周期被打断了

189
00:05:53,120 --> 00:05:53,800
怎么去执行

190
00:05:54,640 --> 00:05:57,280
第4个问题就是数据类型有很多

191
00:05:57,680 --> 00:05:59,520
但数据类型具体有几个字节

192
00:06:00,360 --> 00:06:01,440
具体我们应该怎么存

193
00:06:01,880 --> 00:06:03,080
对应我们的指令集架构

194
00:06:03,080 --> 00:06:04,040
又有什么不一样

195
00:06:04,760 --> 00:06:05,720
我们指令集

196
00:06:06,040 --> 00:06:07,640
我们的指令会有长度的

197
00:06:08,440 --> 00:06:09,720
我们的数据类型不一样

198
00:06:09,720 --> 00:06:11,120
那我们指令是不是长度不一样

199
00:06:11,560 --> 00:06:13,480
假设我有一个int的加法

200
00:06:13,760 --> 00:06:14,960
跟我们的fruit的加法

201
00:06:15,640 --> 00:06:16,520
指令是两个吗

202
00:06:16,520 --> 00:06:17,160
还是一个

203
00:06:18,000 --> 00:06:19,440
这些问题都非常有意思

204
00:06:19,440 --> 00:06:21,800
非常欢迎大家去弹幕留言

205
00:06:21,800 --> 00:06:23,200
或者去深入的思考

206
00:06:24,120 --> 00:06:26,200
接下来我们看一下下一个内容

207
00:06:26,200 --> 00:06:27,360
就是sisca的架构

208
00:06:27,360 --> 00:06:28,400
还有visca的架构

209
00:06:28,920 --> 00:06:32,360
sisca的架构就是我们的复杂指令集

210
00:06:32,600 --> 00:06:36,000
visca的架构就是我们的简单的指令集

211
00:06:36,960 --> 00:06:38,440
它是一个复杂指令集

212
00:06:38,600 --> 00:06:39,600
除了常用的指令

213
00:06:39,600 --> 00:06:42,360
我们还有包括非常多不常用的指令

214
00:06:42,520 --> 00:06:44,880
可能常用的指令只占到20%

215
00:06:45,200 --> 00:06:47,480
80%的指令都是不常用的

216
00:06:47,760 --> 00:06:48,760
但没关系

217
00:06:48,760 --> 00:06:51,280
我们的CPU的面积可以做得很大

218
00:06:51,280 --> 00:06:54,200
我们的晶体管也可以设计的非常的多

219
00:06:54,200 --> 00:06:55,840
放在我们的笔记本上面

220
00:06:56,000 --> 00:06:58,560
其实还是有很多用于的地方

221
00:06:58,560 --> 00:07:00,640
所以我们就很多不常用的指令

222
00:07:00,640 --> 00:07:01,560
只要用到的时候

223
00:07:01,560 --> 00:07:03,640
直接把指令调起来就可以用了

224
00:07:03,640 --> 00:07:05,960
这里面我们可以看到sisca的架构的

225
00:07:05,960 --> 00:07:07,720
它占是非常的深的

226
00:07:07,720 --> 00:07:09,840
下面我们给你们看看visca架构

227
00:07:09,840 --> 00:07:13,120
visca架构主要只有一些常用的指令

228
00:07:13,120 --> 00:07:14,640
不常用指令它没有

229
00:07:14,640 --> 00:07:18,040
它是用通过一些常用的指令去做拼接的

230
00:07:18,040 --> 00:07:20,080
当然适宜到拼接

231
00:07:20,080 --> 00:07:22,320
它就会衍生了可能会更慢

232
00:07:22,320 --> 00:07:24,440
本来我在CPU上面

233
00:07:24,440 --> 00:07:25,840
在我们的sisca架构上面

234
00:07:26,160 --> 00:07:28,040
执行一条不常用的指令

235
00:07:28,040 --> 00:07:30,560
可能在visca上面要执行五六条

236
00:07:30,560 --> 00:07:31,880
才能够拼起来

237
00:07:31,880 --> 00:07:34,600
可能有现在我们举一个具体的例子

238
00:07:34,600 --> 00:07:35,880
一个矩阵层

239
00:07:35,880 --> 00:07:37,640
可能在我们的sisca里面

240
00:07:37,800 --> 00:07:39,480
我们有矩阵层这个指令

241
00:07:39,560 --> 00:07:41,520
但是visca里面我们没有矩阵层

242
00:07:41,520 --> 00:07:44,120
我们只有单个数据的相乘

243
00:07:44,120 --> 00:07:45,680
单个scala的相乘

244
00:07:45,680 --> 00:07:47,920
这个时候如果我们要实现这个操作

245
00:07:47,920 --> 00:07:50,600
可能就要有大量的visca的这种指令

246
00:07:50,600 --> 00:07:54,280
去组合成为一条一个复杂的矩阵层了

247
00:07:54,280 --> 00:07:57,360
下面我们具体的打开一下sisca架构

248
00:07:57,360 --> 00:07:59,680
和visca架构具体的不一样

249
00:07:59,680 --> 00:08:02,360
现在我们先看一下sisca的架构

250
00:08:03,200 --> 00:08:04,000
sisca的架构

251
00:08:04,160 --> 00:08:07,800
因为引入了非常多平时很少用的指令

252
00:08:07,800 --> 00:08:10,240
所以我们会导致整个CPU的设计

253
00:08:10,240 --> 00:08:11,680
包括我们的电路设计

254
00:08:11,680 --> 00:08:12,280
芯片设计

255
00:08:12,280 --> 00:08:13,240
还有软件站的设计

256
00:08:13,240 --> 00:08:15,040
都会变得非常的复杂

257
00:08:15,040 --> 00:08:18,320
整体增加我们整个硬件的成本

258
00:08:18,520 --> 00:08:19,200
除了硬件

259
00:08:19,200 --> 00:08:20,760
还有软件的成本的设计

260
00:08:20,760 --> 00:08:23,120
当然了硬件数影响是非常的大的

261
00:08:23,120 --> 00:08:24,720
整体会增加我们的时间

262
00:08:24,720 --> 00:08:25,520
研发的成本

263
00:08:25,520 --> 00:08:28,280
还有芯片面积的开销

264
00:08:28,840 --> 00:08:30,120
而像visca架构

265
00:08:30,280 --> 00:08:32,640
它只包含一些常用的指令

266
00:08:32,640 --> 00:08:35,200
所以我们经常会在手机端

267
00:08:35,320 --> 00:08:36,920
我们看到手机里面这么小

268
00:08:36,920 --> 00:08:37,840
塞一个电源

269
00:08:37,840 --> 00:08:40,480
我们的CPU其实是非常非常的小

270
00:08:40,480 --> 00:08:43,760
所以非常适合移动端的设备去使用的

271
00:08:43,760 --> 00:08:45,200
当然了我们的移动端的设备

272
00:08:45,480 --> 00:08:47,880
没办法去做很多复杂的工作

273
00:08:47,880 --> 00:08:49,400
当然对于我们的应用来说

274
00:08:49,600 --> 00:08:51,440
其实已经完全够用了

275
00:08:52,880 --> 00:08:56,680
我们总结了一下sisca跟visca的一个具体的区别

276
00:08:56,680 --> 00:08:58,720
我觉得中品觉得最大的区别

277
00:08:58,720 --> 00:09:00,280
就是指令的数量

278
00:09:00,280 --> 00:09:01,280
指令的数量

279
00:09:01,280 --> 00:09:04,800
决定了我们的不同的架构之间的区别

280
00:09:04,920 --> 00:09:07,560
第2个就是指令的长度

281
00:09:07,560 --> 00:09:09,120
sisca是不固定长的

282
00:09:09,120 --> 00:09:11,400
而visca为了做的更加简单方便

283
00:09:11,400 --> 00:09:14,400
而且非常有明确的约束规范

284
00:09:14,400 --> 00:09:16,360
所以它会是一个定长的

285
00:09:16,360 --> 00:09:18,360
而且可仿存的指令

286
00:09:19,080 --> 00:09:20,680
sisca是不加限制的

287
00:09:20,680 --> 00:09:22,640
有非常多各种的仿存指令

288
00:09:22,640 --> 00:09:25,040
而在visca里面只有load和store

289
00:09:25,040 --> 00:09:27,240
而这里面提到仿存指令

290
00:09:27,920 --> 00:09:29,200
就提到我们的AI芯片

291
00:09:29,520 --> 00:09:31,200
AI芯片的仿存的方式

292
00:09:31,360 --> 00:09:33,720
是跟我们的CPU跟我们的GPU不一样的

293
00:09:33,840 --> 00:09:37,440
所以AI芯片用的是一个sisca的架构

294
00:09:37,440 --> 00:09:38,600
这里面要澄清一点

295
00:09:38,600 --> 00:09:40,280
就是指令级架构

296
00:09:40,280 --> 00:09:42,040
虽然是从CPU衍生过来

297
00:09:42,040 --> 00:09:43,880
但是我们可以反推过去

298
00:09:43,880 --> 00:09:46,120
它不一定只代表sisca

299
00:09:46,120 --> 00:09:48,880
就是针对我们的CPU才能够设计的

300
00:09:48,880 --> 00:09:50,440
我们可能AI芯片里面

301
00:09:50,440 --> 00:09:52,200
也可以用到sisca的架构

302
00:09:52,200 --> 00:09:55,920
AI芯片里面也或许会用到visca的架构

303
00:09:55,920 --> 00:09:58,120
具体去我们后面讲AI芯片的时候

304
00:09:58,120 --> 00:09:59,960
还会深入的去打开

305
00:10:01,480 --> 00:10:03,240
这就是ISA的种类了

306
00:10:03,240 --> 00:10:04,160
我们刚才说到

307
00:10:04,160 --> 00:10:08,040
因为CPU的发展衍生了非常多不同的架构

308
00:10:08,040 --> 00:10:09,000
而整体CPU

309
00:10:09,200 --> 00:10:12,600
实际上是在1960年开始正式的问世

310
00:10:12,600 --> 00:10:15,360
我们之前讲到第一台大型的CPU

311
00:10:16,080 --> 00:10:17,280
那种是大型的CPU

312
00:10:17,280 --> 00:10:19,440
现在讲到的是微型的CPU

313
00:10:19,440 --> 00:10:21,840
这些都是在60年代问世的

314
00:10:21,840 --> 00:10:24,320
已经发展了五六十年了

315
00:10:24,320 --> 00:10:25,800
而这五六十年代里面

316
00:10:25,960 --> 00:10:27,080
我们出现了

317
00:10:27,080 --> 00:10:30,280
就消亡了非常多不同的架构

318
00:10:30,280 --> 00:10:33,200
现在用的最多的是我们的x86的指令架构

319
00:10:33,400 --> 00:10:36,280
英特尔AMD都是使用我们的x86

320
00:10:36,280 --> 00:10:39,360
我们现在买机器买服务器都是用x86

321
00:10:39,360 --> 00:10:42,840
而现在ARM用的非常的多

322
00:10:42,840 --> 00:10:43,680
无处不在了

323
00:10:43,680 --> 00:10:44,880
我现在的手机

324
00:10:44,880 --> 00:10:46,360
包括现在的千万事事倍

325
00:10:46,360 --> 00:10:48,240
都是用ARM的指令架构的

326
00:10:48,240 --> 00:10:50,360
而后面应该是最近

327
00:10:50,360 --> 00:10:53,920
又有了visca-v这种开放式指令

328
00:10:53,920 --> 00:10:55,320
当然了这种开放式指令

329
00:10:55,480 --> 00:10:58,640
现在来说开始慢慢的涌现的越来越多了

330
00:10:58,640 --> 00:11:00,240
因为ARM它是收费的

331
00:11:00,240 --> 00:11:01,360
x86也是收费的

332
00:11:01,480 --> 00:11:03,960
而且x86还是真不完全对外公开

333
00:11:03,960 --> 00:11:05,920
而ARM是公开授权的

334
00:11:05,920 --> 00:11:08,200
而visca-v现在越来越多人的参与

335
00:11:08,200 --> 00:11:09,840
是因为它是完全开放的

336
00:11:09,840 --> 00:11:11,120
所以我们可以继续visca-v

337
00:11:11,200 --> 00:11:14,880
做更多各种各样的新的芯片的设计

338
00:11:15,320 --> 00:11:16,920
最后还有一些已经消亡

339
00:11:16,920 --> 00:11:19,520
或者已经用的越来越少的一些指令架构了

340
00:11:19,520 --> 00:11:21,240
我们就不一一介绍了

341
00:11:21,880 --> 00:11:25,000
接下来我们看看整体的CPU的应用场景

342
00:11:25,000 --> 00:11:26,480
这个就相当于废话了

343
00:11:26,480 --> 00:11:28,400
大家简单的了解一下就好了

344
00:11:28,400 --> 00:11:30,120
我们现在CPU应用的最多的

345
00:11:30,120 --> 00:11:31,800
肯定是服务器领域

346
00:11:31,800 --> 00:11:34,280
但他个人可能接触的比较少

347
00:11:34,280 --> 00:11:37,760
但是现在我国有各种大量的云运营商

348
00:11:37,760 --> 00:11:38,560
华为云

349
00:11:39,000 --> 00:11:40,200
云阿里云

350
00:11:40,680 --> 00:11:42,360
腾讯云这些云服务商

351
00:11:42,600 --> 00:11:45,160
都是用大量的服务器领域的

352
00:11:45,160 --> 00:11:48,080
里面塞了大量的x86的CPU在里面

353
00:11:48,320 --> 00:11:50,880
第二个就是我们平时经常接触到的

354
00:11:50,880 --> 00:11:52,160
包括我给你们录视频的

355
00:11:52,560 --> 00:11:54,160
都是用我们的苹果电脑

356
00:11:54,160 --> 00:11:55,200
能用到电脑了

357
00:11:55,200 --> 00:11:57,840
就会用到intel和AMD的芯片

358
00:11:57,960 --> 00:11:58,480
当然了

359
00:11:58,480 --> 00:12:00,320
现在苹果基于ARM

360
00:12:00,320 --> 00:12:02,600
确实开发出自己的PC领域的芯片

361
00:12:02,600 --> 00:12:03,880
这也是跟intel打架

362
00:12:03,880 --> 00:12:05,640
打得非常厉害的一个话题了

363
00:12:06,080 --> 00:12:07,640
最后就是嵌入式领域了

364
00:12:07,640 --> 00:12:09,640
包括我们的手机嵌入式的设备

365
00:12:09,640 --> 00:12:11,760
包括我们经常之前疫情期间

366
00:12:12,360 --> 00:12:13,640
的一声哨一哨

367
00:12:13,640 --> 00:12:16,600
那种都是我们的ios嵌入式的设备

368
00:12:17,640 --> 00:12:19,600
最后我们来一个总结

369
00:12:19,600 --> 00:12:22,600
就是现在CPU是具备整体的

370
00:12:22,600 --> 00:12:24,000
图灵的完备性的

371
00:12:24,000 --> 00:12:25,320
它可以做一个主动的

372
00:12:25,320 --> 00:12:27,160
从我们的内存里面读取

373
00:12:27,160 --> 00:12:28,920
指令流读取我们的数据

374
00:12:28,920 --> 00:12:30,200
然后解码之后

375
00:12:30,200 --> 00:12:31,480
给我们的计算机

376
00:12:31,480 --> 00:12:32,440
计算单元

377
00:12:32,440 --> 00:12:33,880
ALU进行执行

378
00:12:33,880 --> 00:12:36,520
那最后再把结果写回我们的数据

379
00:12:36,520 --> 00:12:38,920
那第二个我们讲了ISA

380
00:12:38,920 --> 00:12:40,160
我们的指令ISA

381
00:12:40,160 --> 00:12:42,520
主要是跟我们的计算机体系结构

382
00:12:42,520 --> 00:12:43,920
还有编程部分相关的

383
00:12:43,920 --> 00:12:45,560
它定义了整个指令集的

384
00:12:45,560 --> 00:12:46,520
数据类型计算器

385
00:12:46,520 --> 00:12:47,600
寻子内存管理

386
00:12:47,600 --> 00:12:48,440
还有IO

387
00:12:48,440 --> 00:12:51,040
所以我们说ISA对于CPU来说

388
00:12:51,040 --> 00:12:52,920
非常非常的重要

389
00:12:52,920 --> 00:12:55,800
没了它就没有了我们现在的CPU

390
00:12:55,920 --> 00:12:56,960
那最后最后一点

391
00:12:57,080 --> 00:12:58,520
我们实际上可以把CPU

392
00:12:58,720 --> 00:13:01,240
简单的分开为控制面

393
00:13:01,240 --> 00:13:03,480
还有计算面两个部分

394
00:13:03,480 --> 00:13:06,400
而CPU作为指令流驱动的

395
00:13:06,400 --> 00:13:08,000
整体的计算引擎

396
00:13:08,000 --> 00:13:09,360
非常的重要

397
00:13:09,360 --> 00:13:10,080
现在来说

398
00:13:10,080 --> 00:13:11,280
我们做任何事情

399
00:13:11,280 --> 00:13:13,240
都离不开CPU

400
00:13:13,240 --> 00:13:15,480
包括我们现在虽然有AI芯片

401
00:13:15,480 --> 00:13:17,840
但是AI芯片要跟CPU配合来使用

402
00:13:17,840 --> 00:13:19,120
更多的调度控制

403
00:13:19,120 --> 00:13:20,840
是由我们的CPU来做的

404
00:13:20,840 --> 00:13:22,760
而具体的可能矩阵的计算

405
00:13:22,760 --> 00:13:24,080
和深度学习的计算

406
00:13:24,080 --> 00:13:24,920
AI的计算

407
00:13:24,920 --> 00:13:27,480
就交给我们的具体的其他的芯片

408
00:13:27,480 --> 00:13:28,640
而我们总体来说

409
00:13:28,640 --> 00:13:29,880
CPU很重要

410
00:13:29,880 --> 00:13:31,320
于是就放在第一节

411
00:13:31,320 --> 00:13:32,960
那今天的内容就到这里为止

412
00:13:32,960 --> 00:13:33,560
谢谢各位

413
00:13:33,560 --> 00:13:34,760
拜拜

