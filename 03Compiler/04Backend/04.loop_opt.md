# 算子循环优化

## 循环展开

循环展开（Loop Unrolling）将一个循环中的多次迭代展开成多个单独的迭代，以减少程序执行的开销，提高代码的运行效率。在计算机执行程序的流水线中，每次跳转到循环体内部都需要进行额外的指令处理和跳转操作，这会增加程序的开销。而循环展开可以通过减少跳转次数、减少指令处理次数等方式，降低指令分支预测的开销来优化程序性能，提高程序执行的速度。

当程序中存在大量循环结构时，每一次循环迭代都要判断是否满足循环的条件，造成额外开销。如果循环的次数已知，且数据前后没有依赖关系，则可以产生大量指令针对每个数据进行运算，为具有多个功能单元的处理器提供指令级并行，也有利指令流水线的调度。

原始循环：

```python
for i in range(n):
    a[i] += b[i]
```

通过循环展开，可以将其转换为以下形式：

```c++
for i in range(0, n-3, 4):
    a[i] += b[i]
    a[i+1] += b[i+1]
    a[i+2] += b[i+2]
    a[i+3] += b[i+3]
for i in range(n-3, n):
    a[i] += b[i]
```

在展开后的循环中，原本执行了 *n* 次循环迭代，变成了执行 *n/4* 次循环展开。因此，在循环体较小且循环次数较大的情况下，循环展开可以显著提高程序的执行效率。

需要注意的是，循环展开也有可能会增加代码的大小，增加缓存的使用，以及降低代码的可读性等副作用。因此，在进行循环展开优化时，需要综合考虑代码的执行效率、可读性、代码大小等方面的因素。

## 循环分块

循环分块是利用cache的数据局部性进行优化的一种方法。现代CPU通常具有多级cache，在存储体系中，cache是除CPU寄存器外最接近CPU的存储层次，相比主存速度更快，但是容量更小。cache中复制有CPU频繁使用的数据以进行快速访问。由于cache的容量有限，数据会在cache中进行换入换出。当访问的数据在cache中没有时，产生cache miss，会向低一级存储层次发出访问请求，然后该数据存储进cache，这时访问数据的时间就大大提高。当访问数据就在cache中时，会直接使用该数据以进行复用。

循环分块主要针对大型数据集进行优化，大数据集无法一次全部存入cache中。当遍历该数据集时，循环按照顺序进行访问，会替换掉之前加载进cache的数据，导致后面的指令对之前的数据无法复用，要重新加载数据，产生大量的cache miss，数据的复用性很差。程序执行时间变长，大量时间花费在载入数据上。

循环分块将大数据集分成多个小块以充分进行数据复用。数据块的内存访问是一个具有高内存局部性的小邻域。该数据块可以一次加载进cache，执行完所有或者尽可能多的计算任务后才被替换出。

在实现中将一层内层循环分成 outer loop * inner loop。然后把 outer loop 移到更外层去，从而确保 inner loop 一定能满足 Cache。

原始的数据存储访问模式和分块后的存储访问模式见下图：

![循环分块访存模式]((../images/034CM_Backend/loop_tiling.png)



## 循环重排

循环重排序（reorder）是矩阵乘法常见的优化方式，指的是对程序中的循环结构重新排列顺序，以优化数据访问模式，特别是在CNN中卷积层的应用。通过改变循环的嵌套顺序或者循环内部的迭代顺序，可以改善数据的局部性，减少缓存失效。如下图循环重排序示意图，在矩阵乘法计算中，B是逐列访问的，在行优先的存储模式下访问模式很不友好。切换内层的循环顺序可以使得所有元素按顺序读取和写入。一次计算输出的一行，得到的是中间结果，全部累加即可得到结果矩阵的一行最终结果，这种方式利用的是内存的空间局部性。

![循环重排访存模式]((../images/034CM_Backend/loop_reorder.png)

## 循环融合

循环融合（Loop Fusion）用于将多个循环合并为一个更大的循环，将相邻或紧密间隔的循环融合在一起。通过合并多个循环，可以减少程序中的循环次数，从而减少循环开销。合并循环可以减少内存访问次数，提高数据局部性，减少缓存未命中的可能性，从而提高程序执行效率。

以下是一个简单的循环融合的示例代码：

两个独立的循环如下：

```python
# 独立的循环
for i in range(len(a)):
    a[i] = a[i] * a[i]

for i in range(len(b)):
    b[i] = b[i] * b[i]
```

通过循环融合，可以将这两个循环合并为一个循环：

```python
# 循环融合
for i in range(len(a)):
    a[i] = a[i] * a[i]
    b[i] = b[i] * b[i]
```



## 循环拆分

拆分主要是将循环分成多个循环，可以在有条件的循环中使用，分为无条件循环和含条件循环。

```python
for i in range(n):
    A[i] = a[i] + b[i]
    c[i]=2 * a[i]
    if(temp[i] > data):
        d[i] = a[i]
 
#循环拆分
for i in range(n):
    A[i] = a[i] + b[i]
    c[i]=2 * a[i]

for i in range(n):
    if(temp[i] > data):
        d[i] = a[i]
```

通过拆分，将包含控制流的代码独立为一个循环。一部分代码只有计算，可以在加速器上计算，而加速器不支持的控制流部分就可以回退到CPU计算。



## 本节视频

<html>
<iframe src="https://player.bilibili.com/player.html?bvid=BV1r14y1w7hG&as_wide=1&high_quality=1&danmaku=0&t=30&autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</html>
