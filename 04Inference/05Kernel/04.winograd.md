# Winograd算法

## 算法介绍
Im2col 在将三维张量组织成矩阵后调用 GEMM 计算库，这些计算库很大程度上使用一些基于访存局部性的优化；空间组合优化则本身就是利用局部性优化的方法。本小节介绍的 Winograd 优化算法则是矩阵乘优化方法中 Coppersmith–Winograd 算法的一种应用，是基于算法分析的方法。

Andrew Lavin 和 Scott Gray 在 Fast Algorithms for Convolutional Neural Networks 首次介绍了这种方法。该方法现已广泛应用于各种深度学习框架中。Winograd 算法在卷积优化中的应用的基本方法和矩阵乘中应用类似，通过技巧性的矩阵计算变换，减少计算过程所需的乘法数量。下面简要介绍一下基本原理（全部摘自原文）。

## 算法过程
### conv算法原理


### Winograd 一维卷积原理


### Winograd 原理推导


## 工程实现
### 概述

### 详细步骤
对于 weights 的转换，首先通过 Winograd 变换矩阵 G 和 GT 分别将 3x3 的 weight 转换为 4x4 的矩阵，然后将该矩阵中相同位置的点（如图中蓝色为位置 1 的点）转换为一个 IC*OC 的矩阵，最终形成 4x4=16 个转换之后 weights 矩阵。
<br /><center> ![winograd03](images/winograd03.png "winograd03") </center>

对于 FeatureMap 的转换，首先将输入 FeatureMap 按照 4x4 tile 进行切分，然后将每个 tile 通过 B 和 B^T 转换为 4x4 的矩阵，矩阵 B 和 B^T 为 FeatureMap 对应的 Winograd 变换矩阵，然后进行与 weight 处理，转换为 16 个 nr tiles * IC 的 FeatureMap 矩阵。
<br /><center> ![winograd04](images/winograd04.png "winograd04") </center>

将上述转换矩阵矩阵乘，得到 16 个 nr tiles * OC 矩阵，然后将相同位置的 16 个点转换为 nr tiles * OC 个 4x4 矩阵，再使用输出的 Winograd 变换矩阵 A 和 A^T 将这些 4x4 的矩阵转换为 2x2 的输出矩阵，最后将这些矩阵写回输出矩阵中就可以得到 Winograd 卷积的最终结果。
<br /><center> ![winograd05](images/winograd05.png "winograd05") </center>


### 实现步骤

## 本节视频

<html>
<iframe src="https:&as_wide=1&high_quality=1&danmaku=0&t=30&autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</html>
