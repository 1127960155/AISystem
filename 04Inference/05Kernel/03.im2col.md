# Im2Col算法

## 算法介绍
作为早期的深度学习框架，Caffe 中卷积的实现采用的是基于 im2col 的方法，至今仍是卷积重要的优化方法之一。

Im2col 是计算机视觉领域中将图片转换成矩阵的矩阵列（column）的计算过程。从上一节的介绍中可以看到，二维卷积的计算比较复杂不易优化，因此在深度学习框架发展的早期，Caffe 使用 Im2col 方法将三维张量转换为二维矩阵，从而充分利用已经优化好的 GEMM 库来为各个平台加速卷积计算。
最后，再将矩阵乘得到的二维矩阵结果使用 Col2im 将转换为三维矩阵输出。
<br /><center> ![im2col_1](images/im2col01.png "im2col_1") </center>


## 算法过程
>除非特别说明，本文默认采用的内存布局形式为 NHWC 。其他的内存布局和具体的转换后的矩阵形状或许略有差异，但不影响算法本身的描述。

Im2col+Matmul 方法主要包括两个步骤：
1) 使用 Im2col 将输入矩阵展开一个大矩阵，矩阵每一列表示卷积核需要的一个输入数据。
2) 使用上面转换的矩阵进行 Matmul 运算，得到的数据就是最终卷积计算的结果。

### 卷积通用过程
图像卷积正常的三通道卷积，输入维度为3维（H, W, 3），卷积核维度为（N, C, KH, KW），输出维度为（N, H, W）。卷积的一般计算方式为：
<br /><center> ![im2col_3](images/im2col03.png "im2col_3") </center>
 
卷积默认采用数据排布方式为NHWC，输入维度为4维（N,IH,IW,IC），卷积核维度为（OC,KH,KW,IC），输出维度为（N,OH,OW,OC）。卷积的一般计算方式为：
<br /><center> ![im2col_4](images/im2col04.png "im2col_4") </center>
### Im2col算法过程
卷积操作转换为矩阵相乘，对 Kernel 和 Input 进行重新排列。将输入数据按照卷积窗进行展开并存储在矩阵的列中，多个输入通道的对应的窗展开之后将拼接成最终输出 Matrix 的一列
<br /><center> ![im2col_5](images/im2col05.png "im2col_5") </center>

对 Input 进行重排，得到的矩阵见右侧，行数对应输出 OH*OW 个数；每个行向量里，先排列计算一个输出点所需要输入上第一个通道的 KH*KW 个数据，再按次序排列之后通道，直到通道 IC。
<br /><center> ![im2col_6](images/im2col06.png "im2col_6") </center>

对权重数据进行重排，即以卷积的 stride 为步长展开后续卷积窗并存在 Matrix 下一列。将 N 个卷积核展开为权重矩阵的一行，因此共有 N 行，每个行向量上先排列第一个输入通道上KH*KW 数据，再依次排列后面的通道直到 IC。
<br /><center> ![im2col_7](images/im2col07.png "im2col_7") </center>

通过数据重排，完成 Im2col 的操作之后会得到一个输入矩阵，卷积的 Weights 也可以转换为一个矩阵，卷积的计算就可以转换为两个矩阵相乘的求解，得到最终的卷积计算结果。
<br /><center> ![im2col_8](images/im2col08.png "im2col_8") </center>

Im2col 算法计算卷积的过程，具体过程如下（简单起见忽略 Padding 的情况，即认为OH=IH,OW=IW）：

> 1. 将输入由N×IH×IW×IC根据卷积计算特性展开成(OH×OW)×(N×KH×KW×IC)形状二维矩阵。显然，转换后使用的内存空间相比原始输入多约KH∗KW−1倍；
> 2. 权重形状一般为OC×KH×KW×IC四维张量，可以将其直接作为形状为(OC)×(KH×KW×IC)的二维矩阵处理；
> 3. 对于准备好的两个二维矩阵，将(KH×KW×IC)作为累加求和的维度，运行矩阵乘可以得到输出矩阵(OH×OW)×(OC)；
> 4. 将输出矩阵(OH×OW)×(OC)在内存布局视角即为预期的输出张量N×OH×OW×OC，或者使用 Col2Im 算法变为下一个算子输入 N×OH×OW×OC:

### Im2col 算法要点总结
 1. Im2col 计算卷积使用 GEMM 的代价是额外的内存开销。使用 Im2col 将三维张量展开成二维矩阵时，原本可以复用的数据平坦地分布到矩阵中，将输入数据复制了KH∗KW−1份;
 2. 转化成矩阵后，可以在连续内存和缓存上操作，而且有很多库提供了高效的实现方法（BLAS、MKL），Numpy 内部基于 MKL 实现运算的加速。
 3. 在实际实现时，离线转换模块实现的时候可以预先对权重数据执行 Im2col 操作，Input Data Im2col和GEMM的数据重排会同时进行，以节省运行时间。

# 空间组合优化算法
>数学原理待更
>
## 算法介绍
Im2col 是一种比较朴素的卷积优化算法，在没有精心处理的情况下会带来较大的内存开销。空间组合（Spatial pack）是一种类似矩阵乘中重组内存的优化算法。

空间组合优化算法：是一种基于分治法（Divide and Conquer）的方法，基于空间特性，将卷积计算划分为若干份，分别处理。
## 空间组合优化原理
如图所示在空间上将输出、输入划分为四份：
<br /><center> ![im2col_9](images/im2col09.png "im2col_9") </center>

划分后，大卷积计算被拆分为若干个小卷积进行计算。划分过程中计算总量不变，但计算小矩阵时访存局部性更好，可以借由计算机存储层次结构获得性能提升：
<br /><center> ![im2col_10](images/im2col10.png "im2col_10") </center>

### 注意点
> 需要更改
>
<br /><center> ![im2col_11](images/im2col11.png "im2col_11") </center>

### 仍存在的问题
1. 实际应用中可以拆为很多份。例如可以拆成小张量边长为 4 或者 8 ，从而方便编译器向量化计算操作。随着拆分出的张量越小，Padding 引起的额外内存消耗越大，其局部性也越高，负面作用是消耗的额外内存也越多。
2. 对于不同规模的卷积，寻找合适的划分方法不是一件容易的事情。正如计算机领域的许多问题一样，该问题也是可以自动化的，例如通过使用 AI编译器 可以在这种情况下寻找较优的划分方法。

## 算法流程

## 本节视频

<html>
<iframe src="https:&as_wide=1&high_quality=1&danmaku=0&t=30&autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</html>
