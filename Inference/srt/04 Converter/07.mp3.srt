0
0:00:00.000 --> 0:00:04.760
吧吧吧吧拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔拔

1
0:00:05.340 --> 0:00:08.760
哈喽大家好我还是那个周米

2
0:00:08.760 --> 0:00:10.960
现在我们还是推进引擎的模型

3
0:00:10.960 --> 0:00:14.120
立显游化里面的计算图游化这个内容

4
0:00:15.180 --> 0:00:20.920
我们在上一集里面呢讲了很多长量眉谍的一些具体的parts还有具体的规则

5
0:00:20.920 --> 0:00:24.500
下面呢我们其实又讲了很多勇于节点的消除

6
0:00:24.500 --> 0:00:26.920
其实勇于节点的消除特别特别的多

7
0:00:26.920 --> 0:00:28.880
总结起来都有二十多条了

8
0:00:28.880 --> 0:00:30.480
产量则有十几条了

9
0:00:30.480 --> 0:00:32.600
那接下来内容呢我们快速地过一下

10
0:00:32.600 --> 0:00:36.920
擅子永和擅子替换还有擅子迁移

11
0:00:36.920 --> 0:00:40.000
所以说在基础的图优化里面呢

12
0:00:40.000 --> 0:00:44.360
总比看到了有些开源项目里面的计算图优化

13
0:00:44.360 --> 0:00:47.440
就有五十多甚至上百个parts

14
0:00:47.440 --> 0:00:48.920
那这里面就有非常多的parts

15
0:00:48.920 --> 0:00:51.520
而这里面呢只是一个basic第一哟

16
0:00:51.520 --> 0:00:55.600
我们还有二三还有非常多的不同的优化的parts

17
0:00:55.600 --> 0:00:58.840
那现在呢我们马上开始擅子永和

18
0:00:58.840 --> 0:01:01.720
这个内容

19
0:01:01.720 --> 0:01:04.800
擅子永和这个概念呢其实我觉得大家都知道了啊

20
0:01:04.800 --> 0:01:12.360
像卷迹艾特啊卷迹茂德啊卷迹比恩啊还有维瑞普啊还有维薛白这些基本上都可以做很多永和的方式

21
0:01:12.360 --> 0:01:18.040
这里面的却是永和的规则呢也有很多只是op的一些线性的永和

22
0:01:18.040 --> 0:01:22.760
线性永和呢就是说相邻的op呢存在线性上可永和的关系

23
0:01:22.760 --> 0:01:27.120
就线性上呢我们可以从数学层面呢去把它们通过线性的变换

24
0:01:27.240 --> 0:01:32.400
换口数学的线性组合把它们变成一个相同的算子块变成一个大算子

25
0:01:32.400 --> 0:01:35.280
那像这种呢我们叫做op的线性永和

26
0:01:35.280 --> 0:01:48.200
那从卷迹来看啊卷迹比恩艾特拉就卷迹比恩激活卷迹比恩艾特拉卷迹斯科尔艾特拉卷迹茂德艾特拉这种就卷迹家很多其实都可以做很多非常的永和

27
0:01:48.200 --> 0:01:54.880
那假设像比恩呢就可以把比恩的那些γβ其实永和到我们的卷迹参数里面

28
0:01:54.880 --> 0:01:58.600
那卷迹参数呢就有两个一个是weight一个是biased

29
0:01:58.600 --> 0:02:04.600
所以说一般的都可以把很多的数呢提前算到我们的weight和biased里面两个方式

30
0:02:04.600 --> 0:02:06.440
下面我们看一下具体的图啊

31
0:02:07.640 --> 0:02:13.840
我做这一期的时候呢画图就花了我基本上三四天的时间了三四天业馀的时间

32
0:02:13.840 --> 0:02:20.560
所以还是嗯图还是很难的所以欢迎大家去取阅或者拿来用声明来源就好了

33
0:02:20.560 --> 0:02:28.120
像我们可以看到卷迹比恩艾特拉卷迹比恩的公式呢我们可以看到在训练的时候呢我们就已经训练好我瓦迦斯的命了嘛

34
0:02:28.120 --> 0:02:32.360
像我们的权重的b呢就可以通过这种方式呢去重新的计算

35
0:02:32.360 --> 0:02:36.760
那最后呢就变成一个具体的只有一个卷迹了像激活了基本上都可以融进去

36
0:02:36.760 --> 0:02:50.000
那好像里面的一个艾特的const就可以永和到我们的biased里面像scale里面的scale呢还有biased呢就可以永和到我们的biased还有我们的weight里面同样的方式卷迹呢可以做非常多的永和

37
0:02:50.000 --> 0:02:59.720
下面我们还是在图上永和里面的ops的一种线性的永和线性永和有非常多刚才只是举了一些卷迹啊我们可以看到线性永和有

38
0:02:59.720 --> 0:03:10.960
麦克茂加艾特拉麦克茂加scale呢面加艾特拉贝殊隆加scale呢麦克茂加贝殊隆呢麦克茂加艾大家觉得可以自己创新很多的parts或自己能想到很多的parts

39
0:03:10.960 --> 0:03:19.640
但除了自己想到更多是些实际场景来去驱动的因为面却是后面可以加很多不同的算子也做很多的新的创新

40
0:03:19.640 --> 0:03:25.800
那么可以看到像麦克茂呢加了个艾特可以把艾特这个参数呢变成GMM这种参常

41
0:03:25.800 --> 0:03:30.840
在麦克茂前面的有个scale或者DIV呢确实也可以把它永和进来

42
0:03:30.840 --> 0:03:36.560
像面跟艾特呢我们就可以把它变成一个layer long的方式做一个简单的永和

43
0:03:36.560 --> 0:03:47.400
所以说算子永和的方式特别特别的多嗯这里面呢也是一节的讲不完的我们只是简单的穿一穿给大家知道一下有这么一个事情就好了大家听听就完了

44
0:03:47.400 --> 0:04:17.400
当个开心后面呢还有OP的一些激活的永和就卷机加比录呢卷机加比录六呢还有卷机加其他的ec基本上都可以做永和这这是很重要为什么要这么做呢确实它可以减少我们的第二次仿存卷机的时候呢我可能仿存有两三次啊第一次呢去取里面的输入的数据然后呢去取我们的位置了还有去取我们的base呢相比录呢我们输出之后呢又要取我们的输入那这个时候呢把它永和在一起呢确实能够减少

45
0:04:17.400 --> 0:04:47.400
我们的仿存的次数还可以加快我们的计算的时间不用换出换出HBM节大的减少啦接着我们可以看一下看完算子永和之后我们看看算子的替换那算子的替换呢就真的很简单了就一配一个node了或一配一个OD变成另外一个OD那这里面呢有几种方式一种是one to one就一个算子换一个算子像MacMount呢就直接换成卷机那这种也是很好的优优化像NINO呢全连接方式呢

46
0:04:47.400 --> 0:05:17.400
变成我们的卷机就变成一个一乘一的卷机不是通用的卷机哦像币恩的原理呢是等价于scale的那这个时候呢我们其实也可以通过scale来去换算那scale的计算方式呢其实更少像匹克维露呢我们其实可以在真正推理的时候呢换成内克维露其实真的是不影响我们的精度的而且有可能精度还有提升哦所以说基本上我们的一对一的算子替换有非常多那值得注意的就是像MacMount啊虽然是一对一的替换替换成卷机但注意的时候

47
0:05:17.400 --> 0:05:47.400
MacMount的数据呢是一个二维的数据的一个乡城a乘以b然后乘以b乘以a这两个矩阵乡城就得到了一个a乘以a的矩阵那这个时候呢我们卷机呢数据的数据维度一般都是四维的nc去w所以这个时候呢我们需要对两维的数据呢进行一个we shape对我们的input第二个数据呢进行一个transpose然后再给它进行一个运算的所以大家注意哦像这里面的一个全连接变成一个卷机一乘一

48
0:05:47.400 --> 0:06:17.400
的也是需要进行一个we shape输出呢也是进行一个we shape就好了简单的改改它的一个内存排布还有边呢我们确实可以把它变成一个scale的方式这也是具体的计算那像披露呢就变成一个立路看图说话总是这么简单我们接下来再看一看一些一换多就是一个算子换成多个算子能够减少我们推进引擎呢要实现很多很多不同的算子就是一个大科董呢换成一个小的

49
0:06:17.400 --> 0:06:47.400
为什么会出现一换多呢有一个算子换成多个算子呢是因为我们在推进引擎里面的假设我没有支持这个算子但这个算子呢可以通过很多小算子进行拼接的那这个时候呢我们的理想总换优化模块呢就可以做一些一换多的方式像学富内里面呢就有学富圈奴那学富圈奴呢可能有一些推进引擎呢没有实现于是呢就可以通过微讯比较premium这种方式进行组合像派特呢确实有些AI框架呢会有派特二或者其他

50
0:06:47.400 --> 0:07:17.400
方式我们也可以转换像设备呢是探测服里面特有的一种算子我们也可以通过多个设备的算子进行转换像谷谷卷机呢也可以通过slist加谷谷呢进行一个替换所以说里面的方式特别特别的多我们举简单一个例子像学富圈奴呢确实可以通过微讯较premium的这种方式去进行一个转换那具体的为什么可以这么转大家也可以推理一下像这里面的卷机呢假设谷不等于一我们可以把它slist

51
0:07:17.560 --> 0:07:21.000
藏谷不个number的一个卷机的参数啊

52
0:07:21.560 --> 0:07:27.000
有谷不个那这里面的卷机呢谷不就等于零就把它concate到一起那这种呢就替换掉了

53
0:07:27.480 --> 0:07:34.360
这样呢就可以去实现推理引擎里面本来没有这些算子但是我们可以通过一些算子的组合进行一个替换

54
0:07:36.600 --> 0:07:46.680
在计算图游玩里面的一个basic最基础的我们还有最后一个内容就是算子的前一一算子的前一有比较多像slist跟model啊还有bitshift跟reduce

55
0:07:46.680 --> 0:07:51.160
那么这些都可以把它替换掉位置把它往前挪

56
0:07:52.760 --> 0:07:58.040
而算子前一其实我觉得嗯大家呀其实不要觉得你你要去发现规律

57
0:07:58.360 --> 0:08:04.840
更多的时候呢我们可以利用算数的一个交换率去考虑这个问题我们可不可以这么去操作

58
0:08:05.080 --> 0:08:12.040
就是我们的算数的计算的过程当中呢能不能通过交换率减少我们的数据的传输还有仿存的次数

59
0:08:12.200 --> 0:08:23.720
这一点很重要就大家要去真正地站在问题的本子去看问题而不是为了发现帕斯发现创造不同的规律而创造规律更多地要结合我们的真正的场景和数学的研拟

60
0:08:24.200 --> 0:08:33.400
那下面呢我们可以看到像这种呢就是算子前一的一个很经典的案例我一个mod然后在slist呢我确实可以把它直接slist掉然后直接成在做一个mod

61
0:08:33.640 --> 0:08:40.040
那像一个bitshift呢还有reduce呢确实可以把它换回来可以减少我们的通讯的次数

62
0:08:42.040 --> 0:08:45.240
好了今天的内容就到这里为止了我们回顾一下

63
0:08:47.320 --> 0:09:00.520
在计算图的基础图优化的这个模块呢我们讲了常量的折叠把一些不用的常量的就把它合并在一起其实它有点类似于永逸节点的消除就把一些常量把它干掉

64
0:09:00.760 --> 0:09:07.240
那接着呢我们又讲了一些永逸节点的消除永节点的消除有非常非常的多我列出来的就已经快接近二十个了

65
0:09:07.240 --> 0:09:37.240
然后呢有些算子融合把很多零散的算子呢变成一个大的算子还有算子替换呢有一对一的替换也有一对多的替换的一对多的替换呢就有点算子融合的一个逆过程最后呢我们还有一些算子的迁移迁移的工作呢确实为了减少我们的仿存的次数让我们训练的更快以这个目的作为驱动好了今天的内容就到这里为止谢谢各位摆了个拜卷得不行了卷得不行了记得一键二详

66
0:09:37.240 --> 0:09:42.960
键餐点加关注哦所有的内容都会开源在下面这条链接里面摆了个拜

