0
0:00:00.000 --> 0:00:08.640
Hello大家好,我是ZOMI,冷得瑟瑟发抖的ZOMI

1
0:00:08.640 --> 0:00:12.000
大家不要只关注不点赞,也不要只点赞不关注

2
0:00:12.000 --> 0:00:17.440
现在我们还是在推进引擎模型转换和优化的内容

3
0:00:17.440 --> 0:00:21.080
因为在转换模块确实之前的内容有点多

4
0:00:21.080 --> 0:00:23.240
所以最终还是分成三节内容

5
0:00:23.240 --> 0:00:28.000
今天主要去给大家汇报一下的就是模型转换的整体的流程

6
0:00:28.000 --> 0:00:30.760
我们看一下之前讲到的一些内容

7
0:00:30.760 --> 0:00:32.360
先来简单的回顾一下

8
0:00:32.360 --> 0:00:35.760
之前我们去看了一下最基础的挑战和架构

9
0:00:35.760 --> 0:00:38.920
然后看了一下网络模型怎么去反串行化和串行化

10
0:00:38.920 --> 0:00:42.040
接着进入了一个自定义的计算图

11
0:00:42.040 --> 0:00:43.160
自定义完计算图之后

12
0:00:43.160 --> 0:00:46.880
现在来看看整体的转换模块的流程

13
0:00:46.880 --> 0:00:49.360
还有相关的一些技术的细节

14
0:00:51.200 --> 0:00:54.160
下面我们来到转换模块的最后一个内容

15
0:00:54.360 --> 0:00:57.240
就是模型转换的流程和技术细节

16
0:00:57.360 --> 0:00:59.480
说实话这里面的更多的技术细节

17
0:00:59.480 --> 0:01:01.520
我们在分散在每一节了

18
0:01:01.520 --> 0:01:04.600
我们来看一看转换模块主要有两个思路

19
0:01:04.840 --> 0:01:07.040
第一个就是直接转换

20
0:01:07.040 --> 0:01:10.160
第二个就是规范式的一种转换

21
0:01:10.160 --> 0:01:15.160
直接转换我们看刚才我们的一个转换的架构图可以看到

22
0:01:15.160 --> 0:01:16.920
例如我们现在以Maxwell为例

23
0:01:17.040 --> 0:01:21.440
我们把Maxwell通过一个converter转成推进引擎的IR

24
0:01:22.200 --> 0:01:27.000
这种方式就是直接把AI框架的格式转换成为推进引擎的格式

25
0:01:27.760 --> 0:01:31.800
第二种规范性的转换主要是指使用开放经营的文档格式

26
0:01:31.800 --> 0:01:36.040
然后让更多的主流的AI框架都对应到格式范围

27
0:01:36.040 --> 0:01:38.360
说白了就是像我们的这个图

28
0:01:38.360 --> 0:01:40.120
我们的架构图又出现了

29
0:01:40.120 --> 0:01:42.760
例如PyTorch它不是直接转PyTorch

30
0:01:42.760 --> 0:01:44.680
而是把PyTorch转成onlist

31
0:01:44.680 --> 0:01:47.360
或者我们可以把Maxwell转成onlist

32
0:01:47.360 --> 0:01:51.760
然后通过onlist converter这个模块转成推进引擎的IR

33
0:01:51.760 --> 0:01:54.440
这种就是第二种规范性的转换

34
0:01:54.480 --> 0:01:58.400
其实在我们现在至少在中米了解过的很多的AI框架

35
0:01:58.400 --> 0:02:03.000
基本上两种的转换的方式和转换的技术都是同时支持的

36
0:02:04.120 --> 0:02:07.400
像直接转换它整个算法还是比较清晰的

37
0:02:07.400 --> 0:02:10.400
我们看一下第一个就是内容的读取

38
0:02:10.400 --> 0:02:13.480
把从不同AI框架生成的一个网络模型

39
0:02:13.920 --> 0:02:16.200
通过识别几个内容非常重要

40
0:02:16.200 --> 0:02:19.480
网络模型的张量的数据的类型和格式

41
0:02:19.480 --> 0:02:21.680
还有算子的类型和参数

42
0:02:21.800 --> 0:02:24.560
另外还有计算图的结构和命名规范

43
0:02:24.560 --> 0:02:27.760
和它们之间的相关的信息进行读取

44
0:02:27.760 --> 0:02:31.800
这几个也是对应于我们自定义计算图里面的张量

45
0:02:31.800 --> 0:02:36.120
算子还有图三个内容进行一个识别

46
0:02:36.120 --> 0:02:38.680
接着第二步就是格式的转换

47
0:02:38.680 --> 0:02:42.640
格式的转换就是把我们刚才识别到的一些内容了

48
0:02:42.640 --> 0:02:45.640
其实在识别完之后就变成了

49
0:02:45.640 --> 0:02:48.840
内存的一个对象或者代码具体指向的一个地址

50
0:02:48.960 --> 0:02:52.520
这个时候我们就可以真正的做一些格式的转换

51
0:02:52.520 --> 0:02:54.520
通过commit来进行转换

52
0:02:55.160 --> 0:02:58.080
转换之后就是对模型进行保存的保存

53
0:02:58.200 --> 0:03:02.880
可能还会用回PBR或者FB的这种文档的格式

54
0:03:02.880 --> 0:03:05.120
然后用于我们下一次推进引擎

55
0:03:05.120 --> 0:03:07.680
真正one time的时候去调用的

56
0:03:09.200 --> 0:03:12.680
像第二种规范式的转换就是ONNX的

57
0:03:12.680 --> 0:03:15.960
确实ONNX是个非常典型的代表

58
0:03:16.280 --> 0:03:19.760
现在我们看一下ONNX官网的一个AI的定义

59
0:03:20.920 --> 0:03:23.640
下面这个就是ONNX的AI的定义

60
0:03:23.640 --> 0:03:25.280
确实大家也可以去看一看

61
0:03:25.280 --> 0:03:26.760
ONNX的AI跟Portobuf

62
0:03:26.760 --> 0:03:28.880
或者我们刚才定义的有什么不一样

63
0:03:28.880 --> 0:03:31.680
对于它的网络模型它的定义有什么不同

64
0:03:31.680 --> 0:03:33.840
对于模型的一些可选的参数

65
0:03:33.840 --> 0:03:35.400
还有OP, OP-set

66
0:03:35.400 --> 0:03:38.280
当然还有很多function的功能

67
0:03:38.280 --> 0:03:39.560
还有graph的功能

68
0:03:39.560 --> 0:03:43.760
确实它的定义比我们刚才讲的要多很多

69
0:03:43.960 --> 0:03:46.640
这里面我就不跟大家一一去介绍了

70
0:03:48.320 --> 0:03:51.400
回到我们模型转换的一个通用的流程

71
0:03:51.520 --> 0:03:54.480
下面这个图就是整个模型转换的通用流程

72
0:03:54.480 --> 0:03:56.080
不管是直接转换

73
0:03:56.080 --> 0:03:59.280
还是像ONNX的这种规范化的一个格式转换

74
0:03:59.440 --> 0:04:01.640
其实流程还是这一套流程

75
0:04:01.640 --> 0:04:03.720
首先我们有AI框架

76
0:04:03.720 --> 0:04:05.080
就AI训练好的框架

77
0:04:05.080 --> 0:04:06.440
生成一个计算图

78
0:04:06.640 --> 0:04:07.920
这个生成计算图的功能

79
0:04:08.240 --> 0:04:10.360
主要是AI框架去实现的

80
0:04:10.360 --> 0:04:11.560
我们在推进引擎

81
0:04:11.560 --> 0:04:14.160
实际上是不感知或者没怎么去接触的

82
0:04:14.160 --> 0:04:17.080
接着真正的在推进引擎里面的converter

83
0:04:17.240 --> 0:04:18.560
主要是三个模块

84
0:04:18.560 --> 0:04:21.120
第一个是做一个算子的对接

85
0:04:21.120 --> 0:04:23.800
我们需要把计算图里面的IR的算子

86
0:04:23.800 --> 0:04:27.240
或者计算图里面的一些primitive的算子

87
0:04:27.240 --> 0:04:29.640
对接到我们刚才自定义的一些算子

88
0:04:30.640 --> 0:04:33.240
接着会进行一个具体的格式的转换

89
0:04:33.240 --> 0:04:35.240
就真正的一些工程化的转换

90
0:04:35.240 --> 0:04:38.120
把不同的计算图的IR转成自己的一个IR

91
0:04:38.120 --> 0:04:40.720
最后就是模型的保存与导出

92
0:04:40.800 --> 0:04:41.720
主要是这三步

93
0:04:41.720 --> 0:04:42.920
而这里面的代码量

94
0:04:42.920 --> 0:04:44.680
确实基本上都是一一对应

95
0:04:44.680 --> 0:04:46.320
你要做很多大量的工程

96
0:04:46.320 --> 0:04:48.600
这里面就是大家各位兄弟们

97
0:04:48.600 --> 0:04:52.080
业以济日去开发的一些工作了

98
0:04:52.080 --> 0:04:54.840
好了今天的内容就到这里为止

99
0:04:54.840 --> 0:04:56.600
我们简单的回顾一下

100
0:04:58.200 --> 0:04:59.960
今天主要是给大家汇报了一下

101
0:04:59.960 --> 0:05:01.960
整个转换模块最内核的

102
0:05:02.160 --> 0:05:03.960
计算图的一个概念

103
0:05:03.960 --> 0:05:06.720
那计算图更重要的主要有三个模块

104
0:05:07.040 --> 0:05:08.640
计算图的两个基本组成

105
0:05:08.880 --> 0:05:09.960
脏量和算子

106
0:05:09.960 --> 0:05:11.760
另外还有图相关的信息

107
0:05:11.760 --> 0:05:13.880
就完成了我们整个计算图的定义

108
0:05:14.720 --> 0:05:15.720
我们中间还穿插了

109
0:05:15.720 --> 0:05:16.720
AI框架的计算图

110
0:05:16.720 --> 0:05:18.480
跟推进引擎的计算图的区别

111
0:05:18.840 --> 0:05:20.200
接着我们去看了一下

112
0:05:20.200 --> 0:05:22.280
转换模块的一个整体的流程

113
0:05:22.720 --> 0:05:25.400
还有它的技术的细节和算法的流程

114
0:05:25.680 --> 0:05:26.480
讲完这个之后

115
0:05:26.680 --> 0:05:29.320
整个转换模块基本上就结束了

116
0:05:30.000 --> 0:05:31.360
我们将会在下一个内容里面

117
0:05:31.520 --> 0:05:35.160
去给大家汇报一下图优化的相关的功能

118
0:05:35.160 --> 0:05:38.520
这些功能也是在我们AI编辑里面比较像的

119
0:05:38.560 --> 0:05:41.320
所以后面应该会过得稍微快一点点

120
0:05:41.640 --> 0:05:42.200
谢谢各位

121
0:05:42.200 --> 0:05:43.000
摆了个掰

122
0:05:44.240 --> 0:05:45.840
卷的不行了

123
0:05:45.840 --> 0:05:47.280
记得一键三连加关注

124
0:05:47.720 --> 0:05:50.680
所有的内容都会开源在下面这条链接里面

125
0:05:51.320 --> 0:05:52.000
摆了个掰

