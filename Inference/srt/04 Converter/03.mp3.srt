0
0:00:00.000 --> 0:00:05.260
啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦

1
0:00:05.260 --> 0:00:09.100
诶诶哦已经开始了啊大家好我是宗米

2
0:00:09.100 --> 0:00:13.320
今天的我们还是模型转换和优化的这个系列里面

3
0:00:13.320 --> 0:00:18.140
今天主要给大家去介绍的一个内容是模型转换的技术细节

4
0:00:18.140 --> 0:00:23.340
就真正的来到我们模型转换怎么转应该怎么去定义自己的计算图

5
0:00:24.380 --> 0:00:29.360
之前有很多好朋友呢建议宗米去讲一些具体的代码不要讲太虚的东西但是呢

6
0:00:29.360 --> 0:00:37.040
总比还是觉得我们也一定要跳出具体的代码跳出具体的工程跳出具体每天编码的事情来看一看

7
0:00:37.040 --> 0:00:44.880
看一看整体的原理看看整体的架构去了解一下看一下不同的AI框架不同的AI编译器不同的推定

8
0:00:44.880 --> 0:00:50.240
其他整体上面有什么差异它使用不同的文件格式有什么不一样的地方

9
0:00:50.240 --> 0:00:55.040
每一个模块每一个流程每个细节我们都应该知道

10
0:00:55.040 --> 0:01:00.320
只有这样我们才能够成为自己是一个AI系统的专家嘛

11
0:01:00.320 --> 0:01:06.880
而不是像我以前聚焦于某一个特性里面知道这个特性应该怎么写这代码我能讲得很明白

12
0:01:06.880 --> 0:01:17.440
而且我可以给你讲代码讲两三个小时但是我那个时候还做不到我能够跳出这个特性出来去看一看这个特性跟其他特性看看整体有什么区别

13
0:01:17.440 --> 0:01:23.360
这也是我希望给大家去汇报或者给大家去掌握的一个思想

14
0:01:23.440 --> 0:01:29.840
其实在上一节课呢我们了解了一下模型转换的一个具体的格式还有相关的内容

15
0:01:30.400 --> 0:01:36.720
今天的我们很重要的一个内容就是了解一下怎么制定一个计算图还有转换的流程和细节

16
0:01:37.920 --> 0:01:45.040
下面我们来看一下计算图的回顾呀既然谈到计算图我们肯定需要去回顾一下什么是计算图

17
0:01:45.040 --> 0:01:55.360
中闵老师你好啊你说要讲计算图但是我想问一下为什么推力引擎需要自定义计算图呢

18
0:01:55.360 --> 0:02:05.920
哎小心又来了一个灵魂问题哦我们可以看到在整个转换模块架构里面呢它分为一个转换模块还有那个图优化嘛

19
0:02:05.920 --> 0:02:13.040
中间是有一个按压或者计算图来去承载的我们会把不同的AI框架呢去对接到同一个按压

20
0:02:13.040 --> 0:02:19.280
那有了这个按压之后呢我们就可以很方便地做一些很多的不同的图优化的工作

21
0:02:19.280 --> 0:02:23.920
那这些图优化的工作呢都是基于一个很重要的概念就是计算图

22
0:02:24.320 --> 0:02:31.440
所以说不管是推力引擎也好AI训练框架也好我们计算图这个概念呢还是非常的重要

23
0:02:31.840 --> 0:02:42.880
于是呢中闵在之前AI框架的分享里面呢就有一个非常详细的系列了去独立地把计算图每一个模块都展开地去详细地给大家去汇报的

24
0:02:43.040 --> 0:03:12.480
那下面呢我们看一下计算图的一个基本的组成啊这个也是AI框架不管现在我们是AI框架还是推力引擎啊它的基本组成都是不变的因为我们的前提的朱雨是计算图嘛那现在我们看一下计算图的具体的组成有两个一个是章量一个是算子章量呢就是整个计算图去流窜的数据或计算图里面去计算的数据而算子呢就是具体的执行的单元

25
0:03:12.480 --> 0:03:16.480
哎中闵老师你好啊我又有个问题了

26
0:03:16.480 --> 0:03:18.640
嘿嘿你说

27
0:03:18.640 --> 0:03:24.000
AI框架的计算图和推力引擎的计算图有什么不同吗

28
0:03:24.000 --> 0:03:34.320
哎这个问题确实问得挺好的这也是我应该总结了好一段时间的这个表呢确实我总结了挺久的有有十来分钟

29
0:03:34.320 --> 0:03:41.840
下面呢我们看一下AI框架计算图还有推力引擎的计算图呢我们对比了几个维度一个是它的一个组成

30
0:03:41.840 --> 0:03:46.480
接着是正反向动静态图还有分布式并行还有具体的使用场景

31
0:03:46.480 --> 0:04:00.720
那可以看到计算图的组成AI框架的计算图和推力引擎的计算图其实是差不多的但是呢有一个很大的区别就是推力引擎更多的是聚焦于我们做一个分网前向的计算不需要分网就不需要有反向了

32
0:04:00.720 --> 0:04:09.440
而在动静态图里面呢确实AI框架它需要支持非常灵活的动态读者写法但是呢有时候在训练过程中我们希望它越快越好

33
0:04:09.440 --> 0:04:27.760
于是呢会有一个动静转移或者动静统一或者动静态图都支持的情况而推力引擎的大部分都是以静态图为主啊基本上我们在推力引擎不希望它是一个动态图动态图对我们的推力引擎的时间的消耗对我们的温碳的调度还有颗粒的调度确实非常的不友好

34
0:04:27.760 --> 0:04:36.200
所以我们一般都会把它转为静态图去进行执行的话大家一定要注意这个点就是一个forward一个静态图接着呢分布式并行

35
0:04:36.200 --> 0:05:06.200
我们之前确实有三个系列去单独的去汇报了给大家AI框架的计算图到底是怎么样去切分的我们应该有哪些策略但是呢在推力引擎啊我们大部分都是以单卡的推理服务为主很少去考虑分布式的推理确实分布式的推理至少呃中米在从业这么多年没有遇到过太多相关的工作有是有但是基本上很少很少客户大部分都是创新的场景那最后一个就是看一下AI框架的计算图呢更多的是指

36
0:05:06.200 --> 0:05:36.200
训练的场景支持科研的创新对网络模型的训练的微调啊提升算法为主但是推力引擎呢确实它比较特别它的计算图呢主要是支持工业级的应用的部署对外提供服务所以说因为这些特殊的原因所以呢推力引擎呢有自己的计算图的定义当然它也可以附用AI框架计算图的定义这个也是马斯破端一统一的一个概念废话呢我们就不多说了我们继续往下看一看

37
0:05:36.200 --> 0:05:37.200
那接下来呢我们看一下推力引擎呢到底怎么样去定一个计算图的计算图的最基本应该有哪些结构这里面呢我就会带着大家去看一看具体的代码下面我们来回顾一下重新回顾一下计算图有两个组成第一个就是张亮探测第二个呢就是operation算子我们的执行单元下面我们就不看slide了就不看PPT了而转到具体的代码

38
0:06:06.200 --> 0:06:36.200
原亮宗米的鼠标呢一直都是比较大的我也被很多人吐槽过说我已经是老人眼了确实鼠标大一点好看了这是谁干的我建议大家都把自己的鼠标调大一点确实很方便很舒服那现在我们回到推力引擎计算图的一个探测张亮的表示首先我们张亮呢肯定要定义自己的数据结构证明我们的推力引擎里面支持哪几种的数据的运行的方式那一般呢

39
0:06:36.200 --> 0:07:06.200
计定义的鲍勒佛鲁特啦英特三说这些跟传统的计算机没什么区别我们叫做data type那接着要定一个非常重要的内容了就是数据的排布在AI编译器前端优化里面呢确实我们提到单独提到过数据的排布而且开了两节课去给大家去介绍了大概二十分钟这里面的包括NCHW了NHWC了NCHWC零了NDR不同的格式呢我们确实需要声明的就告诉我们的AI框架或告诉我们的算子

40
0:07:06.200 --> 0:07:36.200
实行的到底是一个什么样的数据的排布那有了这两个之后呢我们还要定义我们的张亮那张亮呢就会比较简单这里面的内容不太多第一个呢就是张亮的dims张亮的shape他到底是一个什么样的形态接着呢我们就会有一个data formatdata format就是我们刚才所定义的这个data format到底是NCHW还是NHWC另外还有data typedata type呢就默认了你是使用IP三时候IP十六还是硬的八

41
0:07:36.200 --> 0:08:06.200
最简单的一个FBS就fact buffer的定义呢我们就完成了整个对张亮的定义了下面呢我们就来看一看推定引擎里面对算子的定义那算子定义呢我们同样去看看具体的代码算子的定义呢可能跟张亮不太一样因为我们要对接到很多不同的AI框架里面同一个算子派托许的定义可能跟探索富的定义不太一样也有可能跟脉搏三个AI框架

42
0:08:06.200 --> 0:08:07.800
定义都不太一样

43
0:08:07.800 --> 0:08:12.200
所以在推定引擎里面呢对于每一个算子呢都需要有一个独立的定义

44
0:08:12.200 --> 0:08:23.760
于是呢我们用table卷计二d然后把一些最基本的padding啊kernel啊stride啊dilation啊padmore还有group还有pad的一些方式把它定义出来

45
0:08:23.760 --> 0:08:31.760
具体呢就通过工程性的代码或者我们的converter模块把不同的AI框架的一些参数呢对应到我们自己的一个定义里面

46
0:08:31.760 --> 0:08:36.360
那有了具体的算子那可能这算子有非常多哦

47
0:08:36.360 --> 0:08:39.360
然后呢需要高速推定请我们现在支持哪些算子

48
0:08:39.360 --> 0:08:48.160
于是呢有个optype有个算子的列表有constant的concaten的卷积的dll卷积的matmall有非常非常多的算子

49
0:08:48.160 --> 0:08:55.920
但是呢这些算子啊其实我建议啊一般控制在两百到三百个之间基本上能够复盖百分之九十五的场景

50
0:08:55.920 --> 0:09:01.200
像像派托许里面呢就有一千两百多个算子谭子沪里面呢就一千五百多个算子

51
0:09:01.200 --> 0:09:04.960
其实很多时候在推定引擎啊真的没有必要塞那么多算子

52
0:09:04.960 --> 0:09:08.680
一个算子具体实现的时候呢就可能有好几个kernel

53
0:09:08.680 --> 0:09:14.920
这会非常影响我们整个推定引擎的大小的推定引擎我们要真正部署在端侧嘛肯定是越小越好

54
0:09:14.920 --> 0:09:26.560
接着呢我们会有一些算子的公共的属性例如axes呢学补了size呢还有一些while if else特殊含义的算子或者特殊含义的一些属性参数

55
0:09:26.560 --> 0:09:29.440
那下面这个呢才是算子真正的定义

56
0:09:29.440 --> 0:09:38.880
算子的定义呢我们就需要告诉这个算子它有多少个输入有多少个输出这里面的命呢是属于哪个公共的属性

57
0:09:38.880 --> 0:09:49.000
另外呢它的type属属于哪一个算子呢我批type呢我们就可以在这里面去找到通过这种方式呢去声明我们整个算子的定义

58
0:09:51.360 --> 0:09:59.160
回到我们的PPT里面那接下来有一个很重要的内容就是计算图的表示

59
0:09:59.160 --> 0:10:16.800
我们刚才说计算图主要是由算子跟张量来组成嘛但是图这个概念还是要有的你不能把它拆开里面具体的内容我们现在来看看它的图的定义那图呢其实我们有两个一个是定义网络模型的子图一个是定义整个网络模型

60
0:10:18.320 --> 0:10:29.120
像一些分类的网络模型呢确实我们有一个网络模型一个net就好了就没有子图但是我们在具体工程或者具体实现的过程当中呢遇到if else while啊for的这些

61
0:10:29.160 --> 0:10:59.160
我们就会拆开成为子图这个呢也是在之前的计算图概念呢去给大家普及过的我们看一下模型怎么定义那这里面有个net在存储的时候呢我们就需要去定义这个网络模型的叫什么名字它的输入的tensor的名字它的output的tensor的名字方便我们去做一个代码的控制另外呢还需要告诉我们这个网络模型有哪些算子这个算子的列表呢是一个list这个list呢就告诉我们应该先执行哪一个顺子后执行哪一个算子算子跟算子之间

62
0:10:59.160 --> 0:11:29.160
的一个关系呢就是通过刚才我们定义的根据input index跟up index去检索相关的边那最后呢就有一个subgraph有没有子图有子图的话就去调用下面一个子图啦像遇到if else这种呢确实它就会产生不同的子图那子图呢也有自己的名字也有自己的输入输出当然了还有一个notes的op啊就op list呢其实呢跟上面的网络模型的定义差不多它只是一个简单的子图可能信息呢会比整个大图呢会稍微

63
0:11:29.160 --> 0:11:33.240
少一点没有那么多冗余的信息当然了我们这里面有很多点点点

64
0:11:33.240 --> 0:11:37.360
就告诉大家其实这里面还可以塞很多不同的相关的信息

65
0:11:38.800 --> 0:11:47.720
了解完怎么通过flat buffer和了portal buffer去自定义一个计算图之后呢我们现在来回头来看看整体的流程

66
0:11:47.720 --> 0:11:51.880
整体流程呢首先我们需要构建一个计算图的ir

67
0:11:51.880 --> 0:11:56.960
那刚才呢我就已经以伪代码带着大家去构建自己的一个计算图的ir

68
0:11:56.960 --> 0:12:02.560
这个更重要的是需要结合我们自己的一个推进引擎的突出性还有竞争力去构建的

69
0:12:02.560 --> 0:12:12.480
那第二步呢确实是更多的是工程化的工作了去解析训练模型就我们AI框架不同的框架导出来的模型

70
0:12:12.480 --> 0:12:22.160
第三步呢就是深层自定义的计算图这里面呢就是通过flat buffer或者portal buffer的API呢来去对接到对应的计算图

71
0:12:22.160 --> 0:12:29.880
那我们看一下右边的这两个图右边的这个图你大家可以看到非常的长就是我用钢材定义的一个伪代码吧

72
0:12:29.880 --> 0:12:36.520
然后呢写了一个外思耐五零的网络模型右边的这个呢就是其中一小段的展开

73
0:12:38.040 --> 0:12:45.920
卷得不行了卷得不行了记得一键三连加关注哦所有的内容都会开源在下面这条链接里面摆了个掰

