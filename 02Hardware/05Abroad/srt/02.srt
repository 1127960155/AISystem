1
00:00:01,266 --> 00:00:03,700
字幕生成：mkwei  字幕校准：mkwei

2
00:00:05,000 --> 00:00:05,733
哈喽大家好

3
00:00:05,733 --> 00:00:07,166
我是你们胖胖的ZOMI

4
00:00:07,166 --> 00:00:08,600
减肥真的没那么容易

5
00:00:08,600 --> 00:00:10,333
每块肉都有他的脾气

6
00:00:10,333 --> 00:00:10,766
今天呢

7
00:00:10,766 --> 00:00:14,366
我们来到了AI芯片里面的NPU详解

8
00:00:15,300 --> 00:00:16,900
根据我们上一节的内容呢

9
00:00:16,900 --> 00:00:20,100
讲了特斯拉DOJO里面的整体的概念

10
00:00:20,100 --> 00:00:20,566
之后呢

11
00:00:20,566 --> 00:00:23,100
今天我们看一下DOJO里面的核心

12
00:00:23,133 --> 00:00:24,766
也就是DOJO Core

13
00:00:25,200 --> 00:00:26,400
现在呢我们回顾一下

14
00:00:26,400 --> 00:00:27,933
在整个系列课程里面呢

15
00:00:27,933 --> 00:00:31,133
我们已经处于AI专用处理器里面的

16
00:00:31,133 --> 00:00:32,066
第三个内容

17
00:00:32,266 --> 00:00:33,466
DOJO的架构

18
00:00:33,500 --> 00:00:35,866
那我们在整个DOJO的系列里面呢

19
00:00:35,866 --> 00:00:37,766
之前讲了DOJO的整体的架构

20
00:00:37,766 --> 00:00:40,100
今天我们深入的来到了DOJO Core

21
00:00:40,100 --> 00:00:43,400
我们会分开4个内容给大家去汇报的

22
00:00:43,400 --> 00:00:45,533
第一个呢就是DOJO Core的整体的架构

23
00:00:45,533 --> 00:00:48,266
然后我们看一下DOJO Core的前端的处理

24
00:00:48,533 --> 00:00:48,900
接着呢

25
00:00:48,900 --> 00:00:51,366
我们去看一下DOJO Core的执行引擎

26
00:00:51,366 --> 00:00:53,666
最后呢我们看一下DOJO Core里面的SRAM

27
00:00:53,666 --> 00:00:54,600
和它的内存

28
00:00:54,600 --> 00:00:56,166
到底是怎么去排布的

29
00:00:56,166 --> 00:00:59,600
因为DOJO它属于一个存算一体的架构

30
00:00:59,600 --> 00:01:02,900
这里面的SRAM的内存呢就很有意思了

31
00:01:04,066 --> 00:01:06,100
在正式进入DOJO Core之前呢

32
00:01:06,100 --> 00:01:07,900
我想跟大家一起去回顾一下

33
00:01:07,900 --> 00:01:10,300
DOJO的整个整体的结构

34
00:01:10,366 --> 00:01:10,866
首先呢

35
00:01:10,866 --> 00:01:13,666
DOJO采用的是一个存算一体的架构

36
00:01:13,666 --> 00:01:14,400
这个架构呢

37
00:01:14,400 --> 00:01:15,100
就决定了

38
00:01:15,100 --> 00:01:17,600
DOJO Core里面的核应该长什么样子

39
00:01:17,600 --> 00:01:20,866
他们之间的通讯应该长什么样子

40
00:01:20,966 --> 00:01:23,066
下面呢我们看一下整体的一个概念

41
00:01:23,066 --> 00:01:25,100
今天我们的内容呢就是在这里面

42
00:01:25,266 --> 00:01:29,100
DOJO Core里面的片上SRAM呢有1.25MB

43
00:01:29,100 --> 00:01:31,300
整体的算力其实并不多

44
00:01:31,300 --> 00:01:33,533
但是呢我们的DOJO的D1呢

45
00:01:33,533 --> 00:01:36,866
有354个DOJO Core来去组成的

46
00:01:36,866 --> 00:01:38,400
为什么不是360

47
00:01:38,400 --> 00:01:41,366
个呢是因为它有容错率

48
00:01:41,666 --> 00:01:43,400
接着呢我们看一下DOJO Tile

49
00:01:43,400 --> 00:01:44,600
里面的训练芯片呢

50
00:01:44,600 --> 00:01:46,700
主要是由5乘以5

51
00:01:46,700 --> 00:01:49,866
也就是25个DOJO的D1组成整个Tile

52
00:01:50,300 --> 00:01:52,700
一个Tile呢对应的是一块A100

53
00:01:52,700 --> 00:01:53,933
这么一块芯片

54
00:01:54,200 --> 00:01:56,566
六个Tile呢就组成了一个主机

55
00:01:56,866 --> 00:01:58,533
两个主机呢组成一个机柜

56
00:01:58,533 --> 00:02:01,666
每十个机柜呢就形成一个ExaPOD

57
00:02:02,000 --> 00:02:03,466
这么一个组成的方式

58
00:02:03,800 --> 00:02:04,366
在这里面呢

59
00:02:04,366 --> 00:02:05,466
很有意思的一点就是

60
00:02:05,466 --> 00:02:08,266
DOJO Core可以把它完全当成一个小型

61
00:02:08,266 --> 00:02:09,666
或者微型的PC

62
00:02:09,700 --> 00:02:10,500
每个DOJO Core呢

63
00:02:10,500 --> 00:02:13,166
都可以自己独立的去执行他的任务

64
00:02:13,166 --> 00:02:15,100
不依赖于共享的cache

65
00:02:15,100 --> 00:02:17,100
或者我们的寄存器

66
00:02:17,100 --> 00:02:19,466
整个D1呢作为DOJO的Super Scalar呢

67
00:02:19,466 --> 00:02:22,166
里面有354个DOJO Core嘛

68
00:02:22,166 --> 00:02:24,266
这意味着特斯拉可以使用更多的线程

69
00:02:24,266 --> 00:02:25,900
来驱动更多的指令

70
00:02:26,100 --> 00:02:30,000
通过DOJO Core来执行更多的计算任务

71
00:02:30,400 --> 00:02:32,966
下面呢我们来到了第一个内容

72
00:02:32,966 --> 00:02:35,666
就是DOJO Core的整体结构

73
00:02:36,300 --> 00:02:37,166
下面我们看一下

74
00:02:37,166 --> 00:02:40,466
左边的是DOJO Core的一些主要的参数

75
00:02:40,466 --> 00:02:42,800
右边的这个DOJO Core的核心的架构图

76
00:02:42,800 --> 00:02:43,466
我们可以看到

77
00:02:43,466 --> 00:02:45,500
数据格式是支持的非常的多的

78
00:02:45,500 --> 00:02:48,000
而位宽就bit width呢是64b

79
00:02:48,266 --> 00:02:49,200
整体的MM呢

80
00:02:49,200 --> 00:02:51,666
我觉得最重要的是这个MM的单元

81
00:02:51,666 --> 00:02:54,900
也就是矩阵乘的单元有4路8乘以8

82
00:02:55,366 --> 00:02:57,733
里面另外两个很重要的指标

83
00:02:57,733 --> 00:02:59,400
就是SRAM的size

84
00:02:59,400 --> 00:03:00,700
是1.25MB

85
00:03:00,733 --> 00:03:01,800
那SRAM的rate呢

86
00:03:01,800 --> 00:03:04,766
就是它的读写速率呢是400GB每秒

87
00:03:05,066 --> 00:03:06,366
写呢是200GB每秒

88
00:03:06,366 --> 00:03:08,466
也就是我们读的更多

89
00:03:08,466 --> 00:03:09,500
写的更少

90
00:03:09,533 --> 00:03:11,766
是因为我们需要大量的数据去读取

91
00:03:11,766 --> 00:03:12,766
然后写入

92
00:03:12,800 --> 00:03:14,400
计算完之后写入单一个

93
00:03:14,400 --> 00:03:15,800
或少量的数据

94
00:03:15,933 --> 00:03:16,733
那这里面呢

95
00:03:16,733 --> 00:03:19,166
最重要的是我刚才讲到的SRAM size

96
00:03:19,333 --> 00:03:20,866
还有MatMul

97
00:03:20,866 --> 00:03:23,066
就是我们的矩阵乘里面的大小

98
00:03:23,100 --> 00:03:25,066
另外的话SMT有四路

99
00:03:25,066 --> 00:03:26,800
这个呢也是比较重要的概念

100
00:03:27,133 --> 00:03:27,366
后面呢

101
00:03:27,366 --> 00:03:29,733
我们会详细的介绍这些参数的意义

102
00:03:29,733 --> 00:03:30,600
下面我们看一下

103
00:03:30,600 --> 00:03:33,400
整个DOJO Core的结构和特点呢

104
00:03:33,533 --> 00:03:35,133
实际上每个DOJO Core的核心呢

105
00:03:35,133 --> 00:03:36,933
就是这里面的Execution Engine呢

106
00:03:37,066 --> 00:03:39,066
实际上呢每个DOJO Core的核心呢

107
00:03:39,066 --> 00:03:41,800
它是具有Scalar和Vector

108
00:03:41,800 --> 00:03:44,666
也就是向量和标量计算单元的能力

109
00:03:44,666 --> 00:03:46,266
而这里面Scalar、Vector呢

110
00:03:46,266 --> 00:03:48,600
它自己又具备整体的取指

111
00:03:48,600 --> 00:03:50,366
译码、执行的部件

112
00:03:50,466 --> 00:03:51,100
所以呢

113
00:03:51,100 --> 00:03:53,466
整个DOJO Core的核心呢是非常完善的

114
00:03:53,533 --> 00:03:56,000
不要看着DOJO Core的整体的晶体管很少

115
00:03:56,000 --> 00:03:57,066
或者部件很少呢

116
00:03:57,066 --> 00:03:58,666
就觉得它的作用不大

117
00:03:59,133 --> 00:04:00,600
接下来我们整体的去看看

118
00:04:00,600 --> 00:04:02,733
DOJO Core的一个整体的结构

119
00:04:02,733 --> 00:04:05,400
首先呢它有三部分或者四部分组成哦

120
00:04:05,533 --> 00:04:07,666
第一部分呢就是Front End前端

121
00:04:07,700 --> 00:04:10,366
接着呢就是真正的执行引擎

122
00:04:10,366 --> 00:04:10,900
另外的话

123
00:04:10,900 --> 00:04:13,700
我们还有一个SRAM里面的memory

124
00:04:13,733 --> 00:04:17,066
最后呢还有一个NOC的路由

125
00:04:17,066 --> 00:04:17,966
NOC的route

126
00:04:18,300 --> 00:04:21,533
相比CPU和GPU的控制部件呢它都更少

127
00:04:21,533 --> 00:04:24,166
就整个DOJO Core呢是非常的精简的

128
00:04:24,166 --> 00:04:26,400
但是呢这里面很核心的就是

129
00:04:26,400 --> 00:04:28,166
它有一个MatMul的计算单元

130
00:04:28,400 --> 00:04:30,533
类似于英伟达里面的Tensor core

131
00:04:30,533 --> 00:04:31,666
矩阵计算单元

132
00:04:32,133 --> 00:04:34,666
不过呢DOJO Core确实非常非常的精简

133
00:04:34,700 --> 00:04:35,300
这里面呢

134
00:04:35,300 --> 00:04:35,866
可以看到

135
00:04:35,866 --> 00:04:38,133
他所有的部件还是非常的少的

136
00:04:38,266 --> 00:04:39,866
里面呢就取消了Rename

137
00:04:39,866 --> 00:04:42,733
非常多的改善部件利用率的一些组件

138
00:04:42,733 --> 00:04:45,100
同时呢也不支持虚拟的内存

139
00:04:45,133 --> 00:04:45,766
所以这里面呢

140
00:04:45,766 --> 00:04:48,333
用的SRAM里面存的是实际的物理的地址

141
00:04:48,333 --> 00:04:49,400
这样做的意义呢

142
00:04:49,400 --> 00:04:51,966
就是希望能够减少控制部件

143
00:04:51,966 --> 00:04:53,066
所占用的面积

144
00:04:53,066 --> 00:04:56,733
把更多的面积留给我们这里面的MatMul

145
00:04:56,800 --> 00:05:00,000
还有ALU那可能MatMul占的更多

146
00:05:00,000 --> 00:05:04,200
把更多的芯片的面积留给我们的计算

147
00:05:04,533 --> 00:05:05,000
另外一点呢

148
00:05:05,000 --> 00:05:07,866
就是提供了一个比较大的SRAM

149
00:05:07,866 --> 00:05:09,200
所以呢我们可以看到

150
00:05:09,200 --> 00:05:11,366
整个DOJO Core的架构里面呢

151
00:05:11,400 --> 00:05:14,200
Matmal就是我们的计算单元跟SRAM

152
00:05:14,200 --> 00:05:15,000
存储单元

153
00:05:15,000 --> 00:05:17,866
决定了整个DOJO Core的计算的能效比

154
00:05:18,133 --> 00:05:19,366
既然谈到存储了

155
00:05:19,366 --> 00:05:21,566
也就是我们的Memory Subsystem呢

156
00:05:21,566 --> 00:05:23,400
呃有一点非常值得注意的

157
00:05:23,400 --> 00:05:25,166
就是DOJO上面运行的代码了

158
00:05:25,166 --> 00:05:27,466
实际上不能够直接访问我们的系统

159
00:05:27,466 --> 00:05:29,566
内存的整个DOJO Core里面的Memory呢

160
00:05:29,566 --> 00:05:32,100
只能访问自己的SRAM跟Tensorcore

161
00:05:32,100 --> 00:05:33,733
跟英伟达的整体的架构呢

162
00:05:33,733 --> 00:05:35,266
是完全不一样的

163
00:05:35,266 --> 00:05:37,700
里面有非常多的共享的内存呢

164
00:05:37,700 --> 00:05:38,566
global memory呢

165
00:05:38,566 --> 00:05:39,600
还有local memory呢

166
00:05:39,600 --> 00:05:40,766
这里面都没有

167
00:05:40,800 --> 00:05:42,333
只有一小部分的SRAM

168
00:05:42,333 --> 00:05:45,500
能够给我们的MatMul进行计算和存储

169
00:05:45,800 --> 00:05:47,700
而整个DOJO Core的本地的SRAM呢

170
00:05:47,700 --> 00:05:50,066
完全是由我们的编译器去进行管理

171
00:05:50,066 --> 00:05:51,533
不能用作缓存

172
00:05:51,533 --> 00:05:53,266
这个概念是非常的重要

173
00:05:54,200 --> 00:05:55,266
了解完整体之后呢

174
00:05:55,266 --> 00:05:56,933
接下来我们来到了第二个内容

175
00:05:56,933 --> 00:05:59,300
DOJO Core的前端处理

176
00:05:59,300 --> 00:06:00,566
我们的Front End

177
00:06:01,533 --> 00:06:03,266
在整个Front End的前端模块

178
00:06:03,266 --> 00:06:05,766
也就是我们右边的架构图里面

179
00:06:05,766 --> 00:06:07,766
黄色的这一小部分呢

180
00:06:08,366 --> 00:06:10,366
一进来的第一个模块呢就是BTB

181
00:06:10,366 --> 00:06:13,600
我们的分支目标缓冲区

182
00:06:13,900 --> 00:06:15,766
BTB最重要的工作呢就是

183
00:06:15,766 --> 00:06:18,066
通过预测我们程序里面的分支的路径

184
00:06:18,066 --> 00:06:20,000
还有缓冲分支的使用的信息

185
00:06:20,000 --> 00:06:21,100
来减少我们流水线

186
00:06:21,100 --> 00:06:24,100
处理器里面的分支的性能的损失

187
00:06:24,933 --> 00:06:26,133
在BTB下面呢

188
00:06:26,133 --> 00:06:29,100
就有一个内容或者一个小的模块

189
00:06:29,100 --> 00:06:29,933
叫做PC

190
00:06:30,266 --> 00:06:33,700
是计算机组成原理里面的程序计数器

191
00:06:34,000 --> 00:06:36,100
对程序指令呢进行计数的

192
00:06:36,100 --> 00:06:38,266
再往下呢就是I-Cache呢

193
00:06:38,266 --> 00:06:40,300
这个就是L1的指令缓存

194
00:06:40,566 --> 00:06:41,966
整个L1的指令缓存呢

195
00:06:41,966 --> 00:06:44,500
直接跟DOJO Core里面的SRAM

196
00:06:44,500 --> 00:06:45,533
是直接相连的

197
00:06:45,533 --> 00:06:46,900
去获取计算

198
00:06:47,133 --> 00:06:49,100
接下来要进行计算的指令

199
00:06:49,133 --> 00:06:50,700
接着呢就有Fetch buffer

200
00:06:50,700 --> 00:06:52,300
这里面呢就是取指器

201
00:06:52,300 --> 00:06:54,200
而这里面呢乘以4就是有4路

202
00:06:54,400 --> 00:06:56,500
最多呢可以容纳8条指令

203
00:06:56,533 --> 00:06:59,133
再往下的decoder呢就是我们的译码

204
00:06:59,766 --> 00:07:00,400
译码器呢

205
00:07:00,400 --> 00:07:03,466
从取值缓冲区里面呢获取到指令呢

206
00:07:03,466 --> 00:07:04,566
并对它进行译码呢

207
00:07:04,566 --> 00:07:06,333
根据每一条指令的要求呢

208
00:07:06,333 --> 00:07:08,400
分配所需要的执行的单元

209
00:07:08,933 --> 00:07:10,366
假设Scalar假设Vector的时候呢

210
00:07:10,366 --> 00:07:11,966
它就会对它进行分发

211
00:07:11,966 --> 00:07:13,100
分配主要的单元

212
00:07:13,100 --> 00:07:14,000
这里面呢

213
00:07:14,000 --> 00:07:15,266
上面的这些模块呢

214
00:07:15,266 --> 00:07:16,700
就是我们的前端的模块

215
00:07:16,733 --> 00:07:18,966
接下来就是线程的调度呢

216
00:07:18,966 --> 00:07:21,900
线程调度呢就是往下面的内容

217
00:07:21,900 --> 00:07:27,000
我们的Scalar Scheduler还有SMT Vector schedule了

218
00:07:27,000 --> 00:07:28,933
这里面呢都是做一些调度的

219
00:07:28,933 --> 00:07:31,600
分别指向我们的Scalar跟Vector

220
00:07:31,600 --> 00:07:33,200
里面的具体的计算

221
00:07:33,300 --> 00:07:35,900
那在整个前端模块里面呢

222
00:07:36,366 --> 00:07:39,200
一旦BTB呢生成下一条指令的时候呢

223
00:07:39,366 --> 00:07:39,933
DOJO Core

224
00:07:39,933 --> 00:07:41,366
在每个时钟周期内呢

225
00:07:41,366 --> 00:07:43,666
就会从我们的L1 Cache里面呢

226
00:07:43,666 --> 00:07:44,800
去获取具体的指令

227
00:07:44,800 --> 00:07:45,700
给到我们的buffer

228
00:07:45,700 --> 00:07:47,766
然后呢decode就会对我

229
00:07:47,766 --> 00:07:49,933
们的buffer呢进行译码整体的工作

230
00:07:49,933 --> 00:07:52,900
原理呢就是像刚才所讲到的

231
00:07:54,333 --> 00:07:54,866
接下来呢

232
00:07:54,866 --> 00:07:56,733
我们来到了第三个内容

233
00:07:56,733 --> 00:07:59,366
就是DOJO的执行引擎

234
00:07:59,366 --> 00:08:02,700
也就是里面最核心的计算单元

235
00:08:02,800 --> 00:08:03,400
计算单元呢

236
00:08:03,400 --> 00:08:06,566
就是我们下面绿色的这个模块

237
00:08:06,600 --> 00:08:08,466
针对Scalar和Vector呢

238
00:08:08,466 --> 00:08:11,000
都有四路的SMT啊

239
00:08:11,700 --> 00:08:14,333
下面呢我们来打开一下整个执行引擎

240
00:08:14,333 --> 00:08:16,866
也就是呃红色的这个模块

241
00:08:16,866 --> 00:08:18,366
还有紫色的这个模块

242
00:08:18,400 --> 00:08:20,266
具体的计算的方式

243
00:08:21,100 --> 00:08:21,866
下面我们看一下

244
00:08:21,866 --> 00:08:24,466
执行引擎里面的最重要的计算的单元

245
00:08:24,466 --> 00:08:26,133
也就是执行单元里面呢

246
00:08:26,133 --> 00:08:27,600
有两路的ALU

247
00:08:27,600 --> 00:08:29,333
有两路的AGU

248
00:08:29,400 --> 00:08:32,766
当然啦还有512位的SIMD

249
00:08:32,900 --> 00:08:33,566
另外的话

250
00:08:33,566 --> 00:08:35,000
还有一个最重要最重要的

251
00:08:35,000 --> 00:08:37,866
就是里面DOJO最核心的MatMul

252
00:08:37,866 --> 00:08:40,600
8*8*4的这么一个矩阵的计算

253
00:08:40,900 --> 00:08:42,266
现在呢我们分开来看一下

254
00:08:42,266 --> 00:08:43,466
ALU跟AGU呢

255
00:08:43,466 --> 00:08:46,566
主要是负责除了矩阵计算以外的

256
00:08:46,566 --> 00:08:49,133
一些少量的逻辑的运算

257
00:08:49,133 --> 00:08:51,966
那AGU呢主要是负责地址的生成单元

258
00:08:51,966 --> 00:08:53,166
而ALU啊

259
00:08:53,166 --> 00:08:54,900
大家不用我讲都知道啦

260
00:08:54,900 --> 00:08:57,133
主要负责简单的加减乘除这些工作

261
00:08:57,400 --> 00:08:59,800
另外的话我们看一下第二个内容

262
00:08:59,800 --> 00:09:01,666
或者第二个简单的执行模块

263
00:09:01,666 --> 00:09:03,200
就是SIMD

264
00:09:03,300 --> 00:09:04,800
负责例如激活呀

265
00:09:04,800 --> 00:09:07,600
softmax啊这些简单的计算的

266
00:09:07,800 --> 00:09:09,933
最后呢也是最核心的MatMul

267
00:09:09,933 --> 00:09:12,966
我们的矩阵计算单元主要负责呃

268
00:09:12,966 --> 00:09:15,566
类似于现在大模型非常火的Transformer

269
00:09:15,566 --> 00:09:17,133
包括以前呃

270
00:09:17,133 --> 00:09:18,933
比较火的一些卷积的

271
00:09:18,933 --> 00:09:21,066
核心的矩阵的计算

272
00:09:21,366 --> 00:09:22,900
在执行单元里面的整体加构

273
00:09:22,900 --> 00:09:24,266
里面很有意思的一点呢

274
00:09:24,266 --> 00:09:26,466
就是DOJO的分开两个

275
00:09:26,466 --> 00:09:28,400
第一个呢是Scalar的

276
00:09:28,400 --> 00:09:33,366
scheduler一个呢是Vector的scheduler

277
00:09:33,366 --> 00:09:34,500
那分开两个呢

278
00:09:34,500 --> 00:09:37,066
也就是两条执行的pipeline

279
00:09:37,066 --> 00:09:38,933
一条呢是执行向量的计算

280
00:09:38,933 --> 00:09:41,333
一条呢是执行矩阵的计算

281
00:09:41,900 --> 00:09:43,300
一旦指令发起之后呢

282
00:09:43,300 --> 00:09:45,166
我们的数据就会从SRAM里面

283
00:09:45,166 --> 00:09:47,966
传送到我们具体的Scalar Register里面

284
00:09:47,966 --> 00:09:49,900
或者Vector的Register里面

285
00:09:49,933 --> 00:09:51,200
最后呢计算完之后呢

286
00:09:51,200 --> 00:09:52,700
就会把我们的数据呢

287
00:09:52,700 --> 00:09:55,766
回传到我们的SRAM上面

288
00:09:55,800 --> 00:09:56,900
整体的计算逻辑

289
00:09:56,900 --> 00:09:59,300
就是像我们刚才所描述的那样

290
00:09:59,566 --> 00:10:01,500
刚才讲到的数据的计算和存储呢

291
00:10:01,500 --> 00:10:03,500
就构成了我们整个DOJO Core里面

292
00:10:03,566 --> 00:10:04,300
最重要的类

293
00:10:04,300 --> 00:10:05,900
和数据搬运或者最重要类

294
00:10:05,900 --> 00:10:08,766
和DOJO Core里面的功耗的一大部分

295
00:10:09,700 --> 00:10:10,333
接下来呢

296
00:10:10,333 --> 00:10:13,666
ZOMI就找到google patent里面

297
00:10:13,700 --> 00:10:15,700
特斯拉发的几篇专利

298
00:10:15,700 --> 00:10:16,800
那这几篇专利呢

299
00:10:16,800 --> 00:10:18,933
全部都是围绕着刚才讲到的

300
00:10:18,933 --> 00:10:20,200
矩阵的计算单元

301
00:10:20,400 --> 00:10:22,133
这个矩阵计算单元呢很有意思

302
00:10:22,133 --> 00:10:27,566
就是不管是横和竖都是一个8*8的矩阵

303
00:10:27,566 --> 00:10:28,700
而这里面的输入呢

304
00:10:28,700 --> 00:10:30,900
有两个一个是呢普通的data输入

305
00:10:30,900 --> 00:10:32,866
一个呢是我们的Weight的输入

306
00:10:32,866 --> 00:10:33,933
就权重的输入

307
00:10:34,400 --> 00:10:35,066
每个DOJO Core呢

308
00:10:35,066 --> 00:10:37,933
就包括4路的8*8的矩阵的计算

309
00:10:37,966 --> 00:10:38,900
在计算完之后呢

310
00:10:38,900 --> 00:10:40,900
就会有一个post process Unit

311
00:10:40,900 --> 00:10:42,600
也就是后处理的单元

312
00:10:42,733 --> 00:10:45,766
专门去做一些累加呀或者激活的功能

313
00:10:46,366 --> 00:10:47,000
而这里面呢

314
00:10:47,000 --> 00:10:48,200
整个的计算流程呢

315
00:10:48,200 --> 00:10:50,933
是由左边里面的control Unit

316
00:10:50,933 --> 00:10:52,600
去做一个总体的控制的

317
00:10:52,666 --> 00:10:54,000
那讲完这个之后呢

318
00:10:54,000 --> 00:10:56,133
我们来到了第四个内容

319
00:10:56,133 --> 00:10:58,166
也就是这个视频分享里面的

320
00:10:58,166 --> 00:10:59,266
最后一个内容了

321
00:10:59,266 --> 00:11:02,333
SRAM跟内存之间的一个关系

322
00:11:02,333 --> 00:11:03,466
还有整个DOJO Core里面

323
00:11:03,466 --> 00:11:04,300
的一个关系

324
00:11:05,400 --> 00:11:07,766
今天呢我们稍微拖一拖堂

325
00:11:07,766 --> 00:11:10,133
然后把最后一个内容给他讲完了

326
00:11:10,200 --> 00:11:12,066
那在第四部分呢

327
00:11:12,066 --> 00:11:14,733
就是我们的SRAM跟我们的中间的路由嘛

328
00:11:14,733 --> 00:11:18,066
说白了路由其实为的就是传输数据

329
00:11:18,066 --> 00:11:21,200
而数据呢是存在SRAM里面的

330
00:11:21,400 --> 00:11:22,300
在DOJO Core里面呢

331
00:11:22,300 --> 00:11:24,133
每个节点也就是每个DOJO Core里面呢

332
00:11:24,133 --> 00:11:26,900
一共有1.25MB的SRAM

333
00:11:26,933 --> 00:11:27,766
之所以说DOJO Core

334
00:11:27,766 --> 00:11:29,700
是一个存算一体的架构呢

335
00:11:29,700 --> 00:11:31,366
是因为这里面把SRAM呢

336
00:11:31,366 --> 00:11:34,066
跟我们的MatMul里面的矩阵乘

337
00:11:34,200 --> 00:11:35,100
是放在一起

338
00:11:35,100 --> 00:11:38,066
最大限度的去减少我们数据的搬运

339
00:11:38,066 --> 00:11:40,066
也就是memory bound的这个限制

340
00:11:40,333 --> 00:11:41,933
有了这种架构的定义之后呢

341
00:11:41,933 --> 00:11:43,500
我们的应用程序啊

342
00:11:43,500 --> 00:11:45,966
主要是在本地的SRAM当中去工作的

343
00:11:45,966 --> 00:11:47,000
就是我们的计算项目

344
00:11:47,000 --> 00:11:48,466
都在SRAM里面去工作

345
00:11:48,666 --> 00:11:49,900
如果我们需要来自于DDR

346
00:11:49,900 --> 00:11:50,933
或者高带宽显存

347
00:11:50,933 --> 00:11:52,366
HBM里面的数据

348
00:11:52,400 --> 00:11:53,333
那这个时候呢

349
00:11:53,333 --> 00:11:56,500
必须要通过DMA进行一个操作和读录

350
00:11:56,500 --> 00:11:58,100
然后通过路由把我们的数据呢

351
00:11:58,100 --> 00:11:59,400
放在SRAM里面

352
00:12:00,000 --> 00:12:01,533
最后呢就通过列表解析引擎

353
00:12:01,533 --> 00:12:03,300
也就List Parser engine

354
00:12:03,400 --> 00:12:05,733
来将我们不同的数据呢进行打包

355
00:12:05,733 --> 00:12:08,733
然后丢给我们的decode进行解码

356
00:12:08,733 --> 00:12:10,766
然后计算传输数据

357
00:12:10,766 --> 00:12:13,000
一系列刚才讲过的前端的工作了

358
00:12:13,900 --> 00:12:15,566
实际上呢存算一体这种架构呢

359
00:12:15,566 --> 00:12:19,133
为的就是让我们的时延更加的低

360
00:12:19,300 --> 00:12:22,300
因此呢SRAM的设计并非缓存

361
00:12:22,300 --> 00:12:24,533
而是在我们的主存跳过了一级缓存

362
00:12:24,533 --> 00:12:27,000
然后节省了很多芯片的功耗的面积

363
00:12:27,000 --> 00:12:28,766
我们传统样式计算机

364
00:12:28,766 --> 00:12:29,933
呃组成原理里面呢

365
00:12:29,933 --> 00:12:31,300
我们可能有HBM

366
00:12:31,966 --> 00:12:32,766
有L2 Cache，有L1 Cache

367
00:12:32,766 --> 00:12:34,333
有Register file了

368
00:12:34,333 --> 00:12:35,133
一系列的工作

369
00:12:35,133 --> 00:12:37,366
也在我们的GPU里面给大家去讲过的

370
00:12:37,366 --> 00:12:39,200
那这里面呢都没有喽

371
00:12:39,733 --> 00:12:40,166
另外的话

372
00:12:40,166 --> 00:12:41,933
为了减少我们的芯片的面积呢

373
00:12:41,933 --> 00:12:42,600
DOJO里面

374
00:12:42,600 --> 00:12:44,800
也没有虚拟内存的支持

375
00:12:44,800 --> 00:12:45,700
也没有TLB

376
00:12:45,700 --> 00:12:47,533
各种列表各种便利的机制

377
00:12:47,766 --> 00:12:49,700
都把它这些都干掉

378
00:12:49,700 --> 00:12:51,900
剩下的就是我们刚才讲到了前端

379
00:12:51,900 --> 00:12:53,500
后端还有SRAM

380
00:12:53,500 --> 00:12:56,933
另外还有一个NOC路由这么几个内容

381
00:12:56,933 --> 00:12:57,566
那接下来呢

382
00:12:57,566 --> 00:12:58,766
我们谈到NOC内容

383
00:12:58,766 --> 00:13:01,366
我们看一下NOC Route到底是个什么东西

384
00:13:01,700 --> 00:13:03,333
首先呢每个节点呢

385
00:13:03,333 --> 00:13:04,733
也就每个DOJO Core

386
00:13:04,800 --> 00:13:07,600
都可以连接到一个2D的网络

387
00:13:07,600 --> 00:13:09,133
也就是导航导竖

388
00:13:09,133 --> 00:13:10,066
下一个内容呢

389
00:13:10,066 --> 00:13:12,200
就又是我们另外一个DOJO Core了

390
00:13:12,200 --> 00:13:14,966
那现在我们看一下整体的计算单元

391
00:13:14,966 --> 00:13:18,133
也就是我们的Matmul或者Vector Scalar里面

392
00:13:18,133 --> 00:13:18,600
跟SRAM

393
00:13:18,600 --> 00:13:21,800
跟NOC之间的数据呢是怎么交互的

394
00:13:22,100 --> 00:13:24,066
可以通过指令呢去控制NOC路由

395
00:13:24,066 --> 00:13:25,333
直接把我们的数据呢

396
00:13:25,333 --> 00:13:26,300
搬运到

397
00:13:26,300 --> 00:13:29,266
或者搬出到我们的SRAM存储器里面

398
00:13:29,700 --> 00:13:31,666
在SRAM里面呢有两个内容啊

399
00:13:31,666 --> 00:13:33,166
刚才我们简单的讲了一个

400
00:13:33,166 --> 00:13:35,866
一个呢就是我们的列表解析引擎

401
00:13:35,866 --> 00:13:37,166
list praser engine

402
00:13:37,200 --> 00:13:38,133
另外呢一个呢

403
00:13:38,133 --> 00:13:41,700
就是我们的搜集引擎data Gather engine

404
00:13:42,300 --> 00:13:43,366
那List praser engine呢

405
00:13:43,366 --> 00:13:46,333
主要是指我们的指令进行发送啊

406
00:13:46,333 --> 00:13:48,333
给到decode译码器

407
00:13:48,333 --> 00:13:49,766
那另外呢gather engine呢

408
00:13:49,766 --> 00:13:51,266
主要是控制我们的数据的

409
00:13:51,266 --> 00:13:52,733
把我们的数据呢进行打包

410
00:13:52,733 --> 00:13:54,933
然后呢给到距离计算单元更近的

411
00:13:54,933 --> 00:13:56,366
Register file寄存器

412
00:13:56,366 --> 00:13:58,500
然后真正的进行计算之后回

413
00:13:58,500 --> 00:14:00,966
传我们的数据到列表解析引擎呢

414
00:14:00,966 --> 00:14:02,366
就List praser engine里面呢

415
00:14:02,366 --> 00:14:04,500
更多的是对我们的数据呢进行封装

416
00:14:04,500 --> 00:14:05,700
那那我们可以看到这里面呢

417
00:14:05,700 --> 00:14:07,133
concat operations list呢

418
00:14:07,133 --> 00:14:09,566
就是把我们很多的一些数据呢

419
00:14:09,700 --> 00:14:10,766
啊指令呢

420
00:14:10,766 --> 00:14:12,000
进行一个打包

421
00:14:12,000 --> 00:14:12,933
更多是指令哦

422
00:14:13,266 --> 00:14:14,166
使得我们的计算呢

423
00:14:14,166 --> 00:14:15,700
在整个DOJO Core之间呢

424
00:14:15,700 --> 00:14:16,900
更加的高效

425
00:14:16,900 --> 00:14:18,300
那可能在一个DOJO Core里面呢

426
00:14:18,300 --> 00:14:18,966
执行一个指令

427
00:14:18,966 --> 00:14:20,533
在不同的DOJO Core里面呢

428
00:14:20,533 --> 00:14:22,000
执行不同的指令

429
00:14:22,000 --> 00:14:25,200
那不同的指令就带着不同的数据内容

430
00:14:25,600 --> 00:14:28,066
下面呢我们看一下整个DOJO的D1

431
00:14:28,066 --> 00:14:28,866
DOJO

432
00:14:28,866 --> 00:14:31,100
是由354个DOJO Core

433
00:14:31,100 --> 00:14:32,400
也就右边的这一小模块

434
00:14:32,400 --> 00:14:33,666
我们刚才讲了很多的

435
00:14:33,933 --> 00:14:35,333
而在整个DOJO D1里面呢

436
00:14:35,333 --> 00:14:36,500
大部分都是DOJO Core

437
00:14:36,500 --> 00:14:36,933
这里面呢

438
00:14:36,933 --> 00:14:38,566
没有DDR没有Pcie

439
00:14:38,700 --> 00:14:40,200
大部分都是裸芯片

440
00:14:40,200 --> 00:14:42,266
都是大量的计算单元

441
00:14:42,400 --> 00:14:43,800
而所有的IO

442
00:14:43,800 --> 00:14:45,333
包括讲到的DDR啦

443
00:14:45,366 --> 00:14:46,800
HBM呢Pcie呢

444
00:14:46,900 --> 00:14:48,800
都在外围的电路

445
00:14:48,800 --> 00:14:50,066
都在这上面

446
00:14:50,300 --> 00:14:52,600
那刚才我们讲到了简单的这个5*5呢

447
00:14:52,600 --> 00:14:53,900
就是一个DOJO的

448
00:14:53,900 --> 00:14:55,800
D1在整个系统内存里面呢

449
00:14:55,800 --> 00:14:56,700
DOJO的芯片呢

450
00:14:56,700 --> 00:14:59,133
是不直接连接在内存的

451
00:14:59,200 --> 00:14:59,866
而是装备到

452
00:14:59,866 --> 00:15:02,533
我们之前在第一个视频里面讲到的HBM

453
00:15:02,533 --> 00:15:05,900
DIP也就是上面的这个模块

454
00:15:06,600 --> 00:15:08,800
里面的主存或者显存呢

455
00:15:08,800 --> 00:15:11,766
就我们的HBM是在外围电路里面

456
00:15:11,766 --> 00:15:12,866
刚才讲到所有东西呢

457
00:15:12,866 --> 00:15:15,733
都是围绕着计算的和片内主存的

458
00:15:15,733 --> 00:15:16,766
那单个DOJO呢

459
00:15:16,766 --> 00:15:18,366
芯片是不能自给自足的

460
00:15:18,366 --> 00:15:19,366
因为它没有DDR啦

461
00:15:19,366 --> 00:15:20,500
没有Pcie呢

462
00:15:20,500 --> 00:15:21,200
啊因此呢

463
00:15:21,200 --> 00:15:22,733
刚才讲到的所有这些内容呢

464
00:15:22,733 --> 00:15:24,500
都是分布在整个die

465
00:15:24,500 --> 00:15:25,166
就是training die

466
00:15:25,166 --> 00:15:26,900
的一个呃外围

467
00:15:26,900 --> 00:15:29,500
那我们可以看到外围有很多这种接口

468
00:15:29,600 --> 00:15:33,366
9TB每秒的一个IO接口和PCIe的接口

469
00:15:33,566 --> 00:15:35,000
哎我看了一下时间

470
00:15:35,000 --> 00:15:35,933
时间差不多了

471
00:15:36,066 --> 00:15:37,000
视频太长

472
00:15:37,000 --> 00:15:38,700
可能看的人就越来越少了

473
00:15:38,966 --> 00:15:40,500
今天呢只能聚焦3个内容

474
00:15:40,500 --> 00:15:41,933
跟大家一起去交流的

475
00:15:41,933 --> 00:15:42,500
那第一个呢

476
00:15:42,500 --> 00:15:44,533
就是DOJO Core的整体的架构里面呢

477
00:15:44,533 --> 00:15:46,866
就分为前端处理执行引擎

478
00:15:46,866 --> 00:15:47,933
还有SRAM内存

479
00:15:47,933 --> 00:15:51,066
最后还有一个NOC的路由

480
00:15:51,066 --> 00:15:52,533
那讲到前端的内容呢

481
00:15:52,533 --> 00:15:55,400
我们就把前端的几个处理的流程打开

482
00:15:55,400 --> 00:15:56,900
从BTB到我们的缓存

483
00:15:56,900 --> 00:15:59,300
到取码译码怎么去解决的

484
00:15:59,300 --> 00:16:01,733
整体流程Pipeline给大家打开了

485
00:16:01,866 --> 00:16:04,500
最后呢我们讲了DOJO Core的执行引擎

486
00:16:04,500 --> 00:16:06,500
主要是分开Vector跟scalar

487
00:16:06,600 --> 00:16:07,400
所以计算里面呢

488
00:16:07,400 --> 00:16:08,866
最核心的就是特斯拉的

489
00:16:08,866 --> 00:16:10,533
发的那三篇专利

490
00:16:10,533 --> 00:16:12,533
大家有机会呢也可以去搜一下

491
00:16:12,866 --> 00:16:13,900
我们在下集内容呢

492
00:16:13,900 --> 00:16:15,500
再跟大家去展开SRAM

493
00:16:15,500 --> 00:16:16,666
内存还有一些

494
00:16:16,666 --> 00:16:19,333
在整个DOJO的核心系统里面

495
00:16:19,333 --> 00:16:20,133
的一些问题

496
00:16:20,133 --> 00:16:22,533
之后就做一些简单的思考和回顾啦

497
00:16:22,600 --> 00:16:24,700
那今天的内容呢就到这里为止

498
00:16:24,700 --> 00:16:25,533
谢谢各位

