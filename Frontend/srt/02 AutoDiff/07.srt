1
00:00:00,000 --> 00:00:13,000
Hello 大家好,我是Zongmin,今天又是一节没什么人来观看,但是我依然在坚持的一节分享课里面。

2
00:00:13,000 --> 00:00:18,000
今天主要是给大家去聊一聊自动微分的一个挑战和未来。

3
00:00:18,000 --> 00:00:26,000
自动微分这个话题其实我们已经过了非常多的内容了,包括从自动微分的一个基础的概念。

4
00:00:26,000 --> 00:00:36,000
由那几种微分在计算机表达里面就有三种的微分模式,然后实际上模式又有前向微分和后向微分。

5
00:00:36,000 --> 00:00:42,000
具体的实现过程又分别有表达式图、操作幅重载,还有圆码转换。

6
00:00:42,000 --> 00:00:51,000
在具体的实现或者代码实现其实我们用了操作幅重载的这种方式去表达了正向和后向怎么实现的。

7
00:00:51,000 --> 00:01:03,000
既然讲完所有关于自动微分的具体实现,面向这些面向自动微分的实现其实我们还有很多挑战和未来可以聊一聊的。

8
00:01:03,000 --> 00:01:06,000
首先第一个最大的就是利用性问题。

9
00:01:06,000 --> 00:01:19,000
我们可以看到左边这个就是一些数学的表示,我们需要对数学的表示通过计算机系统变成我们可编程的语言,就是右边的这一坨。

10
00:01:19,000 --> 00:01:31,000
但是我们看到左边的这个左边的是理想的情况,理想的情况就是对数学进行表达,对数学的公式进行分解微分组合的这么一个过程。

11
00:01:31,000 --> 00:01:39,000
但是右边我们可以看到其实我们已经把数学过程变成一个便利变成一个for,变成一个实际的程序表达。

12
00:01:39,000 --> 00:01:49,000
所以自动微分系统或者AI框架实际上并不是对数学进行表达,而是对程序或者我们的代码进行表达。

13
00:01:49,000 --> 00:01:57,000
这个时候就会引起大量的编程的利用性问题或者程序员编写代码习惯性的问题。

14
00:01:57,000 --> 00:02:04,000
说到这个编程的习惯问题,下面我们就继续详细的展开一下。

15
00:02:05,000 --> 00:02:10,000
第一个就是控制流表达,这个是作为我们利用性的第一条。

16
00:02:10,000 --> 00:02:20,000
可以看到左边的那个公式还是我们刚才熟悉的味道。分别是Ln等于4的Ln就是做一个自闭包的一个函数。

17
00:02:20,000 --> 00:02:32,000
那右边实际上我们对程序进行表达,变成一个for i等于1,to 3这么一个简单的三次循环,然后再把v返回出来。

18
00:02:32,000 --> 00:02:46,000
这个时候AI框架就要求程序去识别除了if else while这些控制流部分的程序,然后将其排除在微分的过程当中,才能进行很好的微分。

19
00:02:46,000 --> 00:02:51,000
所以控制流进行表达的时候就会引起各种副作用的问题。

20
00:02:53,000 --> 00:02:58,000
第二点就是我们的数据类型非常复杂。

21
00:02:58,000 --> 00:03:07,000
在计算机系统里面,除了我们经常看到的数据类型int,float,double这些数据类型以外,还有trap。

22
00:03:09,000 --> 00:03:12,000
第二点就是复杂的数据类型。

23
00:03:12,000 --> 00:03:19,000
在我们实际语言表达的时候,我们还有Burz,还有List,Emue,Tupo,Disk,还有List。

