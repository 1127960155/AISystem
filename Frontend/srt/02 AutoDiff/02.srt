1
00:00:00,000 --> 00:00:04,800
巴巴巴巴巴巴巴巴巴巴

2
00:00:04,800 --> 00:00:08,400
Hello 大家好

3
00:00:08,400 --> 00:00:10,800
欢迎来到ZOMI的课堂

4
00:00:10,800 --> 00:00:13,000
这是自动微分的第二节

5
00:00:13,000 --> 00:00:14,600
微分的基本概念

6
00:00:14,600 --> 00:00:18,200
微分对AI框架来说非常重要

7
00:00:18,200 --> 00:00:20,600
但是微分的方式有很多种

8
00:00:20,600 --> 00:00:22,400
或者微分的概念非常多

9
00:00:22,400 --> 00:00:25,400
其中最主要的就是数字微分

10
00:00:25,400 --> 00:00:27,400
符号微分和自动微分

11
00:00:27,400 --> 00:00:30,400
而自动微分就是我们今天的主角

12
00:00:42,000 --> 00:00:45,400
在正式进入到我们的内容里面

13
00:00:45,400 --> 00:00:47,800
我给大家推荐几个阅读材料

14
00:00:47,800 --> 00:00:51,600
在机器学习当中的一个自动微分的综述

15
00:00:51,600 --> 00:00:54,000
今天所讲的所有的内容

16
00:00:54,000 --> 00:00:56,000
主要是来自于这篇文章

17
00:00:56,000 --> 00:00:58,600
所以大家也可以去看一下

18
00:00:58,600 --> 00:01:01,400
第二篇推荐的就是Tangent

19
00:01:01,400 --> 00:01:05,800
是谷歌在17年16年到18年发起的一个项目

20
00:01:05,800 --> 00:01:07,800
不过因为各种原因

21
00:01:07,800 --> 00:01:10,400
这个项目最后流产了

22
00:01:10,400 --> 00:01:12,400
这个我们后面也会讲到

23
00:01:12,400 --> 00:01:13,800
它是基于源码转换

24
00:01:13,800 --> 00:01:16,800
去实现的一个自动微分的方式

25
00:01:16,800 --> 00:01:18,800
第三篇文章

26
00:01:18,800 --> 00:01:21,400
基于神经网络张亮的一个

27
00:01:21,400 --> 00:01:24,200
自动微分编程的一种方式

28
00:01:24,200 --> 00:01:27,800
还有最后一篇就是Delta P

29
00:01:27,800 --> 00:01:31,000
一个在机器学习和科学计算的

30
00:01:31,000 --> 00:01:33,000
自动微分编程的一个系统

31
00:01:33,000 --> 00:01:36,400
这四篇文章都非常值得我们去参考

32
00:01:38,200 --> 00:01:41,000
回到我们今天的课程里面

33
00:01:41,000 --> 00:01:43,000
现在我们有三条公式

34
00:01:43,000 --> 00:01:45,600
第一条公式就是L1等于x

35
00:01:45,600 --> 00:01:48,200
我们现在有定义第二条公式

36
00:01:48,200 --> 00:01:49,800
Ln加1等于4

37
00:01:49,800 --> 00:01:52,400
Ln乘以1减L1

38
00:01:52,400 --> 00:01:55,000
假设Ln等于4的时候

39
00:01:55,000 --> 00:01:58,200
我们来去手工的去求解微分

40
00:01:58,200 --> 00:02:00,600
可以发现根据念式求导法值

41
00:02:00,600 --> 00:02:04,000
我们的微分的一个计算公式

42
00:02:04,000 --> 00:02:07,000
就变得非常非常的长了

43
00:02:07,000 --> 00:02:11,000
长到这个等号后面非常非常的多

44
00:02:11,000 --> 00:02:14,200
而这个我们叫做手工微分

45
00:02:14,200 --> 00:02:16,000
手工微分就是手工

46
00:02:16,000 --> 00:02:18,800
人工的去计算我们的微分公式

47
00:02:18,800 --> 00:02:21,400
所以就变成这么去编写

48
00:02:21,400 --> 00:02:23,000
在实际的计算机里面

49
00:02:23,000 --> 00:02:26,800
我们就会去写很多非常勇于的东西

50
00:02:26,800 --> 00:02:28,600
如果我们的表达是不可知

51
00:02:28,600 --> 00:02:29,800
或者越来越复杂的时候

52
00:02:29,800 --> 00:02:32,800
不可能每一次都手工的去求一遍

53
00:02:32,800 --> 00:02:35,000
所以我们就会引入计算机

54
00:02:35,000 --> 00:02:37,000
实现的几种微分方式

55
00:02:37,000 --> 00:02:39,200
第一种就是符号微分

56
00:02:39,200 --> 00:02:41,200
第二种就是数字微分

57
00:02:41,200 --> 00:02:43,600
第三种是自动微分

58
00:02:43,600 --> 00:02:46,600
我们等一下会重新回到这三种微分

59
00:02:46,600 --> 00:02:49,800
来去统一看一看有什么区别

60
00:02:49,800 --> 00:02:53,000
我们现在来看看刚才所讲的三条公式

61
00:02:53,000 --> 00:02:54,800
手动的去编写

62
00:02:54,800 --> 00:02:56,600
fs v等于x

63
00:02:56,600 --> 00:02:58,400
就是我们对应第一条公式

64
00:02:58,400 --> 00:03:01,200
然后v等于4×v×1-v

65
00:03:01,200 --> 00:03:04,000
就是对应我们第二条公式

66
00:03:04,000 --> 00:03:06,600
然后我们去返回我们的v

67
00:03:06,600 --> 00:03:08,800
这个就是我们正向的一个计算

68
00:03:08,800 --> 00:03:10,400
fx等于4的时候

69
00:03:10,400 --> 00:03:12,600
我们有可能就会返回这么一条公式

70
00:03:12,600 --> 00:03:14,000
这个是正向的

71
00:03:14,000 --> 00:03:15,600
而符号微分就需要我们

72
00:03:15,600 --> 00:03:18,600
人工的去展开这么一个复杂的内容

73
00:03:18,600 --> 00:03:22,200
数字微分就是去设定一个很小的数

74
00:03:22,200 --> 00:03:24,600
然后用差分的方式去求解

75
00:03:24,600 --> 00:03:28,000
而自动微分就是把我们的v和Δv

76
00:03:28,000 --> 00:03:30,200
一起给计算机去求解

77
00:03:31,800 --> 00:03:34,600
首先我们要理清楚一个概念

78
00:03:34,600 --> 00:03:37,800
自动微分并不是符号微分

79
00:03:37,800 --> 00:03:41,000
符号微分也实现不了自动微分

80
00:03:41,000 --> 00:03:43,000
我们看看什么是符号微分

81
00:03:43,000 --> 00:03:46,400
符号微分说白了就是通过求导法值

82
00:03:46,400 --> 00:03:49,600
然后去对我们的公式进行展开

83
00:03:49,600 --> 00:03:53,800
下面就是我们两个复式求导法值的一个大原则

84
00:03:53,800 --> 00:03:55,000
根据这个大原则

85
00:03:55,200 --> 00:03:58,600
我们对原始的表达式进行展开

86
00:03:58,600 --> 00:04:03,000
可以看到通过原始的表达式展开求导之后

87
00:04:03,600 --> 00:04:06,200
表达式就会急剧的膨胀了

88
00:04:06,200 --> 00:04:09,200
所以它的缺点非常明显

89
00:04:09,200 --> 00:04:11,000
就是表达式膨胀

90
00:04:11,000 --> 00:04:13,400
每次都要我人工的去算一遍

91
00:04:13,400 --> 00:04:18,400
但是优势就是计算的数字非常的精确

92
00:04:18,400 --> 00:04:22,800
因为每一步都是正确的通过求导法值去计算而得到的

93
00:04:23,400 --> 00:04:25,400
这个就是符号微分

94
00:04:25,400 --> 00:04:27,600
那我们看一下数字微分了

95
00:04:27,600 --> 00:04:30,400
我们再重新强调一下

96
00:04:30,400 --> 00:04:33,200
自动微分并不是数字微分

97
00:04:33,200 --> 00:04:35,000
也不是符号微分

98
00:04:35,000 --> 00:04:37,600
那数字微分的最简单的原理

99
00:04:37,600 --> 00:04:41,200
通俗来讲就是使用有限差分进行计算

100
00:04:41,200 --> 00:04:43,400
首先我们所谓的有限差分

101
00:04:43,400 --> 00:04:46,200
就是模拟一个很小的数h

102
00:04:46,200 --> 00:04:48,000
h是大于0

103
00:04:48,000 --> 00:04:50,200
但是无限接近于0的一个数

104
00:04:50,200 --> 00:04:52,400
我们求fx关于x的导数

105
00:04:54,000 --> 00:04:57,600
最简单的就可以用差分的方式来去求解

106
00:04:57,600 --> 00:05:00,200
把fx加上一个数

107
00:05:00,200 --> 00:05:01,600
然后特别小的一个数

108
00:05:01,600 --> 00:05:04,000
然后减去fx再除以h

109
00:05:04,000 --> 00:05:07,000
就求得了我在函数当中

110
00:05:08,400 --> 00:05:10,800
某个点的变化趋势

111
00:05:11,000 --> 00:05:14,800
这个就是我们在求数字微分的方式

112
00:05:14,800 --> 00:05:18,400
那这种方式优势就是非常容易去实现

113
00:05:18,400 --> 00:05:21,800
可以看到实现这个公式真的在计算机里面

114
00:05:21,800 --> 00:05:23,400
非常非常的简单

115
00:05:23,400 --> 00:05:26,200
但是要记住我们在计算机里面

116
00:05:26,200 --> 00:05:31,800
经常会遇到FP32,int8,FP16或者FP64

117
00:05:31,800 --> 00:05:33,800
这种不同精度的

118
00:05:33,800 --> 00:05:37,600
因为我们硬件而所设计的一些格式

119
00:05:38,600 --> 00:05:40,600
那有这种格式

120
00:05:40,600 --> 00:05:44,000
我们就会可能导致我们的计算结果不精确

121
00:05:44,000 --> 00:05:45,600
计算的复杂度高

122
00:05:45,600 --> 00:05:48,400
或者对我们的h的表达非常高

123
00:05:48,400 --> 00:05:50,400
h,int8能表达吗

124
00:05:50,400 --> 00:05:51,400
应该不能啊

125
00:05:51,400 --> 00:05:53,200
因为它是一个非常小的小数

126
00:05:53,200 --> 00:05:54,600
FP16呢

127
00:05:54,600 --> 00:05:57,000
FP16不够还有FP32

128
00:05:57,000 --> 00:05:58,400
FP32还不够小

129
00:05:58,400 --> 00:06:00,000
可能我们还有FP64

130
00:06:00,000 --> 00:06:02,000
但是它真的够精确了吗

131
00:06:02,000 --> 00:06:10,800
都不够精确

132
00:06:10,800 --> 00:06:13,800
因为这里面我们是个约等于符号哦

133
00:06:13,800 --> 00:06:17,200
当我的计算结果不够精确的时候

134
00:06:17,200 --> 00:06:19,200
就会引起两个误差

135
00:06:19,200 --> 00:06:21,200
第一个叫做truncation error

136
00:06:21,200 --> 00:06:26,200
假设我的数呢是3.1415926吗

137
00:06:26,200 --> 00:06:28,400
不管了这不是π

138
00:06:29,000 --> 00:06:33,200
那这个时候我就需要对后面的数进行截断

139
00:06:33,200 --> 00:06:34,400
那截断之后呢

140
00:06:34,400 --> 00:06:36,000
我又引起另外一个问题了

141
00:06:36,000 --> 00:06:40,200
就是我的这个数需要怎么去使用呢

142
00:06:40,200 --> 00:06:42,200
我使掉了要进一位呢

143
00:06:42,200 --> 00:06:43,400
还是要退一位呢

144
00:06:43,400 --> 00:06:45,400
就引起了使入误差了

145
00:06:45,400 --> 00:06:47,400
叫做round of error

146
00:06:47,400 --> 00:06:50,200
那第二个计算复杂度高

147
00:06:50,200 --> 00:06:54,000
这个呢就会阻碍我们在机器学习领域去发展的

148
00:06:54,200 --> 00:06:57,400
因为每一个你都要需要去计算

149
00:06:57,400 --> 00:07:01,600
0.0000起这么小的一个小数的时候

150
00:07:01,600 --> 00:07:05,400
我们在机器学习里面大量的用Fp30去计算

151
00:07:05,400 --> 00:07:08,400
这个时候呢就非常不利于发展了

152
00:07:08,400 --> 00:07:15,200
下面呢我下面呢我们来正式的看看什么叫做真正的自动微分

153
00:07:15,200 --> 00:07:17,200
回到这里面呢

154
00:07:17,200 --> 00:07:20,600
我们大家不要去看下面两个黑色的框

155
00:07:20,600 --> 00:07:23,800
跟这个视频的主题呢没有太多的关系

156
00:07:23,800 --> 00:07:28,200
我们会在后面正式的去实现的时候给大家去展示代码的

157
00:07:28,200 --> 00:07:30,400
我们先来聊聊数学原理啊

158
00:07:30,400 --> 00:07:31,600
自动微分

159
00:07:31,600 --> 00:07:33,200
什么是自动微分

160
00:07:33,200 --> 00:07:35,000
是所有的数字计算

161
00:07:35,000 --> 00:07:38,800
就是所有的计算呢都有有限的基本运算去组成

162
00:07:38,800 --> 00:07:44,400
也就是由基本的加减乘除求根号开平方是吧

163
00:07:44,400 --> 00:07:46,400
各种的基本运算来组成的

164
00:07:46,400 --> 00:07:51,200
第二点就是这些基本的运算的导数表达式是已知的

165
00:07:51,200 --> 00:07:56,800
也就是加我A加B的导数我是能够知道的啊

166
00:07:56,800 --> 00:07:59,600
然后A减B的导数我也能够知道的

167
00:07:59,600 --> 00:08:01,800
这就是基本运算的导

168
00:08:01,800 --> 00:08:06,200
由这些已知的我们才能够通过念式求导法则

169
00:08:06,200 --> 00:08:09,800
将这些数字计算组成在一起

170
00:08:09,800 --> 00:08:12,500
计算机最擅长的就是做组合

171
00:08:12,500 --> 00:08:13,700
就是做系统

172
00:08:13,700 --> 00:08:15,300
就是做迭代

173
00:08:15,300 --> 00:08:19,600
所以我们利用这个特性发明了自动微分功能

174
00:08:20,600 --> 00:08:24,600
下面我们来看看在神经网络里面

175
00:08:24,600 --> 00:08:26,400
我们要实现自动微分

176
00:08:26,400 --> 00:08:27,900
有一个概念非常重要

177
00:08:27,900 --> 00:08:29,600
就是表达式追踪

178
00:08:29,600 --> 00:08:32,000
我们叫做Evaluation Traced

179
00:08:32,000 --> 00:08:36,400
就是追踪我们数字计算过程当中的中间变量

180
00:08:36,400 --> 00:08:38,400
那什么是中间变量了

181
00:08:38,400 --> 00:08:43,400
我们假设这里面有三个算子或者三个计算

182
00:08:43,400 --> 00:08:45,200
第一个就是我们的卷机

183
00:08:45,200 --> 00:08:47,300
第二个就是我们的激活纬路

184
00:08:47,300 --> 00:08:49,600
第三个就是我们求Lost

185
00:08:49,600 --> 00:08:52,100
这个是我们正向的一个计算方式

186
00:08:52,100 --> 00:08:54,200
我们的数就是一个Tensor

187
00:08:54,200 --> 00:08:55,600
input一个Tensor

188
00:08:55,600 --> 00:08:59,400
然后我们WB是我们卷机的一个权重

189
00:08:59,400 --> 00:09:01,300
在正向计算的时候

190
00:09:01,300 --> 00:09:03,600
其实没有太多的问题

191
00:09:03,600 --> 00:09:06,300
但是我们看看反向的过程当中

192
00:09:06,300 --> 00:09:08,600
右边那个图就变得非常复杂了

193
00:09:08,600 --> 00:09:09,400
这个是正向的

194
00:09:09,400 --> 00:09:10,600
这个是反向的

195
00:09:10,600 --> 00:09:13,300
从正向到反向没有这么简单

196
00:09:13,300 --> 00:09:16,800
我们会引申右边的这一坨东西

197
00:09:16,800 --> 00:09:19,800
就是每一个计算每一个公式

198
00:09:19,800 --> 00:09:21,600
我们反向的时候

199
00:09:21,600 --> 00:09:23,700
都会引起大量的变量

200
00:09:23,700 --> 00:09:25,900
这个时候在做自动微分的时候

201
00:09:25,900 --> 00:09:28,000
就是有表达式追踪

202
00:09:28,000 --> 00:09:31,000
通过这个Traced跟踪我们每个计算

203
00:09:31,000 --> 00:09:35,100
就是我们每一条箭头都要去跟踪的

204
00:09:35,100 --> 00:09:36,200
如果不跟踪

205
00:09:36,200 --> 00:09:37,900
可能我们计算什么

206
00:09:37,900 --> 00:09:38,700
要计算什么

207
00:09:38,700 --> 00:09:40,200
下一次传到什么

208
00:09:40,200 --> 00:09:42,700
哪一次要复用前面的这个W

209
00:09:42,700 --> 00:09:46,000
哪一次要调DW都不知道了

210
00:09:46,100 --> 00:09:47,100
回到我们这个图

211
00:09:47,100 --> 00:09:51,300
我们可以看到实际上的符号微分很简单

212
00:09:51,300 --> 00:09:53,200
只是通过链式求导法则

213
00:09:53,200 --> 00:09:56,300
然后对我们的公式进行组合

214
00:09:56,300 --> 00:09:59,700
那数字微分也很简单

215
00:09:59,700 --> 00:10:01,300
是一个很小的数

216
00:10:01,300 --> 00:10:04,200
然后根据这条公式去计算

217
00:10:04,200 --> 00:10:07,800
而实际上我们今天所谈的自动微分

218
00:10:07,800 --> 00:10:09,900
就是通过计算机系统

219
00:10:09,900 --> 00:10:11,800
通过一个表达式追踪

220
00:10:11,900 --> 00:10:16,000
去跟踪我们每一次求导的公式和方程

221
00:10:17,400 --> 00:10:19,700
那今天的课程到这就结束了

222
00:10:19,700 --> 00:10:23,400
我们今天了解了计算机微分的三种形态

223
00:10:23,400 --> 00:10:25,100
第一种就是符号微分

224
00:10:25,100 --> 00:10:26,200
第二种数字微分

225
00:10:26,200 --> 00:10:28,300
第三种是自动微分

226
00:10:28,300 --> 00:10:31,300
我们还了解了符号微分的基本原理和优缺点

227
00:10:31,300 --> 00:10:34,200
还有数字微分的基本原理和优缺点哦

228
00:10:34,200 --> 00:10:37,600
最后我们还看了自动微分原理

229
00:10:37,600 --> 00:10:39,100
自动微分的基本原理

230
00:10:39,100 --> 00:10:41,100
但是我们没有太展开

231
00:10:41,100 --> 00:10:45,300
自动微分我们会将在下一节里面详细的去展开

232
00:10:45,300 --> 00:10:47,300
这里面只是抛出一个概念

233
00:10:47,300 --> 00:10:49,000
卷的不行了卷的不行了

234
00:10:49,000 --> 00:10:50,800
记得一键三连加关注哦

235
00:10:50,800 --> 00:10:54,400
所有的内容都会开源在下面这条链接里面

236
00:10:54,400 --> 00:10:55,100
白了个拜

