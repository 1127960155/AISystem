1
00:00:00,000 --> 00:00:10,000
哈喽大家好,我是钟咪酱,欢迎来到钟咪的课堂

2
00:00:10,000 --> 00:00:17,000
上一节课真的是,不管是你听的,是我讲的都是脑瓜子嗡嗡的

3
00:00:17,000 --> 00:00:22,000
这里是所有的分享里面最难的了

4
00:00:22,000 --> 00:00:27,000
那今天呢,我想给大家一起去看一看自动微分是怎么实现的

5
00:00:27,000 --> 00:00:29,000
就是它的具体实现方式啦

6
00:00:29,000 --> 00:00:33,000
自动微分的具体实现方式分三个

7
00:00:33,000 --> 00:00:36,000
第一个是基于表达式或者基于图的

8
00:00:36,000 --> 00:00:41,000
第二个就是操作符重载这个概念基本上只有在高级语言里面才会有的

9
00:00:41,000 --> 00:00:44,000
第三个就是圆码转换

10
00:00:44,000 --> 00:00:47,000
圆码转换也是最难实现最复杂的

11
00:00:47,000 --> 00:00:55,000
所以我们会在下面两节分享里面去讲讲基于表达式或者操作符里面去怎么去实现的

12
00:00:55,000 --> 00:00:58,000
基于圆码转换,说实话你放过我吧

13
00:00:58,000 --> 00:01:02,000
这些实现起来太麻烦了,我们了解基本概念就好了

14
00:01:02,000 --> 00:01:06,000
基于表达式或者表达方法去实现的自动微分

15
00:01:06,000 --> 00:01:10,000
就有应该在12年推出的AutoDiffer

16
00:01:10,000 --> 00:01:14,000
那AutoDiffer它基于表达式的几种实现方式呢

17
00:01:14,000 --> 00:01:17,000
主要是它封装了基本的表达作为一个酷函数

18
00:01:17,000 --> 00:01:20,000
就是我的加减乘除的每一次的导数

19
00:01:20,000 --> 00:01:23,000
我都要去手工的写一遍

20
00:01:23,000 --> 00:01:28,000
运行的时候大家就会去记录基本表达式的一个相关的组合关系

21
00:01:28,000 --> 00:01:31,000
就我的加减乘除这些都要记下来

22
00:01:31,000 --> 00:01:33,000
我加,我要算一遍加

23
00:01:33,000 --> 00:01:36,000
然后加的导数我要记下来

24
00:01:36,000 --> 00:01:40,000
然后去不是人工的记,是那个写程序的时候记下来

25
00:01:40,000 --> 00:01:43,000
然后最后再进行一个组合

26
00:01:43,000 --> 00:01:46,000
就实现的过程非常之复杂,勇于

27
00:01:46,000 --> 00:01:50,000
第二种实现方式就是操作符从载

28
00:01:50,000 --> 00:01:54,000
一看到这个logo我就不困了

29
00:01:57,000 --> 00:01:59,000
这个就是PyTorch

30
00:01:59,000 --> 00:02:01,000
其余操作符从载除了PyTorch

31
00:02:01,000 --> 00:02:04,000
其实它没有一个非常之明显的界限

32
00:02:04,000 --> 00:02:07,000
Tensor4也是基于操作符从载的方式去实现的

33
00:02:07,000 --> 00:02:10,000
只是可能细节上有些不一样

34
00:02:11,000 --> 00:02:14,000
操作符从载就是利用语言的多态性

35
00:02:14,000 --> 00:02:18,000
用操作符去从载基本的运算表达式

36
00:02:18,000 --> 00:02:21,000
也就是我的加减乘除求根号这些

37
00:02:21,000 --> 00:02:22,000
它都从载了一遍

38
00:02:22,000 --> 00:02:26,000
从载的过程当中就用了我们的一个记录器

39
00:02:26,000 --> 00:02:28,000
把这些计算记录下来

40
00:02:28,000 --> 00:02:31,000
然后根据链式求导法则组合

41
00:02:31,000 --> 00:02:34,000
第三种就是我们的圆码转换

42
00:02:34,000 --> 00:02:39,000
圆码转换最典型的代表就是华为字眼的一个Middle Spore

43
00:02:39,000 --> 00:02:41,000
我们叫做头包

44
00:02:41,000 --> 00:02:45,000
简单的Middle就是头,Spore就是包子

45
00:02:45,000 --> 00:02:48,000
简单的头包,实际上它不叫头包

46
00:02:48,000 --> 00:02:51,000
它有它自己的中文名叫做声丝

47
00:02:51,000 --> 00:02:54,000
声腾的声,声腾产业线里面的声

48
00:02:54,000 --> 00:02:57,000
思考的丝,Spore嘛,什么思考

49
00:02:57,000 --> 00:03:01,000
最主要的是基于一个语言的预处理或者编译器

50
00:03:01,000 --> 00:03:03,000
或者解析器去进行一个扩展的

51
00:03:03,000 --> 00:03:06,000
把我们的Python的圆码进行转换

52
00:03:06,000 --> 00:03:12,000
转换完之后再对它这些计算进行一个组织整理

53
00:03:12,000 --> 00:03:14,000
然后最后通过链式求导法则

54
00:03:14,000 --> 00:03:16,000
然后进行组合的

55
00:03:16,000 --> 00:03:18,000
所以它会比较复杂

56
00:03:18,000 --> 00:03:19,000
它需要去写一个

