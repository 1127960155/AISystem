1
00:00:00,140 --> 00:00:04,800
啊吧吧吧吧吧吧吧吧
2
00:00:04,800 --> 00:00:05,520
hello
3
00:00:05,520 --> 00:00:06,150
大家好
4
00:00:06,150 --> 00:00:07,230
我是钟敏
5
00:00:07,230 --> 00:00:10,020
这一节的内容呢还是张量并行
6
00:00:10,020 --> 00:00:15,200
不同的是我们去讲讲张量并行里面的张亮重排
7
00:00:15,200 --> 00:00:17,870
然后呢再去拓展一下my sport
8
00:00:17,870 --> 00:00:21,140
如何去对我们的张亮做自动重排
9
00:00:21,140 --> 00:00:22,900
的一个具体的算法
10
00:00:24,920 --> 00:00:26,800
现在呢我们来到最后一个内容
11
00:00:26,800 --> 00:00:28,720
也就是max很重要的一个特性
12
00:00:28,720 --> 00:00:29,920
张量自动运行
13
00:00:29,920 --> 00:00:33,220
我们来先先看看具体的数学原理吧
14
00:00:33,220 --> 00:00:36,240
首先我们回顾一下一个张量呢
15
00:00:36,240 --> 00:00:37,920
现在的一个2x2的张量
16
00:00:37,920 --> 00:00:39,900
把它切换到两台不同的机器
17
00:00:39,900 --> 00:00:41,580
那可能我们有两种切换方式
18
00:00:41,580 --> 00:00:43,080
一种是行的切分
19
00:00:43,080 --> 00:00:44,280
一种是列的切分
20
00:00:44,280 --> 00:00:46,440
另外一种就是直接复制
21
00:00:46,440 --> 00:00:48,060
那假设我复杂一点
22
00:00:48,060 --> 00:00:49,560
我的机器多了
23
00:00:49,560 --> 00:00:51,620
我同样是一个2x2的机器
24
00:00:51,620 --> 00:00:53,480
我现在有四台设备
25
00:00:53,480 --> 00:00:56,120
我可能会进行一个行列的切分
26
00:00:56,120 --> 00:00:58,400
把每一个元素切分到不同的机器
27
00:00:58,400 --> 00:01:00,950
我也可能只进行一个行的切分
28
00:01:00,950 --> 00:01:03,020
或者只进行一个行的切分
29
00:01:03,020 --> 00:01:05,900
那我有四台机器行切换只会分成两半
30
00:01:05,900 --> 00:01:08,240
所以另外两半呢我们会做一个复制
31
00:01:08,240 --> 00:01:12,530
这个device一跟device 3的数据是相同的
32
00:01:12,530 --> 00:01:15,100
第三种就是进行列的切分
33
00:01:15,100 --> 00:01:18,850
同样列的切分呢只会切分成两组数据
34
00:01:18,850 --> 00:01:21,140
我还是需要进行一个复制
35
00:01:21,140 --> 00:01:24,050
把device一的数据复制成device 3
36
00:01:24,050 --> 00:01:26,960
我才可以保证四台机器都有数据
37
00:01:26,960 --> 00:01:29,330
最后一种方式呢就是全复制
38
00:01:29,330 --> 00:01:32,240
把一个矩阵复制到所有的机器
39
00:01:32,240 --> 00:01:35,380
既然我们有各种的切换方式
40
00:01:35,380 --> 00:01:40,060
就会涉及到各种的通讯方式啦
41
00:01:40,880 --> 00:01:41,980
提到通讯方式
42
00:01:41,980 --> 00:01:45,250
大家可以看一下我之前分享的一个内容
43
00:01:45,250 --> 00:01:46,840
就是我们的通讯人员哦
44
00:01:46,840 --> 00:01:49,740
不不不是是通性原理啊
45
00:01:49,740 --> 00:01:53,120
其实刚才讲的各种的切分方式呢
46
00:01:53,120 --> 00:01:54,680
可以互相转换的
47
00:01:54,680 --> 00:01:57,740
可以通过slice or get或者or to all
48
00:01:57,740 --> 00:02:00,050
不同的方式进行切换
49
00:02:00,050 --> 00:02:01,880
同样我有四台四倍
50
00:02:01,880 --> 00:02:05,420
刚才的几种方式也可以通过all get all reduce
51
00:02:05,420 --> 00:02:06,200
还有slice
52
00:02:06,200 --> 00:02:11,100
还有all to all这几种切分方式进行互相转化的
53
00:02:11,800 --> 00:02:13,470
讲这个有什么用呢
54
00:02:13,470 --> 00:02:16,200
是因为在整个神经网络模型里面呢
55
00:02:16,200 --> 00:02:19,800
我们会大量的去用到这些内容
56
00:02:20,560 --> 00:02:24,180
那假设呢现在我引入了一个新的概念
57
00:02:24,180 --> 00:02:25,940
叫做张亮重排
58
00:02:25,940 --> 00:02:28,730
tensor with distribution
59
00:02:28,730 --> 00:02:30,740
现在我们举一个简单的例子
60
00:02:30,740 --> 00:02:32,750
假设我现在有两个计算
61
00:02:32,750 --> 00:02:34,780
一个x乘以a等于y
62
00:02:34,780 --> 00:02:37,030
第二个是我把y作为输入
63
00:02:37,030 --> 00:02:38,650
y乘以b等于z
64
00:02:38,650 --> 00:02:43,120
那有点像我们刚才transformer的mlp层
65
00:02:43,220 --> 00:02:45,200
在我们的网络模型里面呢
66
00:02:45,200 --> 00:02:47,840
我的x的输入其实已经切换了四半
67
00:02:47,840 --> 00:02:49,100
有s1234 
68
00:02:49,100 --> 00:02:52,140
而我的权重a呢还是只有一份
69
00:02:52,140 --> 00:02:55,760
那我得到的就是一个y1 y2 y3 y4 
70
00:02:55,760 --> 00:02:59,810
下一层的网络模型呢只接收一个y的书
71
00:02:59,810 --> 00:03:03,270
那我就需要对不同的设备的y做一个together
72
00:03:03,270 --> 00:03:06,140
就把张量进行重新排列
73
00:03:06,140 --> 00:03:07,760
得到一个新的张量
74
00:03:07,760 --> 00:03:09,320
然后再进行计算的
75
00:03:09,320 --> 00:03:12,280
这个时候我的b呢已经按照列的方式切换好了
76
00:03:12,280 --> 00:03:13,240
y一乘以b1 
77
00:03:13,240 --> 00:03:15,310
最后得到我的z1234 
78
00:03:15,310 --> 00:03:18,840
那中间的这个过程呢我们叫做张亮重排
79
00:03:18,840 --> 00:03:21,480
我们再来看看另外一个概念
80
00:03:21,480 --> 00:03:24,030
假设我的计算公式还是一模一样的
81
00:03:24,030 --> 00:03:25,720
x乘以a等于y
82
00:03:25,720 --> 00:03:28,240
那y呢作为我们的z的输入
83
00:03:28,240 --> 00:03:30,880
y乘以b等于z
84
00:03:30,980 --> 00:03:34,360
上一层网络模型传给我们的数据呢
85
00:03:34,360 --> 00:03:37,140
就不是x每一个进行切分
86
00:03:37,140 --> 00:03:39,520
而是ex进行行切分
87
00:03:39,520 --> 00:03:41,140
a进行列千分
88
00:03:41,140 --> 00:03:44,500
所以device一呢是x1 devices 2还是x1 
89
00:03:44,500 --> 00:03:45,100
device
90
00:03:45,100 --> 00:03:46,620
三呢是x2 
91
00:03:46,620 --> 00:03:49,530
而a呢device一是a1 
92
00:03:49,530 --> 00:03:50,100
device
93
00:03:50,100 --> 00:03:51,390
二呢是a2 
94
00:03:51,390 --> 00:03:54,880
那这个时候我的计算模型就不一样了
95
00:03:54,880 --> 00:03:58,420
中间呢这时候就不需要一个all get的方式
96
00:03:58,420 --> 00:04:00,160
把所有的y进行聚合
97
00:04:00,160 --> 00:04:02,290
因为y需不需要聚合
98
00:04:02,290 --> 00:04:04,540
取决于我们后面的计算
99
00:04:04,540 --> 00:04:08,200
那后面的b呢我是按照行进行切分的
100
00:04:08,200 --> 00:04:11,320
我按照行进行切分到不同的机器进行复制
101
00:04:11,320 --> 00:04:12,820
最后再进行计算
102
00:04:12,820 --> 00:04:17,399
那我期望得到的是z1 z2 y乘以b之后呢
103
00:04:17,399 --> 00:04:19,379
需要做一个all reduce的操作
104
00:04:19,379 --> 00:04:21,660
然后聚合得到我的z1 
105
00:04:21,660 --> 00:04:24,420
同理这个y进行overduce操作
106
00:04:24,420 --> 00:04:26,080
得到我的z2 
107
00:04:26,080 --> 00:04:27,550
这种操作
108
00:04:27,550 --> 00:04:31,240
也作为我们张亮重排的其中一种特殊的形态
109
00:04:31,240 --> 00:04:34,200
这么做有什么好处呢
110
00:04:34,420 --> 00:04:37,320
商量重排其实是一个很复杂的工程
111
00:04:37,320 --> 00:04:40,280
我需要知道很多种不同的排列方式
112
00:04:40,280 --> 00:04:43,850
然后为系统找到一种最优的执行效率
113
00:04:43,850 --> 00:04:45,980
所以master这个ai框架
114
00:04:45,980 --> 00:04:48,920
就发明了一个张亮切片的一个策略
115
00:04:48,920 --> 00:04:51,720
就是利用刚才张亮重排的一个原理
116
00:04:51,720 --> 00:04:54,780
那可能里面的算法分为四部分
117
00:04:54,780 --> 00:04:58,320
第一步呢就是拿到网络模型定义的脚本
118
00:04:58,320 --> 00:05:00,660
通过源码转换得到我们的计算图
119
00:05:00,660 --> 00:05:05,520
第二步呢就是对每一个算子去枚举
120
00:05:05,520 --> 00:05:07,380
它可能的切分方式
121
00:05:07,380 --> 00:05:10,740
假设维度呢有很多种不同的切分方式
122
00:05:10,740 --> 00:05:11,820
有暗行切分
123
00:05:11,820 --> 00:05:13,260
有按列切分
124
00:05:13,260 --> 00:05:14,280
假设是为路
125
00:05:14,280 --> 00:05:16,680
它有按行的第八行进行切分
126
00:05:16,680 --> 00:05:18,520
它有按第四行进行切分
127
00:05:18,520 --> 00:05:20,200
也有按第四列进行切分
128
00:05:20,200 --> 00:05:21,760
或者第八列进行切分
129
00:05:21,760 --> 00:05:23,260
切分的策略非常多
130
00:05:23,260 --> 00:05:24,920
会进行一个没举
131
00:05:24,920 --> 00:05:25,880
第三步呢
132
00:05:25,880 --> 00:05:28,430
系统就会去枚举我们计算图里面
133
00:05:28,430 --> 00:05:32,430
每一条边经过张量重排之后的具体的策略
134
00:05:32,430 --> 00:05:34,260
还有相对应的代价
135
00:05:34,260 --> 00:05:37,120
那这个呢我们叫做cos这个代价函数
136
00:05:37,120 --> 00:05:40,870
第四步呢就是通过凸优化或者动态规划的方法
137
00:05:40,870 --> 00:05:43,720
去求解最优的代价函数
138
00:05:43,720 --> 00:05:46,020
就是最优的cos函数
139
00:05:46,020 --> 00:05:49,740
到最后一步就是把刚才求得到的一个策略
140
00:05:49,740 --> 00:05:51,200
从算子进行出发
141
00:05:51,200 --> 00:05:53,000
传播到整个网络
142
00:05:53,000 --> 00:05:55,280
然后去进行运算
143
00:05:55,980 --> 00:05:57,800
今天的内容呢稍微多了一点
144
00:05:57,800 --> 00:05:58,760
我们来总结一下
145
00:05:58,760 --> 00:06:00,220
我还了解了my sp
146
00:06:00,220 --> 00:06:03,070
张亮自动并行的具体的策略原理
147
00:06:03,070 --> 00:06:04,000
卷的不行了
148
00:06:04,000 --> 00:06:04,900
卷的不行了
149
00:06:04,900 --> 00:06:06,520
记得一键三连加关注哦
150
00:06:06,520 --> 00:06:08,080
所有的内容都会开源
151
00:06:08,080 --> 00:06:10,960
在下面这条链接里面摆了个拜
