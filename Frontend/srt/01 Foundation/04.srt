1
00:00:00,000 --> 00:00:02,000
哈喽大家好,欢迎来到《总迷的课堂》

2
00:00:02,000 --> 00:00:06,000
这一节主要是跟大家一起去分享AI框架的编程范式

3
00:00:06,000 --> 00:00:10,000
这也是作为AI框架基础的最后一节的内容里面的

4
00:00:10,000 --> 00:00:16,000
这么早就开完饭?你数什么呢?

5
00:00:16,000 --> 00:00:22,000
聊到AI编程范式,其实一开始我也是不知道AI的编程范式

6
00:00:22,000 --> 00:00:26,000
声明是编程迷的,但我还是知道AI编程范式

7
00:00:26,000 --> 00:00:32,000
作为一个算法工程师或者程序员,其实一开始我对编程范式的理解并不是非常深入

8
00:00:32,000 --> 00:00:38,000
最多就是知道在C++编写代码的时候可能会使用面向对象的这种编程范式

9
00:00:38,000 --> 00:00:42,000
现在我们来看看编程范式维基百科的一个解释

10
00:00:42,000 --> 00:00:44,000
其实我也不是很懂刚查的

11
00:00:44,000 --> 00:00:47,000
编程范式英文叫做Programming Programming

12
00:00:47,000 --> 00:00:52,000
编程范式的编程范式是一个词,就是编程范式的编程范式

13
00:00:52,000 --> 00:00:54,000
其实我也不是很懂刚查的

14
00:00:54,000 --> 00:00:56,000
编程范式英文叫做Programming

15
00:00:56,000 --> 00:00:58,000
这个英文是

16
00:00:58,000 --> 00:01:00,000
Paradigm

17
00:01:00,000 --> 00:01:02,000
Programming paradigm

18
00:01:02,000 --> 00:01:06,000
是指软件工程的一类典型编程风格

19
00:01:06,000 --> 00:01:08,000
诶,这有点意思

20
00:01:08,000 --> 00:01:10,000
就是典型的编程风格

21
00:01:14,000 --> 00:01:18,000
面向AI或者深度学习,其实我们有两种编程风格

22
00:01:18,000 --> 00:01:20,000
第一种是声明式编程

23
00:01:20,000 --> 00:01:22,000
第二种是命令式编程

24
00:01:22,000 --> 00:01:26,000
在今天的课程里面呢,我希望跟大家一起去学习

25
00:01:26,000 --> 00:01:28,000
什么是声明式编程

26
00:01:28,000 --> 00:01:30,000
什么是命令式的编程风格

27
00:01:30,000 --> 00:01:34,000
现在我们来看看最简单的或者最原始的

28
00:01:34,000 --> 00:01:37,000
也在我们上一节课里面去提到的

29
00:01:37,000 --> 00:01:39,000
假设我现在充能派

30
00:01:39,000 --> 00:01:42,000
就是直接用Python的一个最基础的酷

31
00:01:42,000 --> 00:01:45,000
去实现一个简单的先成后加

32
00:01:45,000 --> 00:01:48,000
然后再求和的一个简单的操作

33
00:01:48,000 --> 00:01:50,000
也就是做一个最原始的神经元

34
00:01:50,000 --> 00:01:54,000
那这个时候呢,我做了一些简单的计算之后

35
00:01:54,000 --> 00:01:57,000
现在我需要反向的去更新我的T度

36
00:01:57,000 --> 00:02:02,000
更新T度的方式也是比较简单粗暴的直接写下来了

37
00:02:02,000 --> 00:02:05,000
这是最原始的AI的编程方法

38
00:02:06,000 --> 00:02:09,000
后来有了AI框架PyTouch之后呢

39
00:02:09,000 --> 00:02:11,000
首先第一步,我们需要去声明

40
00:02:11,000 --> 00:02:14,000
现在我有几个张量,XYZ

41
00:02:14,000 --> 00:02:17,000
接着呢,我对这些张量进行计算

42
00:02:17,000 --> 00:02:20,000
所以我X乘以Y,A加上以C

43
00:02:20,000 --> 00:02:21,000
这么一个过程

44
00:02:21,000 --> 00:02:25,000
就我们看到右边的这个图,这个动态的图

45
00:02:25,000 --> 00:02:30,000
我们把刚才的XYZ然后通过一个计算图进行表达起来

46
00:02:30,000 --> 00:02:32,000
那既然是AI框架

47
00:02:32,000 --> 00:02:35,000
它肯定要帮我们做一些反向

48
00:02:35,000 --> 00:02:39,000
或者在我们上一个系列里面去讲到的自动微分的操作

49
00:02:39,000 --> 00:02:41,000
那有了这个Bedwalk

50
00:02:41,000 --> 00:02:44,000
然后我们去试着TrainGraph等于True的时候

51
00:02:44,000 --> 00:02:48,000
就会自动的帮我们去构建反向的图

52
00:02:48,000 --> 00:02:50,000
我们再看一次动画

53
00:02:50,000 --> 00:02:53,000
就会自动的帮我们把反向的图构建起来

54
00:02:53,000 --> 00:03:00,000
那这个就是AI框架编程最基本或者最典型的一种方式

55
00:03:00,000 --> 00:03:03,000
有了这种新的编程方式之后呢

56
00:03:03,000 --> 00:03:05,000
后来AI框架慢慢的去演变

57
00:03:05,000 --> 00:03:08,000
然后形成了一个比较系统的一个图

58
00:03:09,000 --> 00:03:10,000
那右边的这个图呢

59
00:03:10,000 --> 00:03:13,000
就是我们上一节展开的粉粉绿绿的图

60
00:03:13,000 --> 00:03:15,000
只是上一节里面做了一个分层

61
00:03:15,000 --> 00:03:17,000
这里面就没有做太多的分层

62
00:03:17,000 --> 00:03:18,000
而是从上到下

63
00:03:18,000 --> 00:03:21,000
看一下整个AI系统或者AI框架

64
00:03:21,000 --> 00:03:25,000
怎么做编程风格或者编程代码之间的一个区分

65
00:03:25,000 --> 00:03:29,000
现在最明显的就是区分前端和后端

66
00:03:29,000 --> 00:03:33,000
那可能我们的统一表是优化层运行时底层库

67
00:03:33,000 --> 00:03:37,000
这些都作为我们的一个整体的后端去看待

68
00:03:37,000 --> 00:03:42,000
这也是我们公司或者我跟其他同事在交流的过程当中

69
00:03:42,000 --> 00:03:44,000
大家都比较认可的一种方式

70
00:03:44,000 --> 00:03:47,000
前端呢就会一些高层次的语言

71
00:03:47,000 --> 00:03:49,000
例如Python作为前端

72
00:03:49,000 --> 00:03:51,000
那可能有一些会使用Lua

73
00:03:51,000 --> 00:03:53,000
还有R还有C++或者JavaScript

74
00:03:53,000 --> 00:03:55,000
作为我们的前端语言

75
00:03:55,000 --> 00:03:58,000
这个呢就是我们对上的API层

76
00:03:58,000 --> 00:04:01,000
那后端呢就会提供一些底层的编程模型

77
00:04:01,000 --> 00:04:02,000
编程语言的开发

78
00:04:02,000 --> 00:04:06,000
后端可能还会提供一些高性能可附用的模块

79
00:04:06,000 --> 00:04:11,000
或者那个通过前端的方式去驱动后端怎么去执行

80
00:04:11,000 --> 00:04:16,000
也就是说我前端的表达其实跟我的后端是相关的

81
00:04:16,000 --> 00:04:20,000
而不是说前端的表达跟后端是完全结偶的

82
00:04:20,000 --> 00:04:23,000
我们这里面有一个叫做统一表示

83
00:04:23,000 --> 00:04:30,000
在第二代神经网络里面可能更多的去使用计算图或者数据流图作为统一的表示

84
00:04:30,000 --> 00:04:34,000
既然我们有了这个计算图进行统一表示

85
00:04:34,000 --> 00:04:37,000
肯定前端要适配好这个统一的表示

86
00:04:37,000 --> 00:04:42,000
后端下面的优化也需要根据我的计算图进行优化

87
00:04:42,000 --> 00:04:45,000
所以整个编程的风格编程的范式

88
00:04:45,000 --> 00:04:50,000
不仅仅是指前端的代码或者前端的高层语言的表示

89
00:04:50,000 --> 00:04:55,000
更多的是指整个AI框架我的设计理念我的架构理念

90
00:04:57,000 --> 00:05:01,000
下面呢我们以PyTorch和Tensor4两个框架为例

91
00:05:01,000 --> 00:05:07,000
看一下什么是命令式编程和生命式编程两种不同的编程方式

92
00:05:07,000 --> 00:05:13,000
PyTorch最特别的一点就是使用动态图去表示它的神经网络

93
00:05:13,000 --> 00:05:16,000
然后使得整个框架的应用性非常好

94
00:05:16,000 --> 00:05:25,000
但是我个人认为其实并不完全是因为动态图导致它的AI框架的应用性特别高

95
00:05:25,000 --> 00:05:31,000
更多的是因为它的命令式编程的方式导致它的AI框架的应用性特别高

96
00:05:31,000 --> 00:05:36,000
我们来看一看命令式编程的它的英文又叫做Informative Programming

97
00:05:36,000 --> 00:05:41,000
那在英文里面我们还有另外一种表述叫做Defined by One

98
00:05:41,000 --> 00:05:44,000
也就是程序定义完之后就去执行了

99
00:05:44,000 --> 00:05:49,000
那这种执行方式在AI框架的一个架构图里面是比较直接的

100
00:05:49,000 --> 00:05:55,000
也就是我前端通过前端的一些语言、高级语言去表示完之后

101
00:05:55,000 --> 00:05:58,000
然后我们会把它变成一个计算图

102
00:05:58,000 --> 00:06:02,000
这是一个概念上的计算图而不是真正意义上的计算图

103
00:06:02,000 --> 00:06:05,000
然后程序就会做一些自动微分

104
00:06:05,000 --> 00:06:07,000
如果我们选择了自动微分Autograde

105
00:06:07,000 --> 00:06:09,000
那就可能会做自动微分

106
00:06:09,000 --> 00:06:12,000
那如果没选可能自动微分这一层都没掉了

107
00:06:12,000 --> 00:06:17,000
然后就去直接根据我们的代码进行一个调度和执行

108
00:06:17,000 --> 00:06:20,000
就是这么简单就从上面直接下来了

109
00:06:20,000 --> 00:06:25,000
所以我们会用前端的语言直接去驱动后端的算子执行

110
00:06:25,000 --> 00:06:29,000
非常直接我定义了一个成号

111
00:06:29,000 --> 00:06:32,000
在这里面我定义了一个A等于X乘以Y

112
00:06:32,000 --> 00:06:34,000
B等于A加Z之后

113
00:06:34,000 --> 00:06:38,000
程序把这个图定义下来变成一个计算图之后

114
00:06:38,000 --> 00:06:43,000
也是根据我A等于X乘以Y先执行完这个计算

115
00:06:43,000 --> 00:06:49,000
然后再执行这个计算直接是Defined by one的这种方式去执行的

116
00:06:49,000 --> 00:06:55,000
那它的一个特点就是非常方便我调试灵活度很高

117
00:06:55,000 --> 00:06:58,000
那缺点就是缺乏对算法的统一描述

118
00:06:58,000 --> 00:07:01,000
还有缺乏编译期间的优化

119
00:07:01,000 --> 00:07:03,000
那优点我们其实都很清楚了

120
00:07:03,000 --> 00:07:05,000
我们聊聊缺点

121
00:07:05,000 --> 00:07:08,000
其实我们现在在试剂MindSpot的时候

122
00:07:08,000 --> 00:07:12,000
也会考虑到很多这方面的因素和原因

123
00:07:12,000 --> 00:07:16,000
首先动态图确实应用性很高

124
00:07:16,000 --> 00:07:18,000
但是如果我们要做高阶微分的时候

125
00:07:18,000 --> 00:07:21,000
如果没有了一个统一的表示

126
00:07:21,000 --> 00:07:23,000
对算法的统一表示

127
00:07:23,000 --> 00:07:27,000
虽然在PyTorch里面虽然说是说使用了一个计算图

128
00:07:27,000 --> 00:07:29,000
或者完整表示的一个图

129
00:07:29,000 --> 00:07:32,000
而是一个虚拟的统一表示的图

130
00:07:32,000 --> 00:07:34,000
这个图只是一个简单的概念

131
00:07:34,000 --> 00:07:37,000
在后面在真正的调度和执行的时候

132
00:07:37,000 --> 00:07:40,000
还是跟前端的语言相绑定的

133
00:07:40,000 --> 00:07:44,000
也就是我们刚才说的我定义完了一个语言之后

134
00:07:44,000 --> 00:07:46,000
我定义完一行代码程序之后

135
00:07:46,000 --> 00:07:48,000
我后面就会进行一个执行

136
00:07:48,000 --> 00:07:49,000
只是为了方便理解

137
00:07:49,000 --> 00:07:53,000
我们可能把它变成一个统一的表示的计算图

138
00:07:54,000 --> 00:07:57,000
第二个我们刚才看到前面一个图

139
00:07:57,000 --> 00:07:59,000
其实我们有很多关于运行时的

140
00:07:59,000 --> 00:08:01,000
还有优化层的一些内容

141
00:08:01,000 --> 00:08:04,000
内核代码的优化和变异

142
00:08:04,000 --> 00:08:07,000
但是实际上到了PyTorch这里面

143
00:08:07,000 --> 00:08:09,000
刚才的那些层数都没有了

144
00:08:09,000 --> 00:08:11,000
也就是缺乏编译期的优化

145
00:08:11,000 --> 00:08:15,000
编译的优化我们是对统一表示进行优化的

146
00:08:15,000 --> 00:08:18,000
因为计算机里面其实我们要做IR

147
00:08:18,000 --> 00:08:19,000
这个就是统一表示

148
00:08:19,000 --> 00:08:21,000
就是我们编译器的其中一个概念

149
00:08:21,000 --> 00:08:23,000
叫做IR中间表示

150
00:08:23,000 --> 00:08:25,000
那缺乏了编译期的统一的优化

151
00:08:25,000 --> 00:08:29,000
就会导致我的性能可能并不是非常友好

152
00:08:29,000 --> 00:08:31,000
所以面对于我们可能在更多

153
00:08:31,000 --> 00:08:33,000
事背上的去执行的时候

154
00:08:33,000 --> 00:08:36,000
PyTorch的性能并不是很高

155
00:08:36,000 --> 00:08:39,000
现在在很多推理部署平台

156
00:08:39,000 --> 00:08:41,000
都会有自己的一个框架

157
00:08:41,000 --> 00:08:43,000
或者我在推理部署的时候

158
00:08:43,000 --> 00:08:46,000
会把PyTorch的代码转成ONIX的代码

159
00:08:46,000 --> 00:08:50,000
然后ONIX在对接其他硬件平台

160
00:08:50,000 --> 00:08:53,000
这个就是动态图或者命令式编程

161
00:08:53,000 --> 00:08:56,000
PyTorch它带来的一些缺点

162
00:08:57,000 --> 00:09:00,000
下面我们来看看声明式编程

163
00:09:00,000 --> 00:09:03,000
声明式编程的英文叫做

164
00:09:03,000 --> 00:09:05,000
Dedicative Programming

165
00:09:05,000 --> 00:09:09,000
然后它的另外一种说法就是Defined and One

166
00:09:09,000 --> 00:09:12,000
然后最出名的代表就是Tensor 4

167
00:09:12,000 --> 00:09:15,000
是基于一个完全的静态图去执行的

168
00:09:15,000 --> 00:09:19,000
静态图去执行就非常依赖于我们的统一表示

169
00:09:19,000 --> 00:09:22,000
就是神经网络的中间表达计算图这一层

170
00:09:22,000 --> 00:09:25,000
前端跟后端不像PyTorch

171
00:09:25,000 --> 00:09:28,000
它们中间其实是偶合性是非常高的

172
00:09:28,000 --> 00:09:31,000
那PyTorch这种声明式编程或者静态图

173
00:09:31,000 --> 00:09:34,000
它的接偶程度是比较高的

174
00:09:34,000 --> 00:09:37,000
前端跟后端不完全依赖和绑定

175
00:09:37,000 --> 00:09:42,000
后端更多的是根据计算图进行一个优化和调度执行

176
00:09:42,000 --> 00:09:47,000
前端可能更多的是对计算图进行一些表示

177
00:09:47,000 --> 00:09:50,000
定义了计算图之后再定义我的前端

178
00:09:50,000 --> 00:09:53,000
所以用户学Tensor 4的时候就会觉得

179
00:09:53,000 --> 00:09:55,000
为什么它这么难学

180
00:09:55,000 --> 00:09:58,000
为什么要学那么多额外的Python的知识

181
00:09:58,000 --> 00:10:00,000
这个就是它的一个问题了

182
00:10:00,000 --> 00:10:04,000
那在执行方面就是前端的语言表达不直接执行

183
00:10:04,000 --> 00:10:07,000
刚才编程式风格的就是我定义完前端之后

184
00:10:07,000 --> 00:10:08,000
后端直接执行

185
00:10:08,000 --> 00:10:10,000
现在不直接执行

186
00:10:10,000 --> 00:10:12,000
而是通过一个IR去表示

187
00:10:12,000 --> 00:10:14,000
就是统一的计算去表示

188
00:10:14,000 --> 00:10:17,000
那对数据流图进行优化在执行

189
00:10:17,000 --> 00:10:21,000
也就是刚才比PyTorch我们多了很多一个计算图的优化

190
00:10:21,000 --> 00:10:24,000
类似的管理计算图的调度和执行

191
00:10:24,000 --> 00:10:26,000
还有内核代码的优化和编译

192
00:10:26,000 --> 00:10:28,000
还有指表达式的一些优化

193
00:10:29,000 --> 00:10:31,000
内容多了非常多

194
00:10:31,000 --> 00:10:33,000
我们可能又多了中间好几层

195
00:10:33,000 --> 00:10:37,000
所以它的优点就是执行之前得到整个程序

196
00:10:37,000 --> 00:10:40,000
或者整个神经网络的全表达

197
00:10:40,000 --> 00:10:42,000
然后可以做一些性能的优化

198
00:10:42,000 --> 00:10:45,000
编译的优化就会导致我们的性能非常高

199
00:10:45,000 --> 00:10:47,000
可能还可以对接到多的硬件

200
00:10:47,000 --> 00:10:49,000
就不同的硬件上面

201
00:10:49,000 --> 00:10:51,000
但是缺点就是不灵活

202
00:10:51,000 --> 00:10:55,000
假设我们现在用Python表达了一行语句

203
00:10:55,000 --> 00:10:59,000
但是我们的这个计算图没有跟得上来

204
00:10:59,000 --> 00:11:01,000
或者Python的某个操作方式

205
00:11:01,000 --> 00:11:04,000
没有附用某个If Else的表达方式

206
00:11:04,000 --> 00:11:06,000
这个计算图没法表达

207
00:11:06,000 --> 00:11:08,000
那就很不方便我们去编程

208
00:11:08,000 --> 00:11:10,000
它的调试也不好

209
00:11:10,000 --> 00:11:12,000
如果Python出现了控制流

210
00:11:12,000 --> 00:11:14,000
或者新的一个数学表示

211
00:11:14,000 --> 00:11:16,000
对于计算图来说我们要适配过来

212
00:11:16,000 --> 00:11:18,000
就会导致很强的约束

213
00:11:18,000 --> 00:11:21,000
一旦有约束就确实不好用

214
00:11:21,000 --> 00:11:23,000
这个就是Tensor4的问题

215
00:11:24,000 --> 00:11:29,000
既然有了两种极端的编程的范式和编程的问题

216
00:11:29,000 --> 00:11:33,000
所以后面或者后来之秀

217
00:11:33,000 --> 00:11:35,000
利用MindSpore还有Pytorch JIT

218
00:11:35,000 --> 00:11:38,000
都采用了一种融合的方式

219
00:11:38,000 --> 00:11:40,000
融合的方式有两种

220
00:11:40,000 --> 00:11:41,000
主要是有两种

221
00:11:41,000 --> 00:11:45,000
一种叫做分阶段的编程MultiStage

222
00:11:45,000 --> 00:11:47,000
另外一种就是即时编程

223
00:11:47,000 --> 00:11:49,000
我们叫Drives in Time JIT

224
00:11:49,000 --> 00:11:52,000
Pytorch又独立的开发了一个JIT的后端

225
00:11:52,000 --> 00:11:55,000
然后对Pytorch进行一个加速执行的

226
00:11:55,000 --> 00:11:58,000
为了更好地去适配到第三方的框架

227
00:11:58,000 --> 00:12:00,000
或者第三方的硬件上面

228
00:12:00,000 --> 00:12:02,000
让它执行效率更高

229
00:12:04,000 --> 00:12:07,000
而MindSpore采用的是一种函数式的编程方式

230
00:12:07,000 --> 00:12:11,000
其实跟我们刚才讲的那两种又有一点不一样

231
00:12:11,000 --> 00:12:15,000
我们就不在这里面展开MindSpore的具体编程范式

232
00:12:15,000 --> 00:12:19,000
但是我们可能会在后面去介绍怎么去使用MindSpore的时候

233
00:12:19,000 --> 00:12:23,000
给大家介绍一下MindSpore的函数式编程有什么不一样

234
00:12:26,000 --> 00:12:29,000
好了,又到了大家喜欢乐见的时候

235
00:12:29,000 --> 00:12:32,000
这是这一个系列里面最后的一节课了

236
00:12:32,000 --> 00:12:36,000
那这一节课里面我们一起回顾了深度学习的编程方式

237
00:12:36,000 --> 00:12:37,000
有两种

238
00:12:37,000 --> 00:12:39,000
第一种就是声明式编程

239
00:12:39,000 --> 00:12:41,000
另外一种是命令式编程

240
00:12:41,000 --> 00:12:47,000
其实未来我们可能可以看见的肯定是以命令式编程的应用性为主

241
00:12:47,000 --> 00:12:52,000
因为命令式的编程方式实在是太方便开发者去使用了

242
00:12:52,000 --> 00:12:58,000
但是我们也不会放弃声明式的编译优化相融合的优点

243
00:12:58,000 --> 00:13:01,000
所以它会做一个两者的结合

244
00:13:03,000 --> 00:13:04,000
好了,谢谢各位

245
00:13:04,000 --> 00:13:05,000
摆了个掰

246
00:13:06,000 --> 00:13:08,000
卷的不行了,卷的不行了

247
00:13:08,000 --> 00:13:10,000
记得一键三连加关注哦

248
00:13:10,000 --> 00:13:13,000
所有的内容都会开源在下面这条链接里面

249
00:13:13,000 --> 00:13:14,000
摆了个掰

