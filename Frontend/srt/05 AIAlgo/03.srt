1
00:00:00,000 --> 00:00:04,840
Baba Baa Baa Baa Baa Baa Baa Baa Baa

2
00:00:04,840 --> 00:00:07,000
Hello 大家好,我是宗米

3
00:00:07,000 --> 00:00:09,320
剛才12點多我們剛開完會

4
00:00:09,320 --> 00:00:11,400
然後現在我過來去錄一門課

5
00:00:11,400 --> 00:00:13,280
然後給大家分享一個知識點

6
00:00:13,280 --> 00:00:15,040
就是大模型和分步式訓練的

7
00:00:15,040 --> 00:00:16,760
這裡調侃一下

8
00:00:16,760 --> 00:00:18,680
我對生活說生活太苦了

9
00:00:18,680 --> 00:00:21,240
生活反倒給我說我給你加點糖啊

10
00:00:21,240 --> 00:00:23,280
我反倒問的是什麼糖啊

11
00:00:23,280 --> 00:00:25,680
生活說加點荒唐

12
00:00:26,640 --> 00:00:27,280
嘖

13
00:00:28,200 --> 00:00:30,400
好了,今天我們要分享的內容

14
00:00:30,400 --> 00:00:33,440
就是通訊實現和通訊元語

15
00:00:33,440 --> 00:00:34,720
那首先我們會講講

16
00:00:34,720 --> 00:00:36,560
我們通訊要實現

17
00:00:36,560 --> 00:00:39,320
那需要軟硬件具備哪些能力

18
00:00:39,320 --> 00:00:42,680
接著我們會講講通訊具體的一種實現方式

19
00:00:42,680 --> 00:00:44,600
那最後我們會去看一下

20
00:00:44,600 --> 00:00:48,280
通訊的元語到底是什麼一個概念

21
00:00:48,280 --> 00:00:50,760
因為一提到元語可能很多人不理解

22
00:00:50,760 --> 00:00:52,760
What is 元語 是吧

23
00:00:52,760 --> 00:00:54,400
所以我們現在來打開一下

24
00:00:54,440 --> 00:00:56,640
我們實現大模型分步式並行的時候

25
00:00:56,640 --> 00:00:57,840
肯定離不開通訊

26
00:00:57,840 --> 00:01:00,800
所以通訊這一節對我們來說非常的重要

27
00:01:01,880 --> 00:01:03,400
下面我們來繞一繞

28
00:01:03,400 --> 00:01:07,920
正常的計算機網絡裡面通訊兩個非常重要的評價指標

29
00:01:07,920 --> 00:01:09,360
第一個就是帶寬

30
00:01:09,360 --> 00:01:10,800
第二個就是延遲

31
00:01:10,800 --> 00:01:14,240
帶寬意味著我每一秒能夠通訊多少數據

32
00:01:14,240 --> 00:01:17,600
而延遲就是我通訊的快還是慢

33
00:01:17,600 --> 00:01:19,600
由於大規模分步式訓練裡面

34
00:01:19,600 --> 00:01:22,400
我們需要傳輸大量的網絡模型的參數

35
00:01:22,400 --> 00:01:26,520
就是我們的模型參數需要大量的同步的操作

36
00:01:26,520 --> 00:01:31,680
所以帶寬和延遲同樣對我們分步式訓練是非常的重要

37
00:01:31,680 --> 00:01:35,960
現在我們來看看通訊具體的兩種實現方式

38
00:01:35,960 --> 00:01:38,680
通訊的實現方式分兩個類型

39
00:01:38,680 --> 00:01:41,120
第一個類型就是機器類的一個通訊

40
00:01:41,120 --> 00:01:43,720
第二個類型就是機器間的通訊

41
00:01:43,720 --> 00:01:45,880
首先我們看看機器類的通訊

42
00:01:45,880 --> 00:01:49,960
現在灰色的虛框裡面就代表這是一台機器

43
00:01:49,960 --> 00:01:51,440
這是一台機器

44
00:01:51,480 --> 00:01:55,000
機器內部我們可能會通過共享內存進行通訊

45
00:01:55,000 --> 00:01:59,080
另外的話我們還可以通過PCI的超潮或者MVLink的這個方式

46
00:01:59,080 --> 00:02:00,800
進行一種通訊

47
00:02:00,800 --> 00:02:03,800
另外一種就是機器跟機器之間的通訊

48
00:02:03,800 --> 00:02:07,920
那機器跟機器之間可能更多的會通過TCPIP這種

49
00:02:07,920 --> 00:02:12,440
Sockit的網絡模型或者RDMA方式的網卡進行通訊

50
00:02:12,440 --> 00:02:14,560
主要有這兩種實現方式

51
00:02:14,560 --> 00:02:18,320
那具體怎麼去實現這些機器跟機器之間

52
00:02:18,320 --> 00:02:21,560
機器內部的通訊我們往下繼續看

53
00:02:21,560 --> 00:02:24,200
那機器類的通訊剛才講了有兩種

54
00:02:24,200 --> 00:02:26,080
第一種就是共享內存

55
00:02:26,080 --> 00:02:28,200
假設我這裡面有一款CPU

56
00:02:28,200 --> 00:02:30,200
這裡面有另外一款CPU

57
00:02:30,200 --> 00:02:34,280
那CPU跟CPU之間我可能會共享同一塊內存

58
00:02:34,280 --> 00:02:35,840
或者多核處理器的時候

59
00:02:35,840 --> 00:02:38,720
我們可能會共享相同的內存

60
00:02:38,720 --> 00:02:42,640
這個共享內存在我們手機裡面是最明顯的

61
00:02:42,640 --> 00:02:44,800
就是我手機有很多不同的IC

62
00:02:44,800 --> 00:02:45,600
我有CPU

63
00:02:45,600 --> 00:02:46,360
我有GPU

64
00:02:46,360 --> 00:02:47,840
我可能還會有ISP

65
00:02:47,840 --> 00:02:51,720
可能都會共享同一款手機裡面的內存

66
00:02:51,720 --> 00:02:55,520
那第二個就是PCIe這種方式

67
00:02:55,520 --> 00:02:59,440
PCIe最明顯的方式就是GPU跟CPU之間的通訊

68
00:02:59,440 --> 00:03:02,520
大部分都是通過PCIe的插槽進行通訊的

69
00:03:02,520 --> 00:03:08,480
而NVLink這種方式更多的是GPU跟GPU之間進行互聯互通

70
00:03:08,480 --> 00:03:11,600
下面來看看機器間的一個通訊

71
00:03:11,600 --> 00:03:14,960
那下面左邊的這個框就是一台機器

72
00:03:14,960 --> 00:03:17,320
中間這個框又是另外一台機器

73
00:03:17,360 --> 00:03:20,200
機器跟機器之間是會進行通訊的

74
00:03:20,200 --> 00:03:24,520
那更多的通訊方式是通過網絡的方式來進行通訊的

75
00:03:24,520 --> 00:03:26,160
也就是上面這條藍色

76
00:03:26,160 --> 00:03:29,240
我們更多的通過網線進行連接

77
00:03:29,240 --> 00:03:34,760
另外我們在AI集群裡面可能更多的會用到RDMA的一種網絡方式

78
00:03:34,760 --> 00:03:37,800
那在AI集團中心或者AI集群裡面

79
00:03:37,800 --> 00:03:42,200
實際上我們更多的會採用RDMA的網絡模型通訊

80
00:03:42,200 --> 00:03:45,000
下面我們來看看具體的這些有什麼區別

81
00:03:45,000 --> 00:03:47,080
或者再解釋一下這些概念

82
00:03:48,440 --> 00:03:50,760
下面我們正式的來到一個硬件篇

83
00:03:50,760 --> 00:03:52,880
我們來看看這個硬件加入圖

84
00:03:52,880 --> 00:03:59,360
這個圖就是OpenPower IBM G1英偉達Tesla P100出了一款GPU集群

85
00:03:59,360 --> 00:04:04,080
那這裡面GPU跟GPU之間是通過NVLink進行一個通訊的

86
00:04:04,080 --> 00:04:08,000
就看到我們可以看到下面綠色的這個就是NVLink

87
00:04:08,000 --> 00:04:11,600
然後GPU跟CPU之間也是通過NVLink進行通訊的

88
00:04:11,600 --> 00:04:18,400
但是GPUCPU跟CPU之間反倒是通過總線區共享內存的方式進行通訊的

89
00:04:18,400 --> 00:04:22,880
服務器跟服務器之間是通過RDMA網卡進行通訊的

90
00:04:22,880 --> 00:04:24,760
而什麼是PCIe插槽

91
00:04:24,760 --> 00:04:27,200
現在我們來看看Wiki的定義

92
00:04:27,200 --> 00:04:31,360
維基百科裡面說了PCIe其實那個e是expressed的e

93
00:04:31,360 --> 00:04:34,240
是計算機總線的一個重要的分支

94
00:04:34,240 --> 00:04:39,120
沿用了原來的PCIe編程的概念和信號的標準

95
00:04:39,120 --> 00:04:42,640
構建了更加高速的串型通訊的系統標準

96
00:04:42,640 --> 00:04:43,920
那簡單的來說

97
00:04:43,920 --> 00:04:46,160
它就是一個通訊的標準

98
00:04:46,160 --> 00:04:48,640
在以前PCIe出現之前

99
00:04:48,640 --> 00:04:49,960
我們在計算機裡面

100
00:04:49,960 --> 00:04:52,120
或者我們組裝計算機的時候

101
00:04:52,120 --> 00:04:54,720
通常都會有一個藍橋北橋

102
00:04:54,720 --> 00:04:56,640
那現在通過PCIe的插槽

103
00:04:56,640 --> 00:04:59,160
我們解決了藍北橋的問題

104
00:04:59,160 --> 00:05:02,600
直接通過PCIe這個總線進行一個通訊

105
00:05:02,600 --> 00:05:03,680
下面這個圖

106
00:05:03,680 --> 00:05:05,560
不管是長的短的

107
00:05:05,560 --> 00:05:08,200
這種都是PCIe的一個插槽

108
00:05:08,200 --> 00:05:10,760
而現在PCIe這個通訊協議

109
00:05:10,760 --> 00:05:13,320
從1.1已經發展到5.0

110
00:05:13,320 --> 00:05:16,640
而現在正在邁入6.0的時代

111
00:05:16,640 --> 00:05:20,560
PCIe的傳輸速率其實還不夠高

112
00:05:20,560 --> 00:05:24,000
英偉達就發明了MV-Link這種傳輸方式

113
00:05:24,000 --> 00:05:27,760
MV-Link最主要的特徵就是非常的高速

114
00:05:27,760 --> 00:05:30,240
而且有非常多的通道

115
00:05:30,240 --> 00:05:33,000
通過插分庫的雙向鏈路來去實現的

116
00:05:33,000 --> 00:05:34,440
左邊這個圖

117
00:05:34,440 --> 00:05:36,160
GPU跟CPU之間

118
00:05:36,200 --> 00:05:38,760
可以通過MV-Link的方式進行連接

119
00:05:38,760 --> 00:05:43,200
但是這種方式就要求CPU是支持MV-Link這個協議

120
00:05:43,200 --> 00:05:46,000
右邊的這個圖更多是現在常用的

121
00:05:46,000 --> 00:05:48,080
就是GPU跟GPU之間互聯

122
00:05:48,080 --> 00:05:51,520
更多的是使用MV-Link進行傳輸的

123
00:05:51,520 --> 00:05:54,480
現在我們來看看一般的MV-Link是怎麼工作的

124
00:05:54,480 --> 00:05:58,600
首先CPU會發起一個Tag或者一個任務

125
00:05:58,600 --> 00:06:02,120
這個任務現在還是通過PCIe來進行一個連接的

126
00:06:02,120 --> 00:06:05,280
接著我們還會保留PCIe的編程接口

127
00:06:05,280 --> 00:06:08,960
同時可以觸發我們GPU跟GPU之間互聯

128
00:06:08,960 --> 00:06:10,800
那我們在上一天裡面講到

129
00:06:10,800 --> 00:06:15,880
其實我們這個互聯方式實際上是通過MV-Link進行連接的

130
00:06:15,880 --> 00:06:19,440
這裡面我們就會對GPU跟GPU之間組成一個環

131
00:06:19,440 --> 00:06:21,760
更方便我們做集合通訊

132
00:06:21,760 --> 00:06:24,280
現在我們看看另外一個很重要的概念

133
00:06:24,280 --> 00:06:28,280
就是RDMA Remote Direct Memory Assessed

134
00:06:28,280 --> 00:06:30,520
直接聽名字可能覺得很陌生

135
00:06:30,520 --> 00:06:33,800
但是一看它的英文詳細可能就非常直接了

136
00:06:33,800 --> 00:06:36,480
我們簡單的說就是遠程內存直連

137
00:06:36,480 --> 00:06:38,320
它有三個重要的特性

138
00:06:38,320 --> 00:06:40,360
這三個特性實在太重要了

139
00:06:40,360 --> 00:06:42,440
這第一個就是CPU Offload

140
00:06:42,440 --> 00:06:44,320
就不需要CPU進行干預

141
00:06:44,320 --> 00:06:46,440
我可以直連我們的內存

142
00:06:46,440 --> 00:06:48,600
第二個就是Kernel Bypassed Cut

143
00:06:48,600 --> 00:06:51,160
這裡面我們的通訊不需要Kernel程序執行

144
00:06:51,160 --> 00:06:53,960
可以在用戶Tag進行數據的傳輸

145
00:06:53,960 --> 00:06:56,760
第三個特性就是Cellul Copy

146
00:06:56,760 --> 00:07:00,600
用戶的應用程序直接可以訪問集區裡面的虛擬內存

147
00:07:00,600 --> 00:07:02,320
這三個特性非常重要

148
00:07:02,320 --> 00:07:04,360
我們來看看下面的圖

149
00:07:04,360 --> 00:07:06,240
左邊就是傳統的網絡通訊

150
00:07:06,240 --> 00:07:09,080
右邊就是RDMA的一個通訊方式

151
00:07:09,080 --> 00:07:12,840
傳統的網絡通訊採用的是TCP IP的網絡通訊

152
00:07:12,840 --> 00:07:15,720
以前主要是以發送一些很小的數據

153
00:07:15,720 --> 00:07:17,640
或者很小的消息為主

154
00:07:17,640 --> 00:07:20,520
所以那時候我們聚焦的點就是處理我們的延遲

155
00:07:20,520 --> 00:07:21,880
通訊的延遲

156
00:07:21,880 --> 00:07:25,600
這是我們提升整個網絡性能的一個關鍵的點

157
00:07:25,600 --> 00:07:28,280
從左邊的圖好幾個藍色的方塊了

158
00:07:28,280 --> 00:07:29,840
我們可以看到裡面有Socket

159
00:07:29,840 --> 00:07:32,520
TCP IP還有Nerva Devices

160
00:07:32,520 --> 00:07:36,360
這個過程就需要經歷非常多的用戶的內存拷貝

161
00:07:36,360 --> 00:07:39,120
所以它執行起來可能會非常的緩慢

162
00:07:39,120 --> 00:07:41,080
而我們的數據量越大的時候

163
00:07:41,080 --> 00:07:43,560
這個延遲對我們來說是很難去接受的

164
00:07:44,560 --> 00:07:47,760
而RDMA新的協議就是用戶跳開Kernel層

165
00:07:47,760 --> 00:07:51,560
就Kernel Bypass直接傳到軟端的服務器

166
00:07:51,560 --> 00:07:55,200
數據要過CPU直接通過RDMA設備

167
00:07:55,200 --> 00:07:58,560
對軟端的虛擬內存直接進行訪問讀和寫

168
00:07:58,560 --> 00:08:01,520
通過簡單的介紹剛才的幾個硬件設備

169
00:08:01,520 --> 00:08:03,320
包括PCIe還有MVLink

170
00:08:03,320 --> 00:08:05,120
還有Infinity Band

171
00:08:05,120 --> 00:08:08,080
RDMA幾種方式我們了解到了

172
00:08:08,080 --> 00:08:09,360
機器內的通訊

173
00:08:09,360 --> 00:08:14,080
CPU跟CPU之間可能更多的通過總線來共享內存

174
00:08:14,080 --> 00:08:19,400
第二個CPU跟GPU之間可能會通過PCIe這個插槽進行連接

175
00:08:19,400 --> 00:08:24,000
GPU跟GPU之間更多會通過MVLink的方式進行通訊

176
00:08:24,000 --> 00:08:26,000
而夸機器之間的通訊

177
00:08:26,040 --> 00:08:27,520
更多通過網絡

178
00:08:27,520 --> 00:08:32,160
AI集群裡面更多的是使用RDMA這種網絡協議的方式進行通訊

179
00:08:33,280 --> 00:08:36,200
下面我們來看一下一個互聯的TOP

180
00:08:36,200 --> 00:08:38,600
只是只有PCIe的時候

181
00:08:38,600 --> 00:08:40,440
一般下面我們有8個卡

182
00:08:40,440 --> 00:08:43,800
8個卡之間一般是通過PCIe插槽

183
00:08:43,800 --> 00:08:46,280
跟我們的X86CPU進行通訊

184
00:08:46,280 --> 00:08:49,240
在英偉達的DGSD一代裡面

185
00:08:49,240 --> 00:08:53,200
中間的這些綠色的線就是通過MVLink進行互聯

186
00:08:53,200 --> 00:08:54,560
然後形成一個環

187
00:08:54,560 --> 00:08:58,720
最後通過PCIe插槽跟我們的X86進行一個連接

188
00:08:59,800 --> 00:09:01,680
後來DGX第二代的時候

189
00:09:01,680 --> 00:09:04,280
英偉達就對MVLink進行一個組合

190
00:09:04,280 --> 00:09:09,440
變成一個MVSwitch的這種網絡通訊路由的方式

191
00:09:09,440 --> 00:09:12,360
連接更多的GPU的芯片

192
00:09:12,360 --> 00:09:16,520
最後就是剛才我們講的機器跟機器之間的一個通訊

193
00:09:16,520 --> 00:09:20,680
就是通過我們的網線或者我的RDMA的方式進行通訊的

194
00:09:21,680 --> 00:09:24,760
了解完硬件我們看看軟件篇

195
00:09:24,760 --> 00:09:26,280
軟件篇其實很好理解

196
00:09:26,280 --> 00:09:27,560
概念也比較簡單

197
00:09:27,560 --> 00:09:28,960
第一個就是NPI

198
00:09:28,960 --> 00:09:30,320
第二個就是NCCL

199
00:09:30,320 --> 00:09:33,360
NCCL就是英偉達的網絡通訊協議

200
00:09:33,360 --> 00:09:36,360
那HCCL就是華為的網絡通訊協議

201
00:09:36,360 --> 00:09:39,200
還有Facebook發明的G2OO3總

202
00:09:39,200 --> 00:09:44,440
第一種NPI就是定義了非常多的元語的接收方式

203
00:09:44,440 --> 00:09:47,680
那一開始它主要是對點對點通訊的

204
00:09:47,680 --> 00:09:49,560
就是點跟點之間通訊

205
00:09:49,600 --> 00:09:51,160
我一個數據發送

206
00:09:51,160 --> 00:09:53,920
我一個數據做接收這種方式

207
00:09:53,920 --> 00:09:56,320
後來NPI推出了集合通訊

208
00:09:56,320 --> 00:10:01,600
但是集合通訊還是建立在點對點的通訊方式的基礎進行一個拓展

209
00:10:02,680 --> 00:10:05,280
NCCL我們以英偉達作為例子

210
00:10:05,280 --> 00:10:06,640
首先它的工作方式

211
00:10:06,640 --> 00:10:09,360
我需要對網絡的TOP進行一個感知

212
00:10:09,360 --> 00:10:11,800
知道我的網絡TOP到底長什麼樣子的

213
00:10:11,800 --> 00:10:14,880
我的回還到底是如何的組織方式

214
00:10:14,880 --> 00:10:17,640
接著我可能會去做一個Graph的Search

215
00:10:17,680 --> 00:10:19,960
就是對我們的網絡TOP進行搜索

216
00:10:19,960 --> 00:10:22,280
找到一個最好的通訊的策略

217
00:10:22,600 --> 00:10:26,120
最後就使能Cuda的Kernel對我們的數據進行通訊

218
00:10:26,360 --> 00:10:32,880
下面中間的這個圖是我截取Pytouch對G2OO、NPI和NCCL的一個支持情況

219
00:10:32,880 --> 00:10:36,480
可以看到NPI大部分都是在CPU上面去執行的

220
00:10:36,480 --> 00:10:39,240
而NCCL主要是支持我們的GPU

221
00:10:39,240 --> 00:10:41,080
GPU支持的模式非常多

222
00:10:41,080 --> 00:10:44,080
而G2OO有點易難進

223
00:10:44,320 --> 00:10:45,920
但是大部分是支持CPU

224
00:10:45,920 --> 00:10:48,040
然後GPU也有部分的支持

225
00:10:48,040 --> 00:10:49,720
可能還不是說非常完善

226
00:10:49,720 --> 00:10:52,080
所以大家參考著來使用

227
00:10:52,760 --> 00:10:54,280
聊到通訊的實現方式

228
00:10:54,400 --> 00:10:57,760
其實我們剛才在講NPI的時候已經簡單的提到了

229
00:10:57,760 --> 00:10:59,720
我們有點對點的通訊

230
00:10:59,720 --> 00:11:01,280
一個是接收一個是發送

231
00:11:01,280 --> 00:11:02,680
就Send和Receive

232
00:11:02,680 --> 00:11:06,320
然後集合通訊就是All with Deuce這種方式

233
00:11:07,320 --> 00:11:09,720
點對點的通訊還是比較粗暴的

234
00:11:09,720 --> 00:11:11,080
就是我服務器0

235
00:11:11,160 --> 00:11:14,560
把我的數據傳送到服務器3

236
00:11:15,000 --> 00:11:17,680
那這裡面Pytouch支持點對點的通訊

237
00:11:17,680 --> 00:11:20,000
直接去聲明我的一個數據是Send

238
00:11:20,000 --> 00:11:21,800
一個數據是Receive就可以了

239
00:11:22,680 --> 00:11:26,360
集合通訊我們會在接下來的內容裡面去詳細的展開

240
00:11:26,840 --> 00:11:29,440
Pytouch可以直接調我們的集合通訊的方式

241
00:11:29,440 --> 00:11:31,800
直接在我們的代碼裡面聲明All with Deuce

242
00:11:32,880 --> 00:11:34,440
今天的內容比較簡單

243
00:11:34,440 --> 00:11:38,280
我們下一節將會詳細的去展開集合通訊的具體的方式

244
00:11:38,360 --> 00:11:40,120
我們今天就了解了機器內部

245
00:11:40,120 --> 00:11:42,520
還有機器之間的具體的通訊方式

246
00:11:43,240 --> 00:11:44,800
另外的話我們還了解了硬件

247
00:11:44,800 --> 00:11:46,360
會通過PCIe NVLink

248
00:11:46,360 --> 00:11:48,960
還有RDMA的方式針對不同的場景

249
00:11:48,960 --> 00:11:50,960
或者不同的機器的組合方式

250
00:11:50,960 --> 00:11:53,000
來去實現我們的硬件通訊的

251
00:11:53,000 --> 00:11:54,280
而在軟件層面

252
00:11:54,280 --> 00:11:56,280
我們會通過NPI GLO

253
00:11:56,280 --> 00:11:58,680
還有XCL的實現方式

254
00:11:58,680 --> 00:12:01,000
另外我們還簡單的了解了

255
00:12:01,000 --> 00:12:04,320
點對點通訊和集合通訊的具體的差異

256
00:12:05,600 --> 00:12:07,160
在這麼累卷的環境下

257
00:12:07,160 --> 00:12:09,640
做到經常更新時速不易

258
00:12:09,640 --> 00:12:12,240
非常歡迎大家對我一鍵三年

259
00:12:12,240 --> 00:12:13,080
謝謝各位

260
00:12:13,080 --> 00:12:13,960
百樂個掰

